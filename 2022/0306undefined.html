<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Hexo">
    <meta name="description" content="方法名
java 基本语法1、注释
什么事注释

注释是写在程序中对代码进行解释说明的文字,方便自己和其他人查看，以便理解程序的。


注释有哪些

单行注释
//注释内容，只能写一行

多行注释
1234/*	注释内容1	注释内容2*/
">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    
    <style>
        body{
            background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>


    <title>Hexo</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.1"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Hexo</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Hexo</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-03-06
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    37.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    139 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>方法名</p>
<h1 id="java-基本语法"><a href="#java-基本语法" class="headerlink" title="java 基本语法"></a>java 基本语法</h1><h2 id="1、注释"><a href="#1、注释" class="headerlink" title="1、注释"></a>1、注释</h2><ul>
<li><p><strong>什么事注释</strong></p>
<ul>
<li>注释是写在程序中对代码进行解释说明的文字,方便自己和其他人查看，以便理解程序的。</li>
</ul>
</li>
<li><p><strong>注释有哪些</strong></p>
<ul>
<li><p>单行注释</p>
<p><code>//注释内容，只能写一行</code></p>
</li>
<li><p>多行注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	注释内容1</span></span><br><span class="line"><span class="comment">	注释内容2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>文档注释</strong></p>
<ul>
<li><p>对文档中的注释是可以提取到一个程序说明文档中去的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	注释内容</span></span><br><span class="line"><span class="comment">	注释内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>注释不影响程序运行</p>
</li>
<li><p>小技巧</p>
<table>
<thead>
<tr>
<th>快捷键进行注释</th>
<th>功能效果</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+ /</td>
<td>单行注释(对当前行进行注释)</td>
</tr>
<tr>
<td>Ctrl+ Shift + /</td>
<td>对选中的代码进行多行注释</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="2、字面量"><a href="#2、字面量" class="headerlink" title="2、字面量"></a>2、字面量</h2><ul>
<li><p>计算机是用来处理数据的，字面量就是告诉程序员:数据在程序中的书写格式。</p>
<p><strong>常用数据</strong></p>
<table>
<thead>
<tr>
<th>常用数据</th>
<th>生活中的写法</th>
<th>程序中的写法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>整数</td>
<td>666,-88</td>
<td>666,-88</td>
<td>写法一致</td>
</tr>
<tr>
<td>小数</td>
<td>13.14 ,-5.12</td>
<td>13.14 ,-5.12</td>
<td>写法一致</td>
</tr>
<tr>
<td>字符</td>
<td>a,b,我</td>
<td>‘a’ ,‘b’ ,‘我’</td>
<td>程序中使用单引号，有且只有一个字符</td>
</tr>
<tr>
<td>字符串</td>
<td>hello world</td>
<td>“hello world”</td>
<td>程序中使用双引号，内容可有可无</td>
</tr>
<tr>
<td>布尔值</td>
<td>真假</td>
<td>true  false</td>
<td>只有两个值：true代表真，false代表假</td>
</tr>
<tr>
<td>空值</td>
<td></td>
<td>值是：null</td>
<td>一个特殊的值，空值</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h2><p><strong>什么是变量</strong></p>
<ul>
<li>变量就是用来存储-一个数据的内存区域(可以理解成盒子) ,且里面存储的数据可以变化。</li>
</ul>
<p>变量定义的格式</p>
<p>数据类型[^type]  变量名称[^name] = 初始值[^value]</p>
<p>[^type]:强制限制盒子中存储数据的形式。例如: int (整数类型)、double(小数类型)<br>[^name]:首字母建议小写，有意义<br>[^value]:存储的初始数据</p>
<h2 id="4、变量使用注意事项"><a href="#4、变量使用注意事项" class="headerlink" title="4、变量使用注意事项"></a>4、变量使用注意事项</h2><ul>
<li>变量要先声明在使用</li>
<li>变量声明后，不能存储其他类型的数据</li>
<li>变量的有效范围是从定义开始到“;”结束，且在用一个范围内不能定义2个同名的变量</li>
<li>变量定义的时候可以没有初始值，但是使用的时候必须给初始值</li>
</ul>
<h2 id="5、变量里的数据在计算机中的底层原理"><a href="#5、变量里的数据在计算机中的底层原理" class="headerlink" title="5、变量里的数据在计算机中的底层原理"></a>5、变量里的数据在计算机中的底层原理</h2><ul>
<li><p>二进制</p>
<ul>
<li>只有0、1，按照逢2进1的方式表示数据</li>
</ul>
</li>
<li><p>十进制转二进制算法</p>
<ul>
<li>除二取余法</li>
</ul>
</li>
<li><p>计算机中数据的最小单位</p>
<ul>
<li><p>最小保存单位：使用8个二进制为一组来保存数据，我们称之为一个字节(byte,简称B)</p>
<p>其中，每个二进制位称之为一位(bit,简称b)，1byte = 8bit 简写 1B = 8b</p>
</li>
</ul>
</li>
<li><p>图片数据</p>
<ul>
<li>图片就是无数个像素点组成的</li>
<li>每个像素点的数据：用<code>0~255*255*255</code>表示其颜色</li>
</ul>
</li>
<li><p>声音数据</p>
<ul>
<li>用二进制存储</li>
</ul>
</li>
<li><p>二进制转十进制</p>
<ul>
<li>每个位的数 乘以权重相加</li>
</ul>
</li>
<li><p>八进制、十六进制</p>
<ul>
<li>为了便于观察和表示二进制，推出了八进制和十六进制</li>
<li>没三位二进制作为一个单元，最小数是0，最大数是7，共八个数字，就是八进制。</li>
<li>没四位二进制作为一个单元，最小数是0，最大数是15，共16个数字，一次用0~9</li>
<li>A B C D E F代表的就是十六进制</li>
</ul>
</li>
<li><p>java程序中支持书写二进制、八进制、十六进制的数据，分别需以0B、0、0X或者0x开头</p>
</li>
<li><p>计算机的数据单位</p>
</li>
<li><p>计算机最小的组成单元是：字节，1B = 8b</p>
</li>
<li><p>在B的基础上，计算机发展出了KB、MB、GB、TB这些数据单位，相邻之间以1024进位</p>
</li>
</ul>
<h2 id="6、数据类型"><a href="#6、数据类型" class="headerlink" title="6、数据类型"></a>6、数据类型</h2><h3 id="6-1数据类型的分类"><a href="#6-1数据类型的分类" class="headerlink" title="6.1数据类型的分类"></a>6.1数据类型的分类</h3><ul>
<li><p>引用数据类型(除基本数据类型之外的，如String)</p>
</li>
<li><p>基本数据类型：4大类8种</p>
<ul>
<li><p>整数</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>取值范围</th>
<th>内存占用</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>-2^7^~2^7^-1</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>-2^15^~2^15^-1</td>
<td>2</td>
</tr>
<tr>
<td>int(默认)</td>
<td>-2^31^~2^31^-1</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>-2^63^~2^63^-1</td>
<td>8</td>
</tr>
</tbody></table>
</li>
<li><p>浮点数</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>取值范围</th>
<th>内存占用</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>1.401298e-45~3.04823e+38</td>
<td>4</td>
</tr>
<tr>
<td>double(默认)</td>
<td>4.9000000e-324~1.797693e+308</td>
<td>8</td>
</tr>
</tbody></table>
</li>
<li><p>字符</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>取值范围</th>
<th>内存占用</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>0~65535</td>
<td>2</td>
</tr>
</tbody></table>
</li>
<li><p>布尔</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>取值范围</th>
<th>内存占用</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>true,false</td>
<td>1</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="7、关键字、标识符"><a href="#7、关键字、标识符" class="headerlink" title="7、关键字、标识符"></a>7、关键字、标识符</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li>Java自己保留的一些单词,作为特殊功能的，例如: public、 class, byte、 short、 int、 long、 double…</li>
<li>我们不能用来作为类名或者是变量名称，否则报错。</li>
<li>注意:关键字很多，不用刻意去记。</li>
</ul>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul>
<li><p>标志符就是由一-些字符、符号组合起来的名称，用于给类，方法，变量等起名字的规矩。</p>
</li>
<li><p>标识符的要求</p>
<ul>
<li>基本要求:由数字、字母、下划线( )和美元符($)等组成</li>
<li>强制要求:不能以数字开头、不能是关键字、区分大小写</li>
</ul>
</li>
<li><p>命名指导规范</p>
<ul>
<li>变量名称:     满足标识符规则，建议全英文、有意义、首字母小写,满足“驼峰模式”,例如: int studyNumber = 59。</li>
<li>类名称:        满足标识符规则，建议全英文、有意义、首字母大写,满足“驼峰模式”，例如: HelloWorld. java。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="1、自动类型转换"><a href="#1、自动类型转换" class="headerlink" title="1、自动类型转换"></a>1、自动类型转换</h2><ul>
<li>类型范围小的变量，可以直接赋值给类型范围大的变量。</li>
</ul>
<p>自动类型转换的其他形式</p>
<p><code>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</code></p>
<h2 id="2、表达式中的自动类型转换"><a href="#2、表达式中的自动类型转换" class="headerlink" title="2、表达式中的自动类型转换"></a>2、表达式中的自动类型转换</h2><ul>
<li><p>在表达式中，小范围的变量会自动转换成较大范围的类型在计算</p>
<p><code>byte、short、char、-&gt;int-&gt;long-&gt;float-&gt;double</code></p>
</li>
<li><p>注意事项</p>
<ul>
<li>表达式的最终结果类型由表达式中的最高类型决定</li>
<li>在表达式中，byte、short、char是直接转简称int类型参与计算的</li>
</ul>
</li>
</ul>
<h2 id="3、强制类型转化"><a href="#3、强制类型转化" class="headerlink" title="3、强制类型转化"></a>3、强制类型转化</h2><p><strong>问题</strong></p>
<ul>
<li><p>类型范围大的数据或变量，不能直接赋值给类型小的变量</p>
<p><code>数据类型 变量2 = (数据类型)变量1、数据</code></p>
</li>
</ul>
<p>注意事项</p>
<ul>
<li>强制类型转换可能造成数据(丢失)溢出</li>
<li>浮点型强转成整形，直接丢掉小数部分，保留整数部分返回</li>
</ul>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul>
<li>对字面量或者变量进行操作的符号</li>
</ul>
<h2 id="1、算数运算符"><a href="#1、算数运算符" class="headerlink" title="1、算数运算符"></a>1、算数运算符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加</td>
<td>+</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>-</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>X</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>与÷相同，在java中两个整数相除等于整除</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>获取的是两个数据做除法的余数</td>
</tr>
</tbody></table>
<ul>
<li><p>案例</p>
<ul>
<li><p>一个三位数，将其拆分为个位、十位、百位后，打印在控制台</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">369</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> data %<span class="number">10</span>;</span><br><span class="line">System.out.println(a);</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> data / <span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">System.out.println(b);</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> data / <span class="number">100</span>;</span><br><span class="line">System.out.println(c);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2、-符号做连接符"><a href="#2、-符号做连接符" class="headerlink" title="2、+符号做连接符"></a>2、+符号做连接符</h2><ul>
<li>符号与字符串运算的时候是用作连接符的，其结果依然是-个字符串。</li>
</ul>
<h2 id="3、自增自减运算符"><a href="#3、自增自减运算符" class="headerlink" title="3、自增自减运算符"></a>3、自增自减运算符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>++</td>
<td>自增</td>
<td>变量自身的值加一</td>
</tr>
<tr>
<td>–</td>
<td>自减</td>
<td>变量自身的值减一</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li><p>++和–即=既可以放在变量的后边，也可以放在变量的前边</p>
</li>
<li><p>++、–只能操作变量，不能操作字面量</p>
</li>
<li><p>++、–如果不是单独使用(如在表达式中、或者同时有其他操作)，放在变量前后会有明显区别</p>
<ul>
<li>如果放在前面，先对变量进行+1、-1，再拿变量的值进行计算</li>
<li>放在变量的后边，先拿变量的值进行运算，在对变量值进行+1、-1</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">r3</span> <span class="operator">=</span> c++ + ++c - --d - ++d + <span class="number">1</span> + c--;</span><br><span class="line">System.out.plintln(r3);<span class="comment">//23</span></span><br><span class="line">System.out.plintln(c);<span class="number">11</span></span><br><span class="line">System.out.plintln(d);<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、赋值运算符"><a href="#4、赋值运算符" class="headerlink" title="4、赋值运算符"></a>4、赋值运算符</h2><h3 id="4-1-基本赋值运算符"><a href="#4-1-基本赋值运算符" class="headerlink" title="4.1 基本赋值运算符"></a>4.1 基本赋值运算符</h3><ul>
<li>就是“=”</li>
<li><code>int a = 10;//先看“=”左边，把数值10费左边的变量a存储</code></li>
</ul>
<h3 id="4-2-扩展赋值运算符"><a href="#4-2-扩展赋值运算符" class="headerlink" title="4.2 扩展赋值运算符"></a>4.2 扩展赋值运算符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+=</td>
<td>加后赋值</td>
<td>a+=b等价于a=(a的数据类型)(a+b);将a+b的值给a</td>
</tr>
<tr>
<td>-=</td>
<td>减后赋值</td>
<td>a-=b等价于a=(a的数据类型)(a-b);将a-b的值给a</td>
</tr>
<tr>
<td>*=</td>
<td>乘后赋值</td>
<td>a*=b等价于a=(a的数据类型)(a<em>b);将a</em>b的值给a</td>
</tr>
<tr>
<td>/=</td>
<td>除后赋值</td>
<td>a/=b等价于a=(a的数据类型)(a/b);将a/b的值给a</td>
</tr>
<tr>
<td>%=</td>
<td>取余后赋值</td>
<td>a%=b等价于a=(a的数据类型)(a%b);将a%b的值给a</td>
</tr>
</tbody></table>
<p><em><strong>注意：扩展后的运算符隐含了强制转换的类型</strong></em></p>
<h3 id="4-3-关系运算符"><a href="#4-3-关系运算符" class="headerlink" title="4.3 关系运算符"></a>4.3 关系运算符</h3><ul>
<li>是对符号进行条件判断的符号，最终会返回一个比较的布尔结果(false,true)</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>a==b,判断a与b是否相等，成立为true,不成立为false</td>
</tr>
<tr>
<td>!=</td>
<td>a!=b,判断a与b是否不相等，成立为true,不成立为false</td>
</tr>
<tr>
<td>&gt;</td>
<td>a&gt;b,判断a是否大于b，成立为true,不成立为false</td>
</tr>
<tr>
<td>&gt;=</td>
<td>a&gt;=b,判断a是否大于或等于b，成立为true,不成立为false</td>
</tr>
<tr>
<td>&lt;</td>
<td>a&lt;b,判断a是否小于b，成立为true,不成立为false</td>
</tr>
<tr>
<td>&lt;=</td>
<td>a&lt;=b,判断a是否小于或等于b，成立为true,不成立为false</td>
</tr>
</tbody></table>
<h3 id="4-4逻辑运算符"><a href="#4-4逻辑运算符" class="headerlink" title="4.4逻辑运算符"></a>4.4逻辑运算符</h3><ul>
<li>可以把多个条件的布尔结果放在一起运算，最终返回一个布尔结果</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>介绍</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>逻辑与</td>
<td>必须都是true，结果才是true</td>
</tr>
<tr>
<td>|</td>
<td>逻辑或</td>
<td>只要有一个为true,结果就是true</td>
</tr>
<tr>
<td>！</td>
<td>逻辑非</td>
<td>你真我假，你假我真!true = false、!false = true</td>
</tr>
<tr>
<td>^</td>
<td>逻辑异或</td>
<td>如果两个条件都为false或者都是true结果是false,两个结果不同结果是true</td>
</tr>
</tbody></table>
<ul>
<li><p>短路逻辑运算符</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>介绍</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>短路与</td>
<td>判断结果与&amp;一样，过程是左边为false则右边不执行</td>
</tr>
<tr>
<td>||</td>
<td>短路或</td>
<td>判断结果与|一样，过程是左边为true则右边不执行</td>
</tr>
</tbody></table>
</li>
<li><p>注意</p>
<ul>
<li>逻辑&amp;、逻辑|“无论左边怎么样，右边都要执行</li>
</ul>
</li>
</ul>
<h3 id="4-5三元运算符"><a href="#4-5三元运算符" class="headerlink" title="4.5三元运算符"></a>4.5三元运算符</h3><ul>
<li><p>格式：<code>条件表达式？值1：值2；</code></p>
</li>
<li><p>执行流程：首先计算关系表达式的值，如果为true，返回值1，若为false，返回值2</p>
</li>
<li><p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">98</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> score &gt; <span class="number">60</span> ? <span class="string">&quot;及格&quot;</span> : <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">System.out.println(result);<span class="comment">//及格</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-5-运算优先级"><a href="#4-5-运算优先级" class="headerlink" title="4.5 运算优先级"></a>4.5 运算优先级</h3><ul>
<li><p>在表达式中,哪个运算符先执行后执行是要看优先级的,例如“*、 1”的优先级高于”+、-”。</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>()</td>
</tr>
<tr>
<td>2</td>
<td>! 、- 、++ 、 –</td>
</tr>
<tr>
<td>3</td>
<td>*、/、%</td>
</tr>
<tr>
<td>4</td>
<td>+、-</td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td>
</tr>
<tr>
<td>6</td>
<td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td>
</tr>
<tr>
<td>7</td>
<td>==、！=</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
</tr>
<tr>
<td>13</td>
<td>？：</td>
</tr>
<tr>
<td>14</td>
<td>=、+=、-=、*=、/=、%=、&amp;=</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h1><ul>
<li>流程控制语句<ul>
<li>顺序结构：程序默认流程</li>
<li>分支结构：if、switch</li>
<li>循环结构：for、while、do…while</li>
</ul>
</li>
</ul>
<h2 id="1-分支结构"><a href="#1-分支结构" class="headerlink" title="1 分支结构"></a>1 分支结构</h2><h3 id="1-1-if分支"><a href="#1-1-if分支" class="headerlink" title="1.1 if分支"></a>1.1 if分支</h3><ul>
<li><p>根据判定的结果决定执行某个分支的代码</p>
</li>
<li><p>if分支的作用</p>
</li>
<li><p>if分支有三种格式</p>
<ul>
<li>````java<br>格式1：<br>if(条件表达式){<pre><code>语句体;
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + ```java</span><br><span class="line">    格式2:</span><br><span class="line">    if(条件表达式)&#123;</span><br><span class="line">        语句体；</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        语句2;</span><br><span class="line">    &#125;</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">  + ```java</span><br><span class="line">    格式3:</span><br><span class="line">    if(条件表达式)&#123;</span><br><span class="line">        语句体1;</span><br><span class="line">    &#125;else if(条件表达式2)&#123;</span><br><span class="line">        语句体2;</span><br><span class="line">    &#125;else if(条件表达式3)&#123;</span><br><span class="line">        语句体3;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    else&#123;</span><br><span class="line">        语句体n+1;</span><br><span class="line">    &#125;</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">### 1.2 switch分支</span><br><span class="line"></span><br><span class="line">**也是匹配条件去执行分支，适合做值匹配的分支选择,结构清晰,格式良好。**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">switch(表达式)&#123;</span><br><span class="line">    case 值1:</span><br><span class="line">        执行代码...;</span><br><span class="line">        break;</span><br><span class="line">    case 值2:</span><br><span class="line">        执行代码...;</span><br><span class="line">        break;</span><br><span class="line">    ...</span><br><span class="line">        case 值n-1:</span><br><span class="line">        执行代码...;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        执行代码n;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">执行流程:</span><br><span class="line"></span><br><span class="line">1. 先执行表达式的值，拿着这个值去与case后的值进行匹配。</span><br><span class="line">2. 匹配哪个case的值 为true就执行哪个case，遇到break就跳出switch分 支。</span><br><span class="line">3. 如果case后的值都不匹配则执行default代码。</span><br><span class="line"></span><br><span class="line">switch分支注意事项:</span><br><span class="line"></span><br><span class="line">1. 表达式类型只能是byte、short. int、 char, JDK5开始支持枚举，JDK7开始支持String、</span><br><span class="line">   不支持double、float、 long。</span><br><span class="line">2. case给出的值不允许重复，且只能是字面量，不能是变量。</span><br><span class="line">3. 不要忘记写break,否则会出现穿透现象。</span><br><span class="line"></span><br><span class="line">## 2 循环结构</span><br><span class="line"></span><br><span class="line">### 2.1 for循环</span><br><span class="line"></span><br><span class="line">+ 控制一段代码反复执行很多次</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  格式:</span><br><span class="line">  for(初始化语句;循环条件;迭代语句)&#123;</span><br><span class="line">      循环体语句(重复执行的代码);</span><br><span class="line">  &#125;</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">### 2.2 while循环</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">初始化语句;</span><br><span class="line">while(循环条件)&#123;</span><br><span class="line">    循环体语句(被重复执行的代码);</span><br><span class="line">    迭代语句;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 2.3 do…while循环</span><br><span class="line"></span><br><span class="line">+ 先执行，在判断循环条件</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  初始化语句:</span><br><span class="line">  de&#123;</span><br><span class="line">      循环体语句;</span><br><span class="line">      迭代语句;</span><br><span class="line">  &#125;while(循环条件);</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">### 2.4 三中循环的区别</span><br><span class="line"></span><br><span class="line">+ for循环和while循环(先判断后执行)</span><br><span class="line">+ do…while(第一次先执行后判断)</span><br><span class="line">+ for和while的区别</span><br><span class="line">  + for循环和while循环的执行流程是一模-样的。</span><br><span class="line">  + 如果已知循环次数建议使用for循环，如果不清楚要循环多少次建议使用while循环。</span><br><span class="line">  + for循环中，控制循环的变量只在循环中可以使用。While循环中，控制循环的变量在循环后还可以继续使用。</span><br><span class="line"></span><br><span class="line">### 2.5 死循环</span><br><span class="line"></span><br><span class="line">+ 一直循环的执行下去，如果没有干预不会停止下来。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  while(true)&#123;</span><br><span class="line">      System.out.plintln(&quot;-----------&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">### 2.6 嵌套循环</span><br><span class="line"></span><br><span class="line">+ 循环中又包含循环</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  for(int i = 0;i &lt; 3;i++)&#123;</span><br><span class="line">      for(int j = 0;j &lt; 5;j++)&#123;</span><br><span class="line">          System.out.plintln(&quot;我爱你&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">+ 嵌套循环的特点</span><br><span class="line"></span><br><span class="line">  + 外部循环每循环一次，内部循环全部执行完一次</span><br><span class="line"></span><br><span class="line">## 3跳转关键字</span><br><span class="line"></span><br><span class="line">+ break:用于跳出并结束当前所在的循环执行</span><br><span class="line">+ countine :用于跳出当前循环的再次执行，进入下一循环</span><br><span class="line">+ break只能结束所在的循环，或者结束所在switch分支的执行</span><br><span class="line">+ countine:只能在循环中使用</span><br><span class="line"></span><br><span class="line"># 数组</span><br><span class="line"></span><br><span class="line">+ 数组就是用来存储一-批同种类型数据的内存区域( 可以理解成容器)</span><br><span class="line"></span><br><span class="line">+ 例子</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  20,10,80,60,90</span><br><span class="line">  int[] arr = &#123;20,10,80,60,90&#125;</span><br><span class="line">  &quot;牛二&quot;,&quot;西门&quot;,&quot;全蛋&quot;</span><br><span class="line">  String[] arr = &#123;&quot;牛二&quot;,&quot;西门&quot;,&quot;全蛋&quot;&#125;</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">## 1.数组的定义</span><br><span class="line"></span><br><span class="line">### 1.1 静态初始化数组</span><br><span class="line"></span><br><span class="line">+ 定义数组的时候直接给数组赋值。</span><br><span class="line"></span><br><span class="line">+ 静态初始化数组的格式:</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  //完整格式</span><br><span class="line">  数据类型[]数组名 = new 数据类型[]&#123;元素1,元素2，元素3... &#125;;</span><br><span class="line">  double[] scores = new double[]&#123;89.9, 99.5, 59.5, 88.0&#125;;</span><br><span class="line">  int[] ages = new int[]&#123;1Z， 24, 36&#125;</span><br><span class="line">  //简化格式</span><br><span class="line">  数据类型[]数组名= &#123;元素1,元素2，元素3, ... &#125;;</span><br><span class="line">  int[] ages = &#123;12，24， 36&#125;;</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">+ 数组属于引用数据类型，数组变量名中存储的数组在内存中的地址信息。</span><br><span class="line"></span><br><span class="line">#### 1.1.1 数组的访问</span><br><span class="line"></span><br><span class="line">+ 数组名称[索引]</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  int[] arr = &#123;12,24,36&#125;;</span><br><span class="line">  //取值</span><br><span class="line">  System . out . println(arr[0]); // 12</span><br><span class="line">  //赋值</span><br><span class="line">  arr[2] = 100;</span><br><span class="line">  System. out。println(arr[2]); // 100</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">+ 数组的长度属性：length</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  //获取数组的长度(就是数组元素的个数)</span><br><span class="line">  System. out. println(arr. length); // 3</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">+ 数组的最大索引为</span><br><span class="line"></span><br><span class="line">  `数组名.length-1//前提：元素个数大于0`</span><br><span class="line"></span><br><span class="line">#### 1.1.2数组的注意事项</span><br><span class="line"></span><br><span class="line">+ `&#x27;数据类型[]数组名&quot;也可以写成&quot;数据类型数组名[]”`</span><br><span class="line">+ 什么类型的数组存放什么类型的数据，否则报错。</span><br><span class="line">+ 数组- -旦定义出来，程序执行的过程中，长度、类型就固定了。</span><br><span class="line"></span><br><span class="line">### 1.2动态初始化数组</span><br><span class="line"></span><br><span class="line">+ 定义数组的时候只确定元素的类型和数组的长度，之后再存入具体数据。</span><br><span class="line"></span><br><span class="line">+ 数组的动态初始化格式:</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  数据类型[] 数组名= new 数据类型[长度];</span><br><span class="line">  int[ ] arr = new int[3];</span><br><span class="line">  //后赋值</span><br><span class="line">  arr[0] = 10;</span><br><span class="line">  System. out. println(arr[0]); // 10</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 1.2.1动态初始化数组的元素默认值</span><br><span class="line"></span><br><span class="line">+ 元素默认值规则</span><br><span class="line"></span><br><span class="line">  + 基本类型</span><br><span class="line"></span><br><span class="line">    | 数据类型                     | 默认值 |</span><br><span class="line">    | ---------------------------- | ------ |</span><br><span class="line">    | byte  short  int  char  long | 0      |</span><br><span class="line">    | float  double                | 0.0    |</span><br><span class="line">    | boolean                      | false  |</span><br><span class="line"></span><br><span class="line">  + 引用类型</span><br><span class="line"></span><br><span class="line">    | 数据类型               | 默认值 |</span><br><span class="line">    | ---------------------- | ------ |</span><br><span class="line">    | 类、接口、数组、String | null   |</span><br><span class="line"></span><br><span class="line">+ 两种初始化的的使用场景总结、注意事项说明:</span><br><span class="line"></span><br><span class="line">  + 动态初始化:只指定数组长度，后期赋值,适合开始知道数据的数量，但是不确定具体元素值的业务场景。</span><br><span class="line">  + 静态初始化:开始就存入元素值，适合一开始就能确定元素值的业务场景。</span><br><span class="line">  + 两种格式的写法是独立的严，不可以混用。</span><br><span class="line"></span><br><span class="line">## 2.数组的遍历</span><br><span class="line"></span><br><span class="line">数组遍历介绍</span><br><span class="line"></span><br><span class="line">+ 遍历:就是一个一个数据的访问。</span><br><span class="line"></span><br><span class="line">+ 为什么要遍历?搜索、数据统计等等都需要用到遍历。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  int[] ages = &#123;20， 30，40，50&#125;;</span><br><span class="line">  for (int i = 0; i &lt; ages.length; i++) &#123;</span><br><span class="line">  System.out.println(ages[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  //第二种</span><br><span class="line">  for(int i:ages)&#123;</span><br><span class="line">      System.out.println(i)</span><br><span class="line">  &#125;</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line"># 方法</span><br><span class="line"></span><br><span class="line">+ 方法是- -种语法结构，它可以把一段代码封装成一个功能，以方便重复调用。</span><br><span class="line">+ 使用方法的好处是?</span><br><span class="line">  + 提高了代码的复用性。</span><br><span class="line">  + 让程序的逻辑更清晰。</span><br><span class="line"></span><br><span class="line">## 1方法的定义</span><br><span class="line"></span><br><span class="line">方法定义的完整格式</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">修饰符返回值类型方法名(形参列表)&#123;</span><br><span class="line">	方法体代码(需要执行的功能代码)</span><br><span class="line">	return返回值;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">## 2方法的调用</span><br><span class="line"></span><br><span class="line">+ 方法必须调用才可以跑起来，调用格式:`方法名(...);`</span><br><span class="line"></span><br><span class="line">+ 注意事项</span><br><span class="line">  + 如果方法不需要返回结果，返回值类型必须申明成void ( 无返回值) ,此时方法内部不可以使用return返回数据。</span><br><span class="line">  + 方法如果没有参数,或者返回值类型申明为void可以称为无参数、无返回值的方法,依次类推。</span><br><span class="line"></span><br><span class="line">## 3.方法的内存原理</span><br><span class="line"></span><br><span class="line">***方法的调用流程-内存图解***</span><br><span class="line"></span><br><span class="line">+ 方法没有被调用的时候，在方法区中的字节码文件中存放</span><br><span class="line">+ 方法被调用的时候，需要进入到栈内存中运行</span><br><span class="line"></span><br><span class="line">## 4.方法的参数传递机制</span><br><span class="line"></span><br><span class="line">### 4.1 基本类型的参数传递</span><br><span class="line"></span><br><span class="line">+ ***Java的参数传递机制:值传递***</span><br><span class="line">  + 在传输实参给方法的形参的时候，并不是俊输实</span><br><span class="line">    参变量本身，而是传输实参变量中存储的值，这</span><br><span class="line">    就是值传递。</span><br><span class="line">+ 注意:</span><br><span class="line">  + 实参:如在方法内部定义的变量。</span><br><span class="line">  + 形参:如在定义方法时， &quot;()&quot;中所声明的参数。</span><br><span class="line"></span><br><span class="line">### 4.2 引用类型的参数传递</span><br><span class="line"></span><br><span class="line">+ 引用类型的参数传输存储的地址值。</span><br><span class="line">  + 方法内部访问到改地址，形参修改，实参对应的改地址也会修改，所以实参也会修改</span><br><span class="line"></span><br><span class="line">## 5.方法重载</span><br><span class="line"></span><br><span class="line">+ 形式</span><br><span class="line">  + 同一个类中，出现多个方法名称相同,但是形参列表是不同的，那么这些方法就是重载方法。</span><br><span class="line">+ 识别技巧</span><br><span class="line">  + 只要是同一个类中，方法名称相同、形参列表不同，那么他们就是重载的方法，其他都不管!(如:修饰符，返回值类型都无所谓)</span><br><span class="line">  + 形参列表不同指的是:形参的个数、类型、顺序不同，不关心形参的名称。</span><br><span class="line"></span><br><span class="line">## 5.return关键字单独使用</span><br><span class="line"></span><br><span class="line">+ return;---&gt;可以立即跳出并结束当前方法的执行; return关键 字单独使用可以放在任何方法中。</span><br><span class="line"></span><br><span class="line"># 面向对象</span><br><span class="line"></span><br><span class="line">## 1.设计对象并使用</span><br><span class="line"></span><br><span class="line">### 1.1 设计类</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class 类名&#123;</span><br><span class="line">    1成员变量;</span><br><span class="line">    2成员方法;</span><br><span class="line">    3构造器;</span><br><span class="line">    4代码块;</span><br><span class="line">    5内部类;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 1.2得到类的对象</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">类名对象名= new类名();</span><br><span class="line">Car C = new Car();</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 1.3使用对象</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">访问属性:对象名.成员变量</span><br><span class="line">访问行为:对象名.方 法名(...)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">## 2.定义类的注意事项</span><br><span class="line"></span><br><span class="line">类名首字母建议大写，且有意义，满足“驼峰模式”。</span><br><span class="line">- 一个Java文件中可以定义多个class类,但只能一一个类是public修饰, 而且public修饰的类名必须成为代码文件名。</span><br><span class="line">- 实际开发中建议还是-一个文件定义-个class类。</span><br><span class="line">- 成员变量的完整定义格式是:修饰符数据类型变量名称=初始化值; 一般无需指定初始化值,存在默认值。</span><br><span class="line"></span><br><span class="line">## 3.对象在内存中的运行机制</span><br><span class="line"></span><br><span class="line">### 3.1 多个对象的内存图</span><br><span class="line"></span><br><span class="line">+ 对象放在堆内存中</span><br><span class="line">+ 类 C = new 类 </span><br><span class="line">  + C变量名指的是对象在堆内存中的地址</span><br><span class="line">+ 成员变量的数据放在对象中，存放于堆内存中</span><br><span class="line"></span><br><span class="line">### 3.2 两个变量指向同一个对象内存图</span><br><span class="line"></span><br><span class="line">垃圾回收</span><br><span class="line"></span><br><span class="line">+ 注意:当堆内存中的对象,没有被任何变量引用(指向)时，就会被判定为内存中的“垃圾”。</span><br><span class="line">+ Java存在自动垃圾回收器，会定期进行清理。</span><br><span class="line"></span><br><span class="line">## 4.构造器</span><br><span class="line"></span><br><span class="line">+ 构造器的作用</span><br><span class="line"></span><br><span class="line">  + 定义在类中的，可以用于初始化- -个类的对象，并返回对象的地址。</span><br><span class="line"></span><br><span class="line">+ 调用构造器</span><br><span class="line"></span><br><span class="line">  + `类变量名称= new构造器;`</span><br><span class="line"></span><br><span class="line">+ 构造器的格式</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  修饰符类名(形参列表)&#123;</span><br><span class="line">  	...</span><br><span class="line">  &#125;</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">+ 构造器的分类和作用</span><br><span class="line"></span><br><span class="line">  + 无参数构造器( 默认存在的) :初始化对象时，成员变量的数据均采用默认值。</span><br><span class="line">  + 有参数构造器:在初始化对象的时候，同时可以接收参数为对象进行赋值。</span><br><span class="line"></span><br><span class="line">## 5.this关键字</span><br><span class="line"></span><br><span class="line">+ 可以出现在构造器方法中</span><br><span class="line"></span><br><span class="line">+ 代表当前对象的地址</span><br><span class="line"></span><br><span class="line">+ 可以用于指定访问当前对象的成员变量、成员方法。</span><br><span class="line"></span><br><span class="line">+ this出现在有参数构造器中的用法</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public class Car &#123;</span><br><span class="line">  	string name;</span><br><span class="line">  	double price;</span><br><span class="line">  	public Car(string namde, double price)&#123;</span><br><span class="line">  	name = name ;</span><br><span class="line">  	price = price;</span><br><span class="line">  &#125;</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">## 6.封装</span><br><span class="line"></span><br><span class="line">### 6.1封装思想概述</span><br><span class="line"></span><br><span class="line">+ 面向对象三大特征：继承、封装、多态</span><br><span class="line">+ 封装：告诉我们，如何正确设计对象的属性和方法</span><br><span class="line">+ 封装的原则:对象代表什么，就得封装对应的数据，并提供数据对应的行为。</span><br><span class="line"></span><br><span class="line">### 6.2如何更好的封装</span><br><span class="line"></span><br><span class="line">+ 一般建议对成员变量使用private(私有、隐藏)关键字修饰进( private修饰的成员只能在当前类中访问)。</span><br><span class="line">+ 为每个成员变量提供配套public修饰的的getter. setter方法暴露其取值和赋值。</span><br><span class="line"></span><br><span class="line">## 7.标准JavaBean</span><br><span class="line"></span><br><span class="line">+ 也可以称为实体类，其对象可以用于在程序中封装数据。</span><br><span class="line">+ 标准JavaBean须满足如下书写要求:</span><br><span class="line">  + 成员变量使用private修饰。</span><br><span class="line">  + 提供成员变量对应的setXxx() / getXxx()方法。</span><br><span class="line">  + 必须提供一个无参构造器;有参数构造器是可写可不写的。</span><br><span class="line"></span><br><span class="line">## 8.成员变量、局部变量的区别</span><br><span class="line"></span><br><span class="line">| 区别         | 成员变量                                   | 局部变量                                   |</span><br><span class="line">| ------------ | ------------------------------------------ | ------------------------------------------ |</span><br><span class="line">| 类中位置不同 | 类中，方法外                               | 常用于方法中                               |</span><br><span class="line">| 初始化值不同 | 有默认值，无需初始化                       | 没有默认值，使用前需要赋值                 |</span><br><span class="line">| 内存位置不同 | 堆内存                                     | 栈内存                                     |</span><br><span class="line">| 生命周期不同 | 随着对象的创建而存在，随着对象的消失而消失 | 随着方法的调用而调用，随着方法的小时而消失 |</span><br><span class="line">| 作用域       |                                            | 在归属的大括号中                           |</span><br><span class="line"></span><br><span class="line">## 9.static</span><br><span class="line"></span><br><span class="line">### 9.1概述</span><br><span class="line"></span><br><span class="line">+ tatic是静态的意思， 可以修饰成员变量和成员方法。</span><br><span class="line"></span><br><span class="line">+ tatic修饰成员变量表示该成员变量只在内存中只存储一份,可以被共享访问、修改。</span><br><span class="line"></span><br><span class="line">+ 静态成员变量(有static修饰， 属于类，内存中加载一 次) :常表示如在线人数信息、等需要被共享的信息，可以被共享访问。</span><br><span class="line"></span><br><span class="line">  + ````java</span><br><span class="line">    类名.静态成员变量。(推荐)</span><br><span class="line">    对象.静态成员变量。(不推荐)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>实例成员变量(无static修饰, 存在于每个对象中) :常表示姓名name、年龄age、等属于每个对象的信息。</p>
</li>
</ul>
<h3 id="9-2-static修饰成员变量内存机制"><a href="#9-2-static修饰成员变量内存机制" class="headerlink" title="9.2 static修饰成员变量内存机制"></a>9.2 static修饰成员变量内存机制</h3><p>staic修饰成员变量一个类中只有一个，所有对象共享</p>
<h3 id="9-3-static修饰成员方法"><a href="#9-3-static修饰成员方法" class="headerlink" title="9.3 static修饰成员方法"></a>9.3 static修饰成员方法</h3><p>成员方法的分类</p>
<ul>
<li>静态成员方法(有static修饰， 归属于类) ,建议用类名访问，也可以用对象访问。</li>
<li>实例成员方法(无static修饰， 归属于对象)，只能用对象触发访问。</li>
<li>使用场景<ul>
<li>表示对象自己的行为的，且方法中需要访问实例成员的，则该方法必须申明成实例方法。</li>
<li>如果该方法是以执行一个共用功能为目的，则可以申明成静态方法。</li>
</ul>
</li>
</ul>
<h3 id="9-4-static访问注意事项"><a href="#9-4-static访问注意事项" class="headerlink" title="9.4 static访问注意事项:"></a>9.4 static访问注意事项:</h3><ul>
<li>静态方法只能访问静态的成员，不可以直接访问实例成员。<br>上</li>
<li>实例方法可以访问静态的成员，也可以访问实例成员。</li>
<li>静态方法中是不可以出现this关键字的。</li>
</ul>
<h3 id="9-5工具类"><a href="#9-5工具类" class="headerlink" title="9.5工具类"></a>9.5工具类</h3><ul>
<li>类中都是一些静态方法， 每个方法都是以完成一个共用的功能为目的，这个类用来给系统开发人员共同使用的。</li>
</ul>
<p>案例：在企业的管理系统中，通常需要在一一个 系统的很多业务处使用验证码进行防刷新等安全控制。</p>
<ul>
<li>问题:<ul>
<li>同一个功能多处开发，会出现代码重复度过高。</li>
</ul>
</li>
<li>使用工具类的好处<ul>
<li>一是调用方便，二是提高了代码复用(一次编写，处处可用)</li>
</ul>
</li>
<li>为什么工具类中的方法不用实例方法做?<ul>
<li>实例方法需要创建对象调用。</li>
<li>此时用对象只是为了调用方法，这样只会浪费内存。</li>
</ul>
</li>
<li>工具类定义时的其他要求:<ul>
<li>由于工具里面都是静态方法，直接用类名即可访问，因此，工具类无需创建对象，建议将工具类的构造器进行私有。</li>
</ul>
</li>
</ul>
<h3 id="9-6-代码块"><a href="#9-6-代码块" class="headerlink" title="9.6 代码块"></a>9.6 代码块</h3><ul>
<li><p>代码块概述</p>
<ul>
<li>代码块是类的5大成分之一(成员变量、构造器,方法，代码块，内部类) ,定义在类中方法外。</li>
<li>在Java类下,使用{}括起来的代码被称为代码块。<br>代码块分为</li>
</ul>
</li>
<li><p>静态代码块:</p>
<ul>
<li>格式: static{}<br>特点:需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次</li>
<li>使用场景: 在类加载的时候做- -些静 态数据初始化的操作,以便后续使用。</li>
</ul>
</li>
<li><p>构造代码块(了解，见的少) :</p>
<ul>
<li>格式: {}</li>
<li>特点:每次创建对象，调用构造器执行时，都会执行该代码块中的代码,并且在构造器执行前执行</li>
<li>使用场景:初始化实例资源。</li>
</ul>
</li>
</ul>
<h3 id="9-7单例设计模式"><a href="#9-7单例设计模式" class="headerlink" title="9.7单例设计模式"></a>9.7单例设计模式</h3><p>什么是设计模式(Design pattern)</p>
<ul>
<li>开发中经常遇到- -些问题，- -个问题通常有n种解法的，但其中肯定有-种解法是最优的，这个最优的解法被人总结出<br>来了，称之为设计模式。</li>
<li>设计模式有20多种，对应20多种软件开发中会遇到的问题。</li>
<li>学设计模式主要是学2点:<ol>
<li>这种模式用来解决什么问题。</li>
<li>遇到这种问题了，该模式是怎么写的，他是如何解决这个问题的。</li>
</ol>
</li>
</ul>
<p>单例模式</p>
<ul>
<li>可以保证系统中，应用该模式的这个类永远只有一个实例，即- -个类永远只能创建一个对象。</li>
<li>例如任务管理器对象我们只需要一个就可以解决问题了,这样可以节省内存空间。</li>
</ul>
<p>单例的实现方式很多</p>
<ul>
<li><p>饿汉单例模式。</p>
<ul>
<li><p>在用类获取对象的时候，对象已经提前为你创建好了。</p>
</li>
<li><p>设计模式</p>
<ol>
<li>定义一个类，把构造器私有。</li>
<li>定义一个静态变量存储一一个对象。</li>
</ol>
</li>
<li><p>```java<br>private Test2(){</p>
<pre><code>&#125;
</code></pre>
<p>public static Test2 test = new Test2();</p>
<p>public static void main(String[] args) {</p>
<pre><code>Test2 t = Test2.test;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 懒汉单例模式。</span><br><span class="line"></span><br><span class="line">  + 在真正需要该对象的时候，才去创建一 个对象(延迟加载对象)。</span><br><span class="line"></span><br><span class="line">  + 设计步骤</span><br><span class="line"></span><br><span class="line">    1. 定义一个类,把构造器私有。</span><br><span class="line">    2. 定义一个静态变量存储一个对象。</span><br><span class="line">    3. 提供一个返回单例对象的方法</span><br><span class="line"></span><br><span class="line">  + ```java</span><br><span class="line">    private Test2()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    private static Test2 instance ;</span><br><span class="line">    public static Test2 getInstance()&#123;</span><br><span class="line">        if (instance == null)&#123;</span><br><span class="line">            instance = new Test2();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test2 t = Test2.getInstance();</span><br><span class="line">    &#125;#</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="10-继承"><a href="#10-继承" class="headerlink" title="10.继承"></a>10.继承</h2><h3 id="10-1概述"><a href="#10-1概述" class="headerlink" title="10.1概述"></a>10.1概述</h3><ul>
<li>Java中提供一个关键字extends, 用这个关键字，我们可以让-个类和另-个类建立起父子关系。</li>
<li><code>public class Student extends People &#123; &#125;</code></li>
<li>Student称为子类( 派生类)，People称为父类(基类 或超类)。</li>
<li>作用:当子类继承父类后，就可以直接使用父类公共的属性和方法了</li>
</ul>
<p>使用继承的好处</p>
<ol>
<li>可以提高代码的复用性</li>
<li>减少代码冗余</li>
<li>增强类的扩展性</li>
</ol>
<p>继承的格式<code>子类 extend 父类</code></p>
<p>继承后子类的特点</p>
<ol>
<li>子类继承父类,子类可以得到父类的属性和行为，子类可以使用。</li>
<li>java中子类更强大</li>
</ol>
<h3 id="10-2继承的设计规范"><a href="#10-2继承的设计规范" class="headerlink" title="10.2继承的设计规范"></a>10.2继承的设计规范</h3><p>继承的设计规范</p>
<ul>
<li>子类们相同特征(共性属性,共性方法)放在父类中定义，子类独有的的属性和行为应该定义在子类自己里面。</li>
<li>如果子类的独有属性、行为定义在父类中,会导致其它子类也会得到这些属性和行为，这不符合面向对象逻辑。</li>
</ul>
<h3 id="10-3-继承的特点"><a href="#10-3-继承的特点" class="headerlink" title="10.3 继承的特点"></a>10.3 继承的特点</h3><ol>
<li>子类可以继承父类的属性和行为,但是子类不能继承父类的构造器。<ol>
<li> 子类有自己的构造器，父类构造器用于初始化父类对象。</li>
<li>子类可以继承父类私有成员，但是不能直接访问。</li>
<li>子类可以直接使用父类静态成员，<u>但不算继承（共享非继承）</u></li>
</ol>
</li>
<li>Java是单继承模式:一个类只能继承一个直接父类。</li>
<li>Java不支持多继承、但是支持多层继承。<ul>
<li>子类A继承父类B，父类B可以继承父类C</li>
</ul>
</li>
<li>Java中 所有的类都是0bject类的子类。<ul>
<li>Java中所有类，要么直接继承了Object,要么默认继承&lt;了Object ,要么间接继承了Object, Object是祖宗类。</li>
</ul>
</li>
</ol>
<h3 id="10-4-继承后，成员变量和成员方法的访问特点"><a href="#10-4-继承后，成员变量和成员方法的访问特点" class="headerlink" title="10.4 继承后，成员变量和成员方法的访问特点"></a>10.4 继承后，成员变量和成员方法的访问特点</h3><p>在子类方法中访问成员(成员变量、成员方法)满足:就近原则</p>
<ul>
<li>先子类局部范围找</li>
<li>然后子类成员范围找</li>
<li>然后父类成员范围找，如果父类范围还没有找到则报错。</li>
</ul>
<p>如果子父类中，出现了重名的成员，会优先使用子类的，此时如果-定要在 子类中使用父类的怎么办?</p>
<ul>
<li>可以通过super关键字，指定访问父类的成员。</li>
</ul>
<h3 id="10-5-继承后，方法重写"><a href="#10-5-继承后，方法重写" class="headerlink" title="10.5 继承后，方法重写"></a>10.5 继承后，方法重写</h3><p>概念</p>
<ul>
<li>在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。</li>
</ul>
<p>应用场景</p>
<ul>
<li>当子类需要父类功能，但父类功能不能完全满足自己需求是时</li>
<li>子类可以重写父类中的方法</li>
</ul>
<p>@Override重写注解</p>
<ul>
<li>@Override是放在重写后的方法上，作为重写是否正确的校验注解。</li>
<li>加上该注解后如果重写错误，编译阶段会出现错误提示。</li>
<li>建议重写方法都加@Override注解，代码安全，优雅!</li>
</ul>
<p>方法重写注意事项和要求</p>
<ul>
<li>重写方法的名称、 形参列表必须与被重写方法的名称和参数列表一致。</li>
<li>私有方法不能被重写。</li>
<li>子类重写父类方法时，访问权限必须大于或者等于父类(暂时 了解:缺省&lt; protected &lt; public)</li>
</ul>
<h3 id="10-6-继承后子类构造器的特点"><a href="#10-6-继承后子类构造器的特点" class="headerlink" title="10.6 继承后子类构造器的特点"></a>10.6 继承后子类构造器的特点</h3><p>子类继承父类后构造器的特点:</p>
<ul>
<li>子类中所有 的构造器默认都会先访问父类中无参的构造器，再执行自己。</li>
<li>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化,子类将无法使用父类的数据。</li>
<li>子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化。</li>
<li>子类构造器的第一行语句默认都是: super(), 不写也存在。</li>
</ul>
<h3 id="10-7-继承后子类构造器访问父类无参构造器"><a href="#10-7-继承后子类构造器访问父类无参构造器" class="headerlink" title="10.7 继承后子类构造器访问父类无参构造器"></a>10.7 继承后子类构造器访问父类无参构造器</h3><p>作用</p>
<ul>
<li>初始化继承自父类的数据。</li>
<li>如果父类中没有无参数构造器，只有有参构造器，会报错。因为子类默认是调用父类无参构造器的。</li>
<li>子类构造器中可以通过书写super(..), 手动调用父类的有参数构造器</li>
</ul>
<h3 id="10-8-this和supper"><a href="#10-8-this和supper" class="headerlink" title="10.8 this和supper"></a>10.8 this和supper</h3><table>
<thead>
<tr>
<th>关键字</th>
<th>访问成员变量</th>
<th>访问成员方法</th>
<th>访问构造方法</th>
</tr>
</thead>
<tbody><tr>
<td>this</td>
<td>this.成员变量<br>访问本类成员变量</td>
<td>this.成员方法<br>访问本类成员方法</td>
<td>this(…)<br>访问本类构造器</td>
</tr>
<tr>
<td>super</td>
<td>super.成员变量<br>访问父类成员变量</td>
<td>super.成员方法<br/>访问父类成员方法</td>
<td>super(…)<br/>访问父类构造器</td>
</tr>
</tbody></table>
<p>this(..)和super(..)使用注意点:</p>
<ul>
<li>子类通过 this ..去调用本类的其他构造器，本类其他构造器会通过super去手动调用父类的构造器，最终还是会调用父类构造器的。</li>
<li>注意: thi(.. )super(..)都只能放在构造器的第一行,所以二者不能共存在同一-个构造器中。</li>
</ul>
<h2 id="11-抽象类"><a href="#11-抽象类" class="headerlink" title="11.抽象类"></a>11.抽象类</h2><p>概述</p>
<ul>
<li>某个父类知道其所有子类要完成某功能，但是每个子类完成情况都不一样,父类就只定义该功能的基本要求,具体实现由子类完成，这个类就可以是一 个抽象类,抽象类其实就是一 种不完全的设计图。</li>
<li>抽象类必须使用abstract修饰:<ul>
<li><code>修饰符abstract class类名&#123;&#125;</code></li>
</ul>
</li>
</ul>
<p>抽象方法</p>
<ul>
<li>就是抽象类中定义的子类必须完成的功能的基本要求。<ul>
<li><code>修 饰符abstract返回值类型方法名称(形参列表); </code></li>
</ul>
</li>
<li>没有方法体，只有方法签名,必须abstract修饰。</li>
</ul>
<p>抽象的使用总结与注意事项</p>
<ul>
<li>抽象类用来被继承的，抽象方法是交给子类重写实现的。</li>
<li>一个类如果继承了抽象类,那么这个类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。</li>
</ul>
<p>特征</p>
<ul>
<li>有得有失:得到了抽象方法,失去了创建对象的能力。</li>
<li>抽象类不能创建对象。</li>
<li>类有的成员(成员变量、方法、构造器)抽象类都具备</li>
<li>抽象类中不一定有 抽象方法,有抽象方法的类一定是抽象类</li>
<li>一个类继承了抽象类必须重写完抽象类的全部抽象方法,否则这个类也必须定义成抽象类。</li>
<li>不能用abstract修饰变量、代码块、构造器。</li>
<li>final和abstract是什么关系?<ul>
<li>互斥关系</li>
<li>abstract定 义的抽象类作为模板让子类继承, final定义的类不能被继承。</li>
<li>抽象方法定义通用功能让子类重写，final定义的方法子类不能重写。</li>
</ul>
</li>
</ul>
<p>使用场景</p>
<ul>
<li>当系统中出现同一个功能多处在开发，而该功能中大部分代码是一样的，只有其中部分可能不同的时候。</li>
</ul>
<p>使用步骤</p>
<ul>
<li>把功能定义成一个所谓的模板方法,放在抽象类中，模板方法中只定义通用且能确定的代码。</li>
<li>模板方法中不能决定的功能定义成抽象方法让具体子类去实现。</li>
</ul>
<h2 id="12-接口"><a href="#12-接口" class="headerlink" title="12.接口"></a>12.接口</h2><h3 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h3><ul>
<li><p>接口就是体现规范的，其中用抽象方法定义的一-组行为规范，接口是更加彻底的抽象。</p>
</li>
<li><p>体现了现实世界中“如果你是这类事物..则必须完成某些行为”的思想。</p>
</li>
<li><p>接口的格式如下:</p>
<ul>
<li>```java<br>接口用关键字interface来定义<br>public interface接口名{<pre><code>//常量
//抽象方法
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + JDK8之前接口中只能是抽象方法和常量，没有其他成分了。</span><br><span class="line"></span><br><span class="line">  + 接口不能实例化</span><br><span class="line"></span><br><span class="line">  + 接口中的成员都是public修饰的,写不写都是,因为规范的目的是为了公开化。</span><br><span class="line"></span><br><span class="line">用法:</span><br><span class="line"></span><br><span class="line">+ 接口是用来被类实现(implements) 的，实现接口的类称为实现类。实现类可以理解成所谓的子类。</span><br><span class="line"></span><br><span class="line">  + ```java</span><br><span class="line">    修饰符class实现类implements接口1,接口2,接口....&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    实现的关键字: implements</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>接口可以被类单实现，也可以被类多实现。</p>
</li>
</ul>
<p>JDK8版本开始后，Java只对接口的成员方法进行了新增</p>
<ul>
<li>项目Version2.0需要对Inter接口丰富，加入10个新的抽象方法，此时改了接口就要所有实现类实现这些方法。</li>
<li>允许接口中直接定义带有方法体的方法<ol>
<li>默认方法<ul>
<li>类似之前写的普通实例方法:必须用default修饰</li>
<li>默认会public修饰。 需要用接口的实现类的对象来调用</li>
</ul>
</li>
<li>静态方法<ul>
<li>默认会public修饰， 必须static修饰。</li>
<li>注意:接口的静态方法必须用本身的接口名来调用。</li>
</ul>
</li>
<li>私有方法<ul>
<li>就是私有的实例方法:，必须使用private修饰， 从JDK 1.9才开始有的。</li>
<li>只能在本类中被其他的默认方法或者私有方法访问。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="13-多态"><a href="#13-多态" class="headerlink" title="13.多态"></a>13.多态</h2><h3 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h3><ul>
<li>同类型的对象，执行同一个行为，会表现出不同的行为特征。</li>
</ul>
<p>常见形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型对象名称= <span class="keyword">new</span>子类构造器;</span><br><span class="line">接口 对象名称= <span class="keyword">new</span>实现类构造器; </span><br></pre></td></tr></table></figure>

<p>多态中成员访问特点</p>
<ul>
<li>方法调用:编译看左边，运行看右边。</li>
<li>变量调用:编译看左边，运行也看左边。 (多态侧重行为多态)</li>
</ul>
<p>多态的前提</p>
<ul>
<li>有继承/实现关系;有父类引用指向子类对象;有方法重写。</li>
</ul>
<h3 id="13-2-优势"><a href="#13-2-优势" class="headerlink" title="13.2 优势"></a>13.2 优势</h3><ul>
<li><p>王多态形式下，右边对象可以实现解耦合,便于扩展和维护。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animala = <span class="keyword">new</span> <span class="title class_">Dog</span>(;</span><br><span class="line">a.run(); <span class="comment">//后续业务行为随对象而变，后续代码无需修改</span></span><br></pre></td></tr></table></figure></li>
<li><p>定义方法的时候，使用父类型作为参数,该方法就可以接收这父类的一-切子类对象,体现出多态的扩展性与便利。</p>
</li>
<li><p>多态下会产生的一个问题:</p>
<ul>
<li>多态下不能使用子类的独有功能</li>
</ul>
</li>
</ul>
<h3 id="13-3类型转换"><a href="#13-3类型转换" class="headerlink" title="13.3类型转换"></a>13.3类型转换</h3><ul>
<li>自动类型转换(从子到父)<ul>
<li>子类对象赋值给父类类型的变量指向。</li>
</ul>
</li>
<li>强制类型转换吗( 从父到子)<ul>
<li>此时必须进行强制类型转换: 子类对象变量= (子类)父类类型的变量</li>
<li>作用: 可以解决多态下的劣势,可以实现调用子类独有的功能。</li>
<li>注意:<ul>
<li>如果转型后的类型和对象真实类型不是同一种类型,那么在转换的时候就会出现ClassCastException</li>
<li>Java建议强转转换前使用instanceof判断当前对象的真实类型，再进行强制转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="14-内部类"><a href="#14-内部类" class="headerlink" title="14.内部类"></a>14.内部类</h2><h3 id="14-1概述"><a href="#14-1概述" class="headerlink" title="14.1概述"></a>14.1概述</h3><ul>
<li><p>内部类就是定义在一个类里面的类,里面的类可以理解成(寄生) ,外部类可以理解成(宿主)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heart</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>内部类的使用场景、作用</p>
<ul>
<li>当一个事物的内部，还有一个部分需要-个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构可以选择使用内部类来设计。</li>
<li>内部类通 常可以方便访问外部类的成员，包括私有的成员。</li>
<li>内部类提供 了更好的封装性，内部类本身就可以用private protectecd等修饰，封装性可以做更多控制。</li>
</ul>
<p>内部类的分类</p>
<ul>
<li>静态内部类[了解]</li>
<li>成员内部类(非静态内部类) [了 解]</li>
<li>局部内部类[了解]</li>
<li>匿名内部类(重点)</li>
</ul>
<h3 id="14-2静态内部类"><a href="#14-2静态内部类" class="headerlink" title="14.2静态内部类"></a>14.2静态内部类</h3><p>概述</p>
<ul>
<li><p>什么是静态内部类?</p>
<ul>
<li><p>有static修饰，属于外部类本身。</p>
</li>
<li><p>它的特点和使用与普通类是完全- -样的，类有的成分它都有,只是位置在别人里面而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"><span class="comment">//静态成员内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>静态内部类创建对象的格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式:外部类名.内部类名对象名= <span class="keyword">new</span>外部类名.内部类构造器;</span><br><span class="line">范例: Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br></pre></td></tr></table></figure></li>
<li><p>静态内部类可以直接访问外部类的静态成员</p>
</li>
<li><p>静态内部类不可以直接访问外部类的实例成员</p>
</li>
</ul>
<h3 id="14-3-成员内部类"><a href="#14-3-成员内部类" class="headerlink" title="14.3 成员内部类"></a>14.3 成员内部类</h3><p>概述</p>
<ul>
<li><p>无static修饰，属于外部类的对象。</p>
</li>
<li><p>jDK16之前，成员内部类中不能定义静态成员，JDK 16开始也可以定义静态成员了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"><span class="comment">//成员内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>成员内部类可以直接访问外部类的静态成员</p>
</li>
<li><p>成员内部类可以直接访问外部类的实例成员</p>
</li>
</ul>
<p>$在成员内部类中访问所在外部类对象,格式:外部类名.this。$</p>
<h3 id="14-4-局部内部类"><a href="#14-4-局部内部类" class="headerlink" title="14.4 局部内部类"></a>14.4 局部内部类</h3><ul>
<li>局部内部类放在方法、代码块、构造器等执行体中。</li>
<li>局部内部类的类文件名为:外部类$N内部类.class。</li>
</ul>
<h3 id="14-5-匿名内部类"><a href="#14-5-匿名内部类" class="headerlink" title="14.5 匿名内部类"></a>14.5 匿名内部类</h3><p>概述</p>
<ul>
<li><p>本质上是一一个没有名字的局部内部类，定义在方法中、代码块中、等。</p>
</li>
<li><p>作用:</p>
<ul>
<li>方便创建子类对象，最终目的为了简化代码编写。</li>
</ul>
</li>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>类|抽象类名|或者接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>特点总结:</p>
<ul>
<li>匿名内部类是一一个没有名字的内部类。</li>
<li>匿名内部类写出来就会产生一个匿名内部类的对象。</li>
<li>匿名内部类的对象类型相当于是当前new的那个的类型的子类类型。</li>
</ul>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="1-String概述"><a href="#1-String概述" class="headerlink" title="1.String概述"></a>1.String概述</h2><ul>
<li>java.lang.String类代表字符串，String类定义的变量可以用于指向字符串对象,然后操作该字符串。</li>
<li>Java程序中的所有字符串文字(例如”abc” )都为此类的对象。</li>
</ul>
<p>String类的特点详解</p>
<ul>
<li>String其实常被称为不可变字符串类型，它的对象在创建后不能被更改。<ul>
<li>String变量每次的修改其实都是产生并指向了新的字符串对象。</li>
<li>原来的字符串对象都是没有改变的，所以称不可变字符串。</li>
</ul>
</li>
</ul>
<h2 id="2-String类创建对象的两种方式"><a href="#2-String类创建对象的两种方式" class="headerlink" title="2.String类创建对象的两种方式"></a>2.String类创建对象的两种方式</h2><ul>
<li><p>方式一：直接使用定义。(推荐方式)</p>
</li>
<li><p>方式二:通过String类的构造器创建对象。</p>
<ul>
<li><table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String()</td>
<td>创建一个空白字符串对象，不含有任何内容</td>
</tr>
<tr>
<td>public String(String original)</td>
<td>根据传入的字符串内容，来创建字符串对象</td>
</tr>
<tr>
<td>public String(char[] chs)</td>
<td>根据字符数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td>public String(byte[] chs)</td>
<td>根据字节数组的内容，来创建字符串对象</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li>以“”方式给出的字符串对象，在字符串常量池中存储，而且相同内容只会在其中存储一份。</li>
<li>通过构造器new对象，每new一次都会产生一个新对象，放在堆内存中。</li>
</ul>
</li>
</ul>
<h2 id="3-String内容比较"><a href="#3-String内容比较" class="headerlink" title="3.String内容比较"></a>3.String内容比较</h2><p>推荐使用String类提供的”equals” 比较:只关心内容一样即可</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean equals (Object anObject)</td>
<td>将此字符串与指定对象进行比较。只关心字符内容是否致!</td>
</tr>
<tr>
<td>public boolean equalsIgnoreCase (String anotherString)</td>
<td>将此字符串与指定对象进行比较，忽略大小写比较字符串。只关心字符内容是否致!</td>
</tr>
</tbody></table>
<h2 id="4-String常用API"><a href="#4-String常用API" class="headerlink" title="4.String常用API"></a>4.String常用API</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int length()</td>
<td>返回此字符串的长度</td>
</tr>
<tr>
<td>public char charAt(int index)</td>
<td>获取某个索引位置处的字符</td>
</tr>
<tr>
<td>public char[] toCharArray():</td>
<td>将当前字符串转换成字符数组返回</td>
</tr>
<tr>
<td>public String substring( int beginIndex, int endIndex)</td>
<td>根据开始和结束索引进行截取，得到新的字符串(包前不包后</td>
</tr>
<tr>
<td>public String substring(int beginIndex)</td>
<td>从传入的索引处截取，截取到末尾，得到新的字符串</td>
</tr>
<tr>
<td>public String replace(CharSequence target,CharSequence replacement )</td>
<td>使用新值，将字符串中的旧值替换，得到新的字符串</td>
</tr>
<tr>
<td>public String[] split(String regex)</td>
<td>根据传入的规则切割字符串，得到字符串数组返回</td>
</tr>
</tbody></table>
<h1 id="ArrayLsit"><a href="#ArrayLsit" class="headerlink" title="ArrayLsit"></a>ArrayLsit</h1><h2 id="1-集合的概述"><a href="#1-集合的概述" class="headerlink" title="1.集合的概述"></a>1.集合的概述</h2><p>集合是与数组类似，也是一种容器，用于装数据的。</p>
<ul>
<li>数组定义完成并启动后,类型确定、长度固定。</li>
<li>问题:在个数不能确定，且要进行增删数据操作的时候，数组是不太合适的。</li>
</ul>
<p>集合的特点</p>
<ul>
<li>集合的大小不固定，启动后可以动态变化，类型也可以选择不固定。</li>
<li>集合非常适合做元素个数不确定，且要进行增删操作的业务场景。</li>
<li>集合的提供了许多丰富、好用的功能，而数组的功能很单一。</li>
</ul>
<h2 id="2-ArrayLsit集合"><a href="#2-ArrayLsit集合" class="headerlink" title="2.ArrayLsit集合"></a>2.ArrayLsit集合</h2><p>ArrayList是集合中的一种,它支持索引。</p>
<ul>
<li><p>ArrayList集合的对象获取</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ArrayList()</td>
<td>创建一个空的集合对象</td>
</tr>
</tbody></table>
</li>
<li><p>ArrayList集合添加元素的方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean add(E e)</td>
<td>将元素追加到此集合的末尾</td>
</tr>
<tr>
<td>public void add(int index,E element)</td>
<td>在此集合中指定位置加入指定的元素</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="3-ArrayLsit对于泛型的支持"><a href="#3-ArrayLsit对于泛型的支持" class="headerlink" title="3.ArrayLsit对于泛型的支持"></a>3.ArrayLsit对于泛型的支持</h2><p>概述</p>
<ul>
<li>ArrayList<E>:其实就是一一个泛型类,可以在编译阶段约束集合对象只能操作某种数据类型。</li>
<li>举例<ul>
<li>ArrayList<String> :此集合只能操作字符串类型的元素。</li>
<li>ArrayList<Integer>:此集合只能操作整数类型的元素。</li>
</ul>
</li>
</ul>
<h2 id="4-ArrayLsit常用API"><a href="#4-ArrayLsit常用API" class="headerlink" title="4.ArrayLsit常用API"></a>4.ArrayLsit常用API</h2><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public E get(int index)</td>
<td>返回指定索引处的元素</td>
</tr>
<tr>
<td>public int size()</td>
<td>返回集合中的元素的个数</td>
</tr>
<tr>
<td>public E remove(int index)</td>
<td>删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td>public boolean remove(Object 0)<a href="%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E5%80%BC">^remove</a></td>
<td>删除指定的元素，返回删除是否成功</td>
</tr>
<tr>
<td>public E set(int index,E element)</td>
<td>修改指定索引处的元素，返回被修改的元素</td>
</tr>
</tbody></table>
<h1 id="语法知识"><a href="#语法知识" class="headerlink" title="语法知识"></a>语法知识</h1><h2 id="1-包"><a href="#1-包" class="headerlink" title="1. 包"></a>1. 包</h2><p>概述</p>
<ul>
<li>包是用来分门别类的管理各种不同类的，类似于文件夹、建包利于程序的管理和维护。</li>
<li>建包的语法格式: package 公司域名倒写技术名称。报名建议全部英文小写，且具备意义</li>
<li>建包语句必须在第一行，一般IDEA工具会帮助创建</li>
</ul>
<p>导包</p>
<ul>
<li>相同包下的类可以直接访问，不同包下的类必须导包,才可以使用导包格式: import 包名.类名;</li>
<li>假如一个类中需要用到不同类，而这个两个类的名称是一样的, 那么默认只能导入一个类,另一个类要带包名访问。</li>
</ul>
<h2 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2.权限修饰符"></a>2.权限修饰符</h2><p>概述</p>
<ul>
<li>权限修饰符:是用来控制一-个成员能够被访问的范围的。</li>
<li>可以修饰成员变量、方法、构造器、内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制。</li>
</ul>
<p>权限修饰符的分类和具体作用范围:</p>
<ul>
<li><p>权限修饰符:有四种作用范围由小到大(private -&gt;缺省-&gt; protected - &gt; public )</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th align="center">同一个类中</th>
<th align="center">同一个包其他类</th>
<th align="center">不同包下的子类</th>
<th align="center">不同包下的无关类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>缺省</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td>public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
</li>
</ul>
<p>作用</p>
<ul>
<li>能够识别别人定义的成员的访问权限。</li>
<li>自己定义成员(方法,成员变量,构造器等) 一般满足如下要求:<ul>
<li>成员变量一般私有。</li>
<li>方法一般公开。</li>
<li>如果该成员只希望本类访问，使用private修饰。</li>
<li>如果该成员只希望本类，同一个包下的其他类和子类访问，使用protected修饰。</li>
</ul>
</li>
</ul>
<h2 id="3-final"><a href="#3-final" class="headerlink" title="3.final"></a>3.final</h2><p>作用</p>
<ul>
<li>final关键字是最终的意思，可以修饰(方法，变量，类)</li>
<li>修饰方法:表明该方法是最终方法，不能被重写。</li>
<li>修饰变量:表示该变量第一-次赋值后,不能再次被赋值(有且仅能被赋值一次)。</li>
<li>修饰类:表明该类是最终类,不能被继承。</li>
</ul>
<p>final修饰变量的注意</p>
<ul>
<li>final修饰的变量 是基本类型:那么变量存储的数据值不能发生改变。</li>
<li>final修饰的变量是引用类型:那么变量存储的地址值不能发生改变，但是地址指向的对象内容是可以发生变化的。</li>
</ul>
<h2 id="4-常量"><a href="#4-常量" class="headerlink" title="4.常量"></a>4.常量</h2><p>概述</p>
<ul>
<li>常量是使用了public static final修饰的成员变量,必须有初始化值,而且执行的过程中其值不能被改变。</li>
<li>常量的作用和好处:可以用于做系统的配置信息，方便程序的维护，同时也能提高可读性。</li>
<li>常量命名规范:<ul>
<li>英文单词全部大写，</li>
<li>多个单词下划线连接起来。</li>
</ul>
</li>
</ul>
<p>常量的执行原理</p>
<ul>
<li>在编译阶段会进行“宏替换”，把使用常量的地方全部替换成真实的字面量。</li>
<li>这样做的好处是让使用常量的程序的执行性能与直接使用字面量是一样的。</li>
</ul>
<p>选择常量做信息标志和分类:</p>
<ul>
<li>代码可读性好，实现了软编码形式。</li>
</ul>
<h2 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h2><p>概述</p>
<ul>
<li>枚举是Java中的一种特殊类型</li>
<li>枚举的作用: “是为了做信息的标志和信息的分类”。</li>
</ul>
<p>定义枚举的格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符<span class="keyword">enum</span>枚举名称&#123;</span><br><span class="line">第一行都是罗列枚举类实例的名称。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举的特征</p>
<ul>
<li>枚举类都是继承了枚举类型: java.lang.Enum</li>
<li>枚举都是最终类，不可以被继承。</li>
<li>枚举的构造器都是私有的，枚举对外不能创建对象。</li>
<li>枚举类的第一行默认都是罗列枚举对象的名称的。</li>
<li>枚举相当于是多例模式</li>
</ul>
<p>枚举做信息标志和分类:</p>
<ul>
<li>代码可读性好，入参约束严谨,代码优雅,是最好的信息分类技术!建议使用!</li>
</ul>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1. Object类"></a>1. Object类</h2><p>0bject类的作用:</p>
<ul>
<li>一个类要么默认继承了0bject类,要么间接继承了Object类, 0bject类 是Java中的祖宗类。</li>
<li>Object类的方法是一切子类都可以直接使用的， 所以我们要学习0bject类的方法。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String toString()</td>
<td>默认是返回当前对象在堆内存中的地址信息:类的全限名@内存地址</td>
</tr>
<tr>
<td>public Boolean equals(Object o)</td>
<td>默认是比较当前对象与另-个对象的地址是否相同，相同返回true,不同返回false</td>
</tr>
</tbody></table>
<p>Objects概述</p>
<ul>
<li>Objects类 与Object还是继承关系，Objects类 是从JDK 1.7开始之后才有的。</li>
<li>Objects的equals方法比较的结果是一样的，但是更安全。</li>
</ul>
<h2 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2. StringBuilder"></a>2. StringBuilder</h2><p>概述</p>
<ul>
<li>StringBuilder是一个可变的字符串类,我们可以把它看成是一个对象容器。</li>
<li>作用:提高字符串的操作效率，如拼接、修改等。</li>
</ul>
<p>构造器</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuilder()</td>
<td>创建一个空白的可变的字符串对象，不包含任何内容</td>
</tr>
<tr>
<td>public StringBuilder()</td>
<td>创建一 个指定字符串内容的可变字符串对象</td>
</tr>
</tbody></table>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuilder append(任意类型)</td>
<td>添加数据并返回StringBuilder对象本身</td>
</tr>
<tr>
<td>public StringBuilder reverse()</td>
<td>将对象的内容反转</td>
</tr>
<tr>
<td>public int length()</td>
<td>返回对象内容长度</td>
</tr>
<tr>
<td>public String toString()</td>
<td>通过toString()就可以实现把StringBuilder转换为String</td>
</tr>
</tbody></table>
<h2 id="3-Math类"><a href="#3-Math类" class="headerlink" title="3.Math类"></a>3.Math类</h2><ul>
<li><p>包含执行基本数字运算的方法, Math类没有提供公开的构造器。</p>
</li>
<li><p>类的成员都是静态的，用类名就可以直接访问</p>
</li>
<li><p>常用方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static int abs(int a)</td>
<td>获取参数绝对值</td>
</tr>
<tr>
<td>public static double ceil(double a)</td>
<td>向上取整</td>
</tr>
<tr>
<td>public static double floor(double a)public static double floor(double a)</td>
<td>向下取整</td>
</tr>
<tr>
<td>public static int round(float a)</td>
<td>四舍五入</td>
</tr>
<tr>
<td>public static int max(int a,int b)</td>
<td>获取两个int值中的较大值</td>
</tr>
<tr>
<td>public static double pow(double a,double b)</td>
<td>返回a的b次幂的值</td>
</tr>
<tr>
<td>public static double randpm()</td>
<td>返回值为double的随机值，范围[0.0,1.0)</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="4-System"><a href="#4-System" class="headerlink" title="4. System"></a>4. System</h2><p>概述</p>
<ul>
<li>System的功能是通用的，都是直接用类名调用即可，所以System不能被实例化。</li>
</ul>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static void exit(int status)</td>
<td>终止当前运行的Java虚拟机，非<br/>零表示异常终止</td>
</tr>
<tr>
<td>public static long currentTimeMillis()</td>
<td>返回当前系统的时间毫秒值形式</td>
</tr>
<tr>
<td>public static void arraycopy(数据源数组，<br>起始索引,目的地数组,起始索引,拷贝个数)数组拷贝</td>
<td>数组拷 贝</td>
</tr>
</tbody></table>
<p>时间毫秒值</p>
<ul>
<li>计算机认为时间是有起点的，起始时间: 1970年1月1日 00:00:00</li>
<li>时间毫秒值:指的是从1970年1月1日 00:00:00走到此刻的总的毫秒数,应该是很大的。1s = 1000ms。</li>
</ul>
<p>原因:</p>
<ul>
<li>1969年8月，贝尔实验室的程序员肯汤普逊利用妻儿离开- -个月的机会，开始着手创造一一个全新的革命性的操作系统，他使用B编译语言在老旧的PDP-7机器上开发出了Unix的一个版本。随后，汤普逊和同事丹尼斯里奇改进了B语言,开发出了C语言,重写了UNIX。</li>
</ul>
<h2 id="5-BigDecimal"><a href="#5-BigDecimal" class="headerlink" title="5.BigDecimal"></a>5.BigDecimal</h2><p>作用</p>
<ul>
<li>用于解决浮点型运算精度失真的问题<ul>
<li><code>public static BigDecimal value0f(double val):包装浮 点数成为BigDecimal对象。</code></li>
</ul>
</li>
</ul>
<p>常用API</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BigDecimal add(BigDecimal b)</td>
<td>加法</td>
</tr>
<tr>
<td>public BigDecimal subtract(BigDecimal b)</td>
<td>减法</td>
</tr>
<tr>
<td>public BigDecimal multiply(BigDecimal b)</td>
<td>乘法</td>
</tr>
<tr>
<td>public BigDecimal divide(BigDecimal b)</td>
<td>除法</td>
</tr>
<tr>
<td>public BigDecimal divide (另一个BigDecimal对象， 精确几位，舍入模式)</td>
<td>除法</td>
</tr>
</tbody></table>
<h1 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h1><h2 id="1-Date"><a href="#1-Date" class="headerlink" title="1.Date"></a>1.Date</h2><p>概述</p>
<ul>
<li>Date类的对象在Java中代表的是当前所在系统的此刻日期时间。</li>
</ul>
<p>构造器</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Date()</td>
<td>创建一个Date对象，代表的是系统当前此刻日期时间。</td>
</tr>
</tbody></table>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public long getTime()</td>
<td>获取时间对象的毫秒值</td>
</tr>
</tbody></table>
<p>Date类记录时间的2种形式</p>
<ol>
<li><p>日期对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建一个日期对象代表了:当前系统的此刻日期时间对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System. out . println(d);</span><br></pre></td></tr></table></figure></li>
<li><p>时间毫秒值</p>
<ul>
<li><p>指的是从1970年1月1日00:00:00走 到此刻的总的毫秒数,应该是很大的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、获取当前时间毫秒值</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span></span><br><span class="line"><span class="operator">=</span> d.getTime();</span><br><span class="line">System. out . println(time) ;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>时间毫秒值-&gt;日期对象</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>构造器</td>
<td>public Date(long time)</td>
<td>把时间毫秒值转换成Date日期对象。</td>
</tr>
<tr>
<td>方法</td>
<td>public void setTime(long time)</td>
<td>设置日期对象的时间为当前时间毫秒值对应的时间</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="2-SimpleDateFormat"><a href="#2-SimpleDateFormat" class="headerlink" title="2. SimpleDateFormat"></a>2. SimpleDateFormat</h2><p>作用</p>
<ul>
<li>可以对Date对象或时间毫秒值格式化成我们喜欢的时间形式。</li>
<li>也可以把字符串的时间形式解析成日期对象。</li>
</ul>
<p>构造器</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public SimpleDateFormat()</td>
<td>构造一-个SimpleDateFormat,使用默认格式</td>
</tr>
<tr>
<td>public simpleDateFormat(String pattern)</td>
<td>构造一个SimpleDateFormat,使用指定的格式</td>
</tr>
</tbody></table>
<p>方法</p>
<table>
<thead>
<tr>
<th>格式化方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public final String format(Date date)</td>
<td>将日期格式化成日期/时间字符串</td>
</tr>
<tr>
<td>public final String format(Object time)</td>
<td>将时间毫秒值式化成日期/时间字符串</td>
</tr>
</tbody></table>
<p>格式化的时间形式的常用的模式对应关系如下:</p>
<table>
<thead>
<tr>
<th>y</th>
<th>年</th>
</tr>
</thead>
<tbody><tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<p>解析字符串时间成为日期对象</p>
<table>
<thead>
<tr>
<th>解析方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Date parse(String source)</td>
<td>从给指定字符串的开始解析文本以生成时间</td>
</tr>
</tbody></table>
<h2 id="3-Calendar"><a href="#3-Calendar" class="headerlink" title="3. Calendar"></a>3. Calendar</h2><p>概述</p>
<ul>
<li>Calendar代表 了系统此刻日期对应的日历对象。</li>
<li>Calendar是- 一个抽象类,不能直接创建对象。</li>
</ul>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int get(int field)</td>
<td>取日期中的某个字段信息。</td>
</tr>
<tr>
<td>public void set(int field,int value)</td>
<td>修改日历的某个字段信息。</td>
</tr>
<tr>
<td>public void add(int field, int amount)</td>
<td>为某个字段增加/减少指定的值</td>
</tr>
<tr>
<td>public final Date getTime()</td>
<td>拿到此刻日期对象。</td>
</tr>
<tr>
<td>public long getTimeInMillis()</td>
<td>拿到此刻时间毫秒值</td>
</tr>
</tbody></table>
<h2 id="4-新增日期类"><a href="#4-新增日期类" class="headerlink" title="4.新增日期类"></a>4.新增日期类</h2><p>概述</p>
<ul>
<li>从ava 8开始，java.time包提供 了新的日期和时间API,主要涉及的类型有:<ol>
<li>LocalDate:不包含具体时间的日期。</li>
<li>LocalTime:不含日期的时间。</li>
<li>LocalDateTime:包含了日期及时间。</li>
<li>Instant:代表的是时间戳。</li>
<li>DateTimeFormatter用于做时间的格式化和解析的</li>
<li>Duration:用于计算两个“时间”间隔</li>
<li>Period:用于计算两个“日期”间隔</li>
</ol>
</li>
<li>新增的API严格区分了时刻、本地日期、本地时间,并且,对日期和时间进行运算更加方便。</li>
<li>其次，新API的类型几乎全部是不变类型(和String的使用类似)，可以放心使用不必担心被修改。</li>
</ul>
<h3 id="4-1LocalDate、LocalTime、LocalDateTime"><a href="#4-1LocalDate、LocalTime、LocalDateTime" class="headerlink" title="4.1LocalDate、LocalTime、LocalDateTime"></a>4.1LocalDate、LocalTime、LocalDateTime</h3><ul>
<li>他们分别表示日期，时间，日期时间对象,他们的类的实例是不可变的对象。</li>
<li>他们三者构建对象和API都是通用的</li>
<li>构建对象方式</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>public static Xxxx.now();</td>
<td>静态方法，根据当前时间创建对象</td>
<td>LocaDate localDate = LocalDate.now();<br>LocalTime llocalTime = LocalTime.nom();<br>LocalDateTime localDateTime = LocalDateTime.nom();</td>
</tr>
<tr>
<td>public static Xxx.Of(..);</td>
<td>静态方法，指定日期/时间创建对象</td>
<td>LocalDate localDate1 = LocalDate. of(2099，11,11);<br> LocalTime localTime1 = LocalTime.of11, 11, 11);<br>LocalDateTime localDateTime1 = LocalDateTime.of(2020, 10, 6, 13,,22,43);</td>
</tr>
</tbody></table>
<p>LocalDateTime的转换API</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public LocalDate toLocalDate()</td>
<td>转换成一个LocalDate对象</td>
</tr>
<tr>
<td>public LocalTime toLocalTime()</td>
<td>转换成一个LocalTime对象</td>
</tr>
</tbody></table>
<p>修改相关的API</p>
<ul>
<li>LocalDateTime综合了LocalDate和LocalTime里面的方法，所以下面只用LocalDate和LocalTime来举例。</li>
<li>●这些方法返回的是- -个新的实例引用，因为LocalDateTime 、LocalDate 、LocalTime 都是不可变的。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>plusDays, plusWeeks, plusMonths, plusYears</td>
<td>向当前LocalDate对象添加几天、几周、几个月、几年</td>
</tr>
<tr>
<td>minusDays, minusWeeks, minusMonths, minusYears</td>
<td>从当前LocalDate对象减去几天、几周、几个月、几年</td>
</tr>
<tr>
<td>withDayOfMonth, withDayOfYear, withMonth, withYear</td>
<td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的</td>
</tr>
<tr>
<td>isBefore, isAfter</td>
<td>比较两个LocalDate</td>
</tr>
</tbody></table>
<h3 id="4-2-Instant时间戳"><a href="#4-2-Instant时间戳" class="headerlink" title="4.2 Instant时间戳"></a>4.2 Instant时间戳</h3><p>概述</p>
<ul>
<li>JDK8获取时间戳特别简单，且功能更丰富。Instant类由一 -个静态的工厂方法now()可以返回当前时间戳。</li>
<li>时间戳是包含日期和时间的，与java.util.Date很类似， 事实上Instant就是类似JDK8以前的Date。</li>
<li>Instant和Date这两个类可以进行转换。</li>
</ul>
<h3 id="4-3DateTimeFormatter"><a href="#4-3DateTimeFormatter" class="headerlink" title="4.3DateTimeFormatter"></a>4.3DateTimeFormatter</h3><ul>
<li>在JDK8中， 引入了一个全新的日期与时间格式器DateTimeFormatter.</li>
<li>正反都能调用format方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime . now( );</span><br><span class="line">System.out.println(ldt);<span class="comment">//2021-03-01T15:09:17.444190900</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter . ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">ldtStr</span> <span class="operator">=</span> ldt.format(dtf);</span><br><span class="line">System. out. println(1dtStr);<span class="comment">//2021-03-01 15:09:17</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ldtStr1</span> <span class="operator">=</span> dtf <span class="title function_">format</span> <span class="params">(ldt)</span>;</span><br><span class="line">System.out.println(ldtStr1);<span class="comment">//2021-03-01 15:09:17</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-Period"><a href="#4-4-Period" class="headerlink" title="4.4 Period"></a>4.4 Period</h3><ul>
<li><p>在Java8中, 我们可以使用以下类来计算8期间隔差异: java.time.Period</p>
</li>
<li><p>主要是Period类方法getYears(), getMonths() 和getDays()来计算,只能精确到年月日。</p>
</li>
<li><p>用于LocalDate之间的比较。</p>
</li>
<li><p>```java<br>LocalDate today = LocalDate.now();<br>System.out.println(today);<br>// 2021-03-01<br>LocalDate birthDate = LocalDate.of(1995， 1, 11);<br>System.out.println(birthDate); // 1995-01-11<br>Period period = Period.between(birthDate, today);<br>System.out.printf(“年龄: %d年%d月%d日”,period.getYears(),period. getMonths(),<br>period.getDays()) ;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4.5 Duration</span><br><span class="line"></span><br><span class="line">+ 在Java8中， 我们可以使用以下类来计算时间间隔差异: java.time.Duration</span><br><span class="line">+ 提供了使用基于时间的值测量时间量的方法。</span><br><span class="line">+ 用于LocalDateTime之间的比较。也可用于Instant之间的比较。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">LocalDateTime today = LocalDateTime.now();</span><br><span class="line">System.out.println(today);</span><br><span class="line">I</span><br><span class="line">LocalDateTime birthDate = LocalDateTime.of(1990,10,1,10,50,30);</span><br><span class="line">System.out.println(birthDate);</span><br><span class="line">Duration duration = Duration.between(birthDate,today);//第二 个参数减第一个参数</span><br><span class="line">System.out.println(duration.toDays());//两个时间差的天数</span><br><span class="line">System.out.println(duration.toHours());//两个时间差的小时数</span><br><span class="line">System.out.println(duration.toMinutes());//两个时间差的分钟数</span><br><span class="line">System.out.println(duration.toMillis());//两个时间差的毫秒数</span><br><span class="line">System.out.println(duration.toNanos());//两个时间差的纳秒数</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-6ChronoUnit"><a href="#4-6ChronoUnit" class="headerlink" title="4.6ChronoUnit"></a>4.6ChronoUnit</h3><ul>
<li>ChronoUnit类可用于在单个时间单位内测量-段时间， 这个工具类是最全的了，可以用于比较所有的时间单位</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">today</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(today);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">birthDate</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">1990</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">30</span>);</span><br><span class="line">System.out.println(birthDate);</span><br><span class="line">System.out.println(“相差的年数:”+ ChronoUnit.YEARS.between(birthDate, today)); </span><br><span class="line">System.out.println(<span class="string">&quot;相差的月数:”+ ChronoUnit.MONTHS.between(birthDate, today));</span></span><br><span class="line"><span class="string">System.out.println(&quot;</span>相差的周数:”+ChronoUnit.WEEKS.between(birthDate, today));</span><br><span class="line">System.out.println(“相差的天数:”+ ChronoUnit.DAYS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的时数:”+ChronoUnit.HOURS.between(birthDate, today));</span></span><br><span class="line"><span class="string">System.out.println(&quot;</span>相差的分数:”+ChronoUnit.MINUTES.between(birthDate, today));</span><br><span class="line">System.out.print1n(<span class="string">&quot;相差的秒数:”+ChronoUnit.SECONDS.between(birthDate, today));</span></span><br><span class="line"><span class="string">System.out.print1n(&quot;</span>相差的毫秒数:”+ChronoUnit.MILLIS.between(birthDate, today));</span><br><span class="line">System.out.println(“相差的微秒数:”+ChronoUnit.MICROS.between(birthDate, today));</span><br><span class="line">System.out.println(“相差的纺秒数:”+ ChronoUnit.NANOS.between(birthDate, today));</span><br><span class="line">System.out.println(“相差的半天数:”+ChronoUnit.HALFDAYS.between(birthDate, today)); </span><br><span class="line">System.out.println(<span class="string">&quot;相差的十年数:”+ChronoUnit.DECADES.between(birthDate, today));</span></span><br><span class="line"><span class="string">System.out.println(*相差的世纪(百年)数:”+ChronoUnit.CENTURIES. between(birthDate, today));</span></span><br><span class="line"><span class="string">System.out.println(&quot;</span>相差的千年数:”+ChronoUnit.MILLENNIA.between(birthDate, today));</span><br><span class="line">System.out.print1n(<span class="string">&quot;相差的纪元数:”+ ChronoUnit.ERAS.between(birthDate, today));</span></span><br></pre></td></tr></table></figure>

<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>概述</p>
<ul>
<li>其实就是8种基本数据类型对应的引用类型。</li>
</ul>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>引用数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>char</td>
<td>Charal[;ter</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<ul>
<li><p>Java为了实现一切皆对象，为8种基本类型提供了对应的引用类型。</p>
</li>
<li><p>后面的集合和泛型其实也只能支持包装类型不支持基本数据类型。</p>
</li>
<li><p>自动装箱:基本类型的数据和变量可以直接赋值给包装类型的变量。</p>
</li>
<li><p>自动拆箱:包装类型的变量可以直接赋值给基本数据类型的变量。</p>
</li>
</ul>
<p>包装类的特有功能</p>
<ul>
<li><p>包装类的变量的默认值可以是null,容错率更高。</p>
</li>
<li><p>可以把基本类型的数据转换成字符串类型(用处不大)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用toString()方法得到字符串结果。</span><br><span class="line">调用Integer.toString(基本类型的数据)。</span><br></pre></td></tr></table></figure></li>
<li><p>可以把字符串类型的数值转换成真实的数据类型(真的很有用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.parselnt(“字符串类型的整数”)</span><br><span class="line">Double.parseDouble(“字符串类型的小数”)。</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul>
<li>正则表达式可以用一些规定的字符来制定规则，并用来校验数据格式的合法性。</li>
</ul>
<h3 id="2-匹配规则"><a href="#2-匹配规则" class="headerlink" title="2.匹配规则"></a>2.匹配规则</h3><ol>
<li><p>字符类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[abc]			只能是a, b,或c</span><br><span class="line">[^abc]			除了a, b, c之外的任何字符</span><br><span class="line">[a-ZA-Z]		a到z A到Z,包括(范围) </span><br><span class="line">[a-d[m-p]]		a到d,或m通过p: ([a-dm-p]联合)</span><br><span class="line">[a-z&amp;&amp;[def]		d, e,或f(交集)</span><br><span class="line">[a-z&amp;&amp;[^bc]]	a到z，除了b和C: ([ad-z]减法 )</span><br><span class="line">[a-z&amp;&amp;[^m- p]]	a到z，除了m到p: ([a-lq-z]减法 )</span><br></pre></td></tr></table></figure></li>
<li><p>预定义字符类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.		任何字符</span><br><span class="line">\d		一个数字: [<span class="number">0</span>-<span class="number">9</span>]k</span><br><span class="line">\D		非数字: [^<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line">\s		一个空白字符: [ \t\n\x0B\f\r]</span><br><span class="line">\S		非空白字符: [^\s]</span><br><span class="line">\w		[a-zA-Z_ _0-<span class="number">9</span>]英文、数字、下划线</span><br><span class="line">\W		[^\w]一个非单词字符</span><br></pre></td></tr></table></figure></li>
<li><p>贪婪的量词</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X?			X,一次或根本不</span><br><span class="line">X*			X，零次或多次</span><br><span class="line">X+			X,一次或多次</span><br><span class="line">X &#123;n&#125;		X，正好n次</span><br><span class="line">X&#123;n,&#125;		X，至少n次</span><br><span class="line">X &#123;n,m&#125; 	X至少n但不超过m次</span><br></pre></td></tr></table></figure></li>
<li><p>字符串对象提供了匹配正则表达式规则的API</p>
<p><code>public boolean matches (String regex): 判断是否匹配正则表达式，匹配返回true,不匹配返回false。</code></p>
</li>
</ol>
<p>正则表达式支持爬取信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span>“来黑马程序学习Java,电话<span class="number">020</span>- <span class="number">43422424</span>，或者联系邮箱”+</span><br><span class="line"><span class="string">&quot;itcast@itcast .cn,电话18762832633，0203232323&quot;</span> +</span><br><span class="line"><span class="string">&quot;邮箱bozai@itcast.cn.400- 100-3233，4001003232&quot;</span> ;</span><br><span class="line"><span class="comment">//需求:从上面的内容中爬取出电话号码和邮箱。</span></span><br><span class="line"><span class="comment">// 1. 定义爬取规则</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(\w&#123;1,&#125;@\W&#123;2,10&#125;(\.\\w&#123;2,10&#125;)&#123;1,2&#125;)1&quot;</span></span><br><span class="line"><span class="string">&quot;(1[3-9]\\d&#123;9&#125;)|(0\\d&#123;2,5&#125;-?\\d&#123;5,15&#125;)|400-?\\d&#123;3,8&#125;-?\\d&#123;3,8&#125;&quot;</span>;</span><br><span class="line"><span class="comment">// 2. 编泽正则表达式成为- - 个四配规则对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"><span class="comment">// 3.通过四配规则对象得到一- 个匹配数据内容的匹配器对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(rs);</span><br><span class="line"><span class="comment">// 4.通过匹配器去内容中爬取出信息</span></span><br><span class="line"><span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">System.out.print1n(matcher.group());</span><br></pre></td></tr></table></figure>

<h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h2><p>数组操作工具类，专门用于操作数组元素的。</p>
<h2 id="2-常用API"><a href="#2-常用API" class="headerlink" title="2. 常用API"></a>2. 常用API</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static String toString(类型[ a)</td>
<td>打印数组</td>
</tr>
<tr>
<td>public static void sort(类型] a)</td>
<td>对数组进行默认升序排序</td>
</tr>
<tr>
<td>public static <T> void sort(类型[ a, Comparator&lt;? superT&gt;c)</td>
<td>使用 比较器对象自定义排序</td>
</tr>
<tr>
<td>public static int binarySearch(int[] a, int key)</td>
<td>二分搜索数组中的数据，存在返回索引，不存在返回-1</td>
</tr>
</tbody></table>
<h2 id="3-比较器"><a href="#3-比较器" class="headerlink" title="3.比较器"></a>3.比较器</h2><p>设置Comparator接口对应的比较器对象，来定制比较规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果认为左边数据大于右边数据返回正整数</span><br><span class="line">如果认为左边数据小于右边数据返回负整数</span><br><span class="line">如果认为左边数据等于右边数据返回<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Lanbda表达式"><a href="#4-Lanbda表达式" class="headerlink" title="4.Lanbda表达式"></a>4.Lanbda表达式</h2><p>概述</p>
<ul>
<li>Lambda表达式是JDK 8开始后的一种新语法形式。</li>
<li>作用:简化匿名内部类的代码写法。</li>
</ul>
<p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(匿名内部类被重写方法的形参列表) -&gt; &#123;</span><br><span class="line">被重写方法的方法体代码。</span><br><span class="line">&#125;</span><br><span class="line">注: -&gt;是语法形式，无实际含义</span><br></pre></td></tr></table></figure>

<p>注意: </p>
<ul>
<li>Lambda表达式只能简化函数式接口的匿名内部类的写法形式</li>
<li>首先必须是接口、其次接口中有且仅有一个抽象方法的形式</li>
<li>通常我们会在接口上加上一个@FunctionalInterface注解，标记该接口必须是满足函数式接口。</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h2><p>集合和数组都是容器</p>
<p>数组</p>
<ul>
<li>数组定义完成并启动后，类型确定、长度固定。</li>
<li>在进行增删数据操作的时候，数组是不太合适的，增删数据都需要放弃原有数组或者移位。</li>
<li>适用场景<ul>
<li>当业务数据的个数是固定的，且都是同一批数据类型的时候，可以采取定义数组存储。</li>
</ul>
</li>
</ul>
<p>集合</p>
<ul>
<li>集合是Java中存储对象数据的一种容器。</li>
<li>集合的大小不固定，启动后可以动态变化，类型也可以选择不固定。集合更像气球。</li>
<li>集合非常适合做元素的增删操作。</li>
<li>集合中只能存储引用类型数据，如果要存储基本类型数据可以选用包装类。</li>
<li>适用场景<ul>
<li>数据的个数不确定，需要进行增删元素的时候。</li>
</ul>
</li>
</ul>
<h2 id="2-体系特点"><a href="#2-体系特点" class="headerlink" title="2.体系特点"></a>2.体系特点</h2><p>集合体系结构</p>
<ul>
<li>Collection 单例<a href="%E5%8D%95%E4%BE%8B%E9%9B%86%E5%90%88%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0(%E6%95%B0%E6%8D%AE)%E5%8F%AA%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E5%80%BC">^collection</a></li>
<li>Map双例<a href="%E5%8F%8C%E4%BE%8B%E9%9B%86%E5%90%88%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AA%E5%80%BC(%E9%94%AE%E5%80%BC%E5%AF%B9)">^map</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(Collection)==&gt;B(List)</span><br><span class="line">A==&gt;C(Set)</span><br><span class="line">B==&gt;D([ArrayList])</span><br><span class="line">B==&gt;E([LinkedList])</span><br><span class="line">C==&gt;F([HashSet])</span><br><span class="line">C==&gt;G([TreeSet])</span><br><span class="line">F==&gt;I([LinkedHashSET])</span><br><span class="line">J(接口)</span><br><span class="line">K([实现类])</span><br></pre></td></tr></table></figure>

<ul>
<li>List系列集合特点<ul>
<li>添加元素是有序、可重复、有索引</li>
<li>ArrayList、LinekdList :有序、可重复、有索引。</li>
</ul>
</li>
<li>Set系列集合:添加的元素是无序、不重复、无索引。<ul>
<li>HashSet:无序、不重复、无索引; LinkedHashSet: 有序、不重复、无索引。</li>
<li>TreeSet:按照大小默认升序排序、不重复、无索引</li>
</ul>
</li>
</ul>
<p><strong>集合都是支持泛型的，可以在编译阶段约束集合只能操作某种数据类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">Collection&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// JDK 1. 7开始后面的泛型类型申明可以省略不写</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:集合和泛型都只能支持引用数据类型，不支持基本数据类型，所以集合中存储的元素都认为是对象。</strong></p>
<h2 id="3-常用API"><a href="#3-常用API" class="headerlink" title="3. 常用API"></a>3. 常用API</h2><p>Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean add(E e)</td>
<td>把给定的对象添加到当前集合中</td>
</tr>
<tr>
<td>public void clear()</td>
<td>清空集合中所有的元素</td>
</tr>
<tr>
<td>public boolean remove(E e)</td>
<td>把给定的对象在当前集合中删除</td>
</tr>
<tr>
<td>public boolean contains(Object obj)</td>
<td>判断当前集合中是否包含给定的对象</td>
</tr>
<tr>
<td>public boolean isEmpty()</td>
<td>判断当前集合是否为空</td>
</tr>
<tr>
<td>public int size()</td>
<td>返回集合中元素的个数。</td>
</tr>
<tr>
<td>public Object[] toArray()</td>
<td>把集合中的元素，存储到数组中</td>
</tr>
</tbody></table>
<h2 id="4-遍历"><a href="#4-遍历" class="headerlink" title="4.遍历"></a>4.遍历</h2><h3 id="4-1-迭代器"><a href="#4-1-迭代器" class="headerlink" title="4.1 迭代器"></a>4.1 迭代器</h3><p>概述</p>
<ul>
<li>遍历就是一个一个的把容器中的元素访问一-遍。</li>
<li>迭代器在Java中的代表是Iterator,迭代器是集合的专用遍历方式。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Iterator<E> iterator()</td>
<td>返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引</td>
</tr>
<tr>
<td>boolean hasNext()</td>
<td>询问当前位置是否有元素存在，存在返回true ,不存在返回false</td>
</tr>
<tr>
<td>E next()</td>
<td>获取当前位置的元素,并同时将迭代器对象移向下一一个位置，注意防止取出越界。</td>
</tr>
</tbody></table>
<h3 id="4-2-foreach循环"><a href="#4-2-foreach循环" class="headerlink" title="4.2 foreach循环"></a>4.2 foreach循环</h3><p>概述</p>
<ul>
<li>增强for循环:既可以遍历集合也可以遍历数组。</li>
<li>它是JDK5之后出现的，其内部原理是一个Iterator迭代器，遍历集合相当于是迭代器的简化写法。</li>
</ul>
<p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素数据类型变量名: 数组或者Collection集合) &#123;</span><br><span class="line"><span class="comment">//在此处使用变量即可，该变量就是元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Lambda"><a href="#4-3-Lambda" class="headerlink" title="4.3 Lambda"></a>4.3 Lambda</h3><ul>
<li>得益于JDK 8开始的新技术Lambda表达式，提供了-种更简单、更直接的遍历集合的方式。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>default void forEach(Consumer&lt;? super T&gt; action):</td>
<td>结合lambda遍历集合</td>
</tr>
</tbody></table>
<h2 id="5-常见数据结构"><a href="#5-常见数据结构" class="headerlink" title="5.常见数据结构"></a>5.常见数据结构</h2><p>概述</p>
<ul>
<li>数据结构是计算机底层存储、组织数据的方式。是指数据相互之间是以什么方式排列在一起的。</li>
<li>通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率</li>
</ul>
<ol>
<li>栈数据结构的执行特点<ul>
<li>后进先出，先进后出</li>
</ul>
</li>
<li>常见数据结构之队列<ul>
<li>先进先出，后进后出</li>
</ul>
</li>
<li>数组<ul>
<li>查询速度快:查询数据通过地址值和索引定位，查询任意数据耗时相同。(元素 在内存中是连续存储的)</li>
<li>删除效率低:要将原始数据删除，同时后面每个数据前移。</li>
<li>添加效率极低:添加位置后的每个数据后移，再添加元素。</li>
</ul>
</li>
<li>链表<ul>
<li>链表中的元素是在内存中不连续存储的，每个元素节点包含数据值和下一个元素的地址。</li>
<li>链表查询慢。无论查询哪个数据都要从头开始找</li>
<li>链表增删相对快</li>
</ul>
</li>
</ol>
<h2 id="6-二叉树"><a href="#6-二叉树" class="headerlink" title="6.二叉树"></a>6.二叉树</h2><p><img src="javaSe.assets/%E4%BA%8C%E5%8F%89%E6%A0%91-164903521838945.png"></p>
<p><img src="javaSe.assets/%E6%A0%B9%E8%8A%82%E7%82%B9-164903521018844.png"></p>
<ul>
<li>只能有一个根节点，每个节点最多支持2个直接子节点。</li>
<li>节点的度:<ul>
<li>节点拥有的子树的个数,二_叉树的度不大于2叶子节点度为0的节点，也称之为终端结点。</li>
</ul>
</li>
<li>高度:<ul>
<li>叶子结点的高度为1，叶子结点的父节点高度为2,以此类推，根节点的高度最高。</li>
</ul>
</li>
<li>层:<ul>
<li>根节点在第一层， 以此类推</li>
</ul>
</li>
<li>兄弟节点:<ul>
<li>拥有共同父节点的节点互称为兄弟节点</li>
</ul>
</li>
</ul>
<p><img src="javaSe.assets/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91-164903520018343.png"></p>
<ul>
<li>二叉查找树又称二叉排序树或者二叉搜索树。</li>
<li>特点:<ol>
<li>每一个节点上最多有两个子节点</li>
<li>左子树.上所有节点的值都小于根节点的值</li>
<li>右子树.上所有节点的值都大于根节点的值</li>
</ol>
</li>
<li>目的:<ul>
<li>提高检索数据的性能。</li>
</ul>
</li>
</ul>
<h3 id="7-平衡二叉树"><a href="#7-平衡二叉树" class="headerlink" title="7.平衡二叉树"></a>7.平衡二叉树</h3><p>平衡二叉树是在满足查找二叉树的大小规则下，让树尽可能矮小，以此提高查数据的性能。</p>
<p>要求</p>
<ul>
<li>任意节点的左右两个子树的高度差不超过1,任意节点的左右两个子树都是一 颗平衡二叉树</li>
</ul>
<p>平衡二叉树在添加元素后可能导致不平衡</p>
<ul>
<li>基本策略是进行左旋，或者右旋保证平衡。</li>
<li>平衡二叉树-旋转的四种情况<ul>
<li>左左<ul>
<li>当根节点左子树的左子树有节点插入，导致二叉树不平衡</li>
<li>左旋</li>
</ul>
</li>
<li>左右<ul>
<li>当根节点左子树的右子树有节点插入，导致二叉树不平衡</li>
<li>先左旋在右旋</li>
</ul>
</li>
<li>右右<ul>
<li>当根节点右子树的右子树有节点插入，导致二叉树不平衡<ul>
<li>右旋</li>
</ul>
</li>
</ul>
</li>
<li>右左<ul>
<li>当根节点右子树的左子树有节点插入，导致二叉树不平衡</li>
<li>先右旋在左旋</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-红黑树"><a href="#7-红黑树" class="headerlink" title="7.红黑树"></a>7.红黑树</h2><p>概述</p>
<ul>
<li>红黑树是一-种自平衡的二叉查找树，是计算机科学中用到的一-种数据结构。</li>
<li>1972年出现，当时被称之为平衡二叉B树。1978年被修改为如今的”红黑树”。</li>
<li>每一个节点可以是红或者黑;红黑树不是通过高度平衡的，它的平衡是通过“红黑规则”进行实现的。</li>
</ul>
<p><img src="javaSe.assets/%E7%BA%A2%E9%BB%91%E6%A0%91-164903518750942.png"></p>
<p>规则</p>
<ul>
<li>每一个节点或是红色的，或者是黑色的，根节点必须是黑色。</li>
<li>如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,叶节点是黑色的。</li>
<li>如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连的情况)。</li>
<li>对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点。</li>
</ul>
<p>添加节点</p>
<ul>
<li>添加的节点的颜色，可以是红色的，也可以是黑色的。</li>
<li>默认用红色效率高。</li>
</ul>
<h1 id="List系列集合"><a href="#List系列集合" class="headerlink" title="List系列集合"></a>List系列集合</h1><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h2><ul>
<li>ArrayList、LinekdList :有序，可重复,有索引</li>
<li>有序:存储和取出的元素顺序一致</li>
<li>有索引:可以通过索引操作元素</li>
<li>可重复:存储的元素可以重复.</li>
</ul>
<p>特有方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index, E element)</td>
<td>在此集合中的指定位置插入指定的元素</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>删除指定索引</td>
</tr>
<tr>
<td>E set(int index,E element )</td>
<td>修改指定索引</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>返回指定索引处的元素</td>
</tr>
</tbody></table>
<h2 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h2><ul>
<li>迭代</li>
<li>增强for循环</li>
<li>Lambda表达式</li>
<li>for循环( 因为List集合存在索引)</li>
</ul>
<h2 id="3-底层原理"><a href="#3-底层原理" class="headerlink" title="3. 底层原理"></a>3. 底层原理</h2><ul>
<li>ArrayList底层是基 于数组实现的:根据索引定位元素快,增删需要做元素的移位操作。</li>
<li>第一次创建集合并添加第一 个元素的时候, 在底层创建一个默认长度为10的数组。</li>
</ul>
<h2 id="4-LinkList"><a href="#4-LinkList" class="headerlink" title="4.LinkList"></a>4.LinkList</h2><p>特点</p>
<ul>
<li>底层数据结构是双链表,查询慢，首尾操作的速度是极快的,所以多了很多首尾操作的特有APl。</li>
</ul>
<p>特有功能</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void addFirst(E e)</td>
<td>在该列表开头插入指定的元素</td>
</tr>
<tr>
<td>public void addLast(E e)</td>
<td>将指定的元素追加到 此列表的末尾</td>
</tr>
<tr>
<td>public E getFirst()</td>
<td>返回此列表中的第-个元素</td>
</tr>
<tr>
<td>public E getLast()</td>
<td>返回此列表中的最后一个元素</td>
</tr>
<tr>
<td>public E removeFirst()</td>
<td>从此列表中删除并返回第一个元素</td>
</tr>
<tr>
<td>public E removeLast( )</td>
<td>从此列表中删除并返回最后-个元素</td>
</tr>
</tbody></table>
<h2 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5.泛型"></a>5.泛型</h2><p>概述</p>
<ul>
<li>泛型:是JDK5中引入的特性，可以在编译阶段约束操作的数据类型,并进行检查。</li>
<li>泛型的格式: &lt;数据类型&gt;;注意:泛型只能支持引用数据类型。</li>
<li>集合体系的全部接口和实现类都是支持泛型的使用的。</li>
</ul>
<p>好处</p>
<ul>
<li>统一数据类型</li>
<li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。</li>
</ul>
<h3 id="5-1-泛型类"><a href="#5-1-泛型类" class="headerlink" title="5.1 泛型类"></a>5.1 泛型类</h3><ul>
<li>定义类时同时定义了泛型的类就是泛型类。</li>
<li>泛型类的格式:修饰符class类名&lt;泛型变量&gt;{ }</li>
<li>此处泛型变量T可以随便写为任意标识，常见的如E、T、K、V等。</li>
</ul>
<h3 id="5-2-泛型方法"><a href="#5-2-泛型方法" class="headerlink" title="5.2 泛型方法"></a>5.2 泛型方法</h3><p>概述</p>
<ul>
<li>定义方法时同时定义了泛型的方法就是泛型方法。</li>
<li>泛型方法的格式:修饰符&lt;泛型变量&gt;方法返回值方法名称(形参列表){}</li>
</ul>
<p>作用</p>
<ul>
<li>方法中可以使用泛型接收-切实际类型的参数，方法更具备通用性。</li>
</ul>
<p>泛型方法的原理:</p>
<ul>
<li>把出现泛型变量的地方全部替换成传输的真实数据类型</li>
</ul>
<h3 id="5-3-泛型接口"><a href="#5-3-泛型接口" class="headerlink" title="5.3 泛型接口"></a>5.3 泛型接口</h3><p>概述</p>
<ul>
<li>使用了泛型定义的接口就是泛型接口。</li>
<li>泛型接口的格式:修饰符interface接口名称&lt;泛型变量&gt;{}</li>
</ul>
<p>泛型接口的原理:</p>
<ul>
<li>实现类可以在实现接口的时候传入自己操作的数据类型，这样重写的方法都将是针对于该类型的操作。</li>
</ul>
<h3 id="5-4泛型通配符"><a href="#5-4泛型通配符" class="headerlink" title="5.4泛型通配符"></a>5.4泛型通配符</h3><ul>
<li>?可以在“使用泛型”的时候代表一切类型。</li>
<li>ET K V是在定义泛型的时候使用的。</li>
</ul>
<h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><p>特点</p>
<ul>
<li>无序:存取顺序不一致</li>
<li>不重复:可以去除重复</li>
<li>无索引:没有带索引的方法,所以不能使用普通for循环遍历，也不能通过索引来获取元素。</li>
</ul>
<p>实现类特点</p>
<ul>
<li>HashSet:无序、不重复、无索引。</li>
<li>LinkedHashSet:有序、不重复、无索引。</li>
<li>TreeSet:排序、不重复、无索引。</li>
</ul>
<p>HashSet底层原理</p>
<ul>
<li>HashSet集合底层采取哈希表存储的数据。</li>
<li>哈希表是一种对于增删改查数据性能都较好的结构。</li>
</ul>
<p>哈希表的组成</p>
<ul>
<li>JDK8之前的，底层使用数组+链表组成</li>
<li>JDK8开始后，底层采用数组+链表+红黑树组成。</li>
</ul>
<h2 id="1-哈希值"><a href="#1-哈希值" class="headerlink" title="1.哈希值"></a>1.哈希值</h2><ul>
<li>是JDK根据对象的地址，按照某种规则算出来的int类型的数值。</li>
</ul>
<p>Object类的API</p>
<ul>
<li>public int hashCode():返回对象的哈希值</li>
</ul>
<p>对象的哈希值特点</p>
<ul>
<li>同一个对象多次调用hashCode()方法返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的。</li>
</ul>
<p>HashSet1.7版本原理解析:数组+链表+ (结合哈希算法)</p>
<ol>
<li>创建一个默认长度1 6的数组，数组名table</li>
<li>根据元素的哈希值跟数组的长度求余计算出应存入的位置( 哈希算法)</li>
<li>判断当前位置是否为null,如果是null直接存入</li>
<li>如果位置不为null,表示有元素，则调用equals方法比较</li>
<li>如果一样，则不存，如果不一-样，则存入数组<ul>
<li>JDK 7新元素占老元素位置，指向老元素</li>
<li>JDK 8中新元素挂在老元素下面</li>
</ul>
</li>
</ol>
<ul>
<li>结论:哈希表是一种对于增删改查数据性能都较好的结构。</li>
</ul>
<p>JDK1.8版本开始HashSet原理解析</p>
<ul>
<li>底层结构:哈希表(数组、链表、红黑树的结合体)</li>
<li>当挂在元素下面的数据过多时，查询性能降低,从DK8开始后，当链表长度超过8的时候，自动转换为红黑树。</li>
<li>结论: JDK8开始后，哈希表对于红黑树的引入进一-步提高了操作数据的性能。</li>
</ul>
<p>HashSet元素去重复的底层原理</p>
<ul>
<li>结论:如果希望Set集合认为2个内容一样的对象是重复的,<br>必须重写对象的hashCode()和equals()方法</li>
</ul>
<h2 id="2-LinkedHashSet集合"><a href="#2-LinkedHashSet集合" class="headerlink" title="2.LinkedHashSet集合"></a>2.LinkedHashSet集合</h2><p>概述</p>
<ul>
<li>有序、不重复、无索引。</li>
<li>这里的有序指的是保证存储和取出的元素顺序一致</li>
<li>原理:<ul>
<li>底层数据结构是依然哈希表，只是每个元素又额外的多了- -个双链表的机制记录存储的顺序。</li>
</ul>
</li>
</ul>
<h2 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3. TreeSet"></a>3. TreeSet</h2><p>概述</p>
<ul>
<li>不重复、无索引、可排序</li>
<li>可排序:按照元素的大小默认升序(有小到大)排序。</li>
<li>TreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好。</li>
<li>注意: TreeSet集合是一定要排序的，可以将元素按照指定的规则进行排序。</li>
</ul>
<p>TreeSet集合默认的规则</p>
<ul>
<li>对于数值类型: Integer , Double,官方默认按照大小进行升序排序。</li>
<li>对于字符串类型: 默认按照首字符的编号升序排序。</li>
<li>对于自定义类型如Student对象，TreeSet无法直接排序。</li>
<li>结论:<ul>
<li>想要使用TreeSet存储自定义类型，需要制定排序规则</li>
</ul>
</li>
<li>自定义排序规则<ul>
<li>TreeSet集合存储对象的的时候有2种方式可以设计自定义比较规则<ol>
<li>让自定义的类 (如学生类)实现Comparable接口重写里面的compareTo方法来定制比较规则。</li>
<li>TreeSet集合有参数构造器，可以设置Comparator接口对应的比较器对象，来定制比较规则。</li>
</ol>
</li>
<li>两种方式中，关于返回值的规则:<ol>
<li>如果认为第一个元素大于 第二个元素返回正整数即可。</li>
<li>如果认为第一个元素小于第二个元素返回负 整数即可。</li>
<li>如果认为第一个元素等于第二个元素返回0即可，此时Treeset集合只会保留一-个元素，认为两者重复。</li>
<li>注意:如果TreeSet集合存储的对象有实现比较规则，集合也自带比较器，默认使用集合自带的比较器排序。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="4.可变参数"></a>4.可变参数</h2><ul>
<li><p>可变参数用在形参中可以接收多个数据。</p>
</li>
<li><p>可变参数的格式: 数据类型…参数名称</p>
</li>
<li><p>可变参数的作用</p>
<ul>
<li>传输参数非常灵活，方便。可以不传输参数，可以传输1个或者多个，也可以传输一个数组</li>
</ul>
</li>
<li><p>可变参数在方法内部本质上就是一个数组。</p>
</li>
<li><p>可变参数的注意事项:</p>
<ol>
<li>一个形参列表中可变参数只能有一个</li>
<li>可变参数必须放在形参 列表的最后面</li>
</ol>
</li>
</ul>
<h2 id="5-集合工具类"><a href="#5-集合工具类" class="headerlink" title="5.集合工具类"></a>5.集合工具类</h2><p>Collections排序相关API</p>
<ul>
<li>使用范围:只能对于List集合的排序。</li>
</ul>
<ol>
<li><p>排序方式1</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> void sort(List<T> list)</td>
<td>将集合中元素按照默认规则排序</td>
</tr>
</tbody></table>
<ul>
<li>注意:本方式不可以直接对自定义类型的List集合排序，除非自定义类型实现了比较规则Comparable接口。</li>
</ul>
</li>
<li><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> void sort(List<T> list, Comparator&lt;? super T&gt; c)</td>
<td>将集合中元素按照<br>指定规则排序</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="Map集合体系"><a href="#Map集合体系" class="headerlink" title="Map集合体系"></a>Map集合体系</h1><h2 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>Map集合是一种双列集合,每个元素包含两个数据。</li>
<li>Map集合的每个元素的格式: key=value(键值对元素)。</li>
<li>Map集合也被称为“键值对集合</li>
</ul>
<p>Map集合整体格式:</p>
<ul>
<li>Collection集合的格式: [元素1,元素2,元素3..] </li>
<li>Map集合的完整格式: {key1=value1 , key2=value2 , key3=value3 …}</li>
</ul>
<h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h2><p>说明</p>
<ul>
<li>使用最多的Map集合是HashMap。</li>
</ul>
<p>Map集合体系特点</p>
<ul>
<li>Map集 合的特点都是由键决定的。</li>
<li>Map集合的键是无序,不重复的， 无索引的，值不做要求( 可以重复)。</li>
<li>Map集合后面重复的键对应的值会覆盖前面重复键的值。</li>
<li>Map集 合的键值对都可以为null。</li>
</ul>
<p>Map集合实现类特点</p>
<ul>
<li>HashMap:元素按照键是无序， 不重复，无索引，值不做要求。( 与Map体系一致)</li>
<li>LinkedHashMap:元素按照键是有序，不重复,无索引，值不做要求。</li>
<li>TreeMap:元素按照建是排序，不重复，无索引的,值不做要求。</li>
</ul>
<h2 id="3-常用API-1"><a href="#3-常用API-1" class="headerlink" title="3.常用API"></a>3.常用API</h2><ul>
<li>Map是双列集合的祖宗接口，它的功能是全部双列集合都可以继承使用的。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V put(K key,V value)</td>
<td>添加元素</td>
</tr>
<tr>
<td>V remove (0bject key)</td>
<td>根据键删除键值对元素</td>
</tr>
<tr>
<td>clear()</td>
<td>移除所有的键值对元素</td>
</tr>
<tr>
<td>boolean containsKey(0bject key)</td>
<td>判断集合是否包含指定的键</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断集合是否包含指定的值</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td>集合的长度，也就是集合中键值对的个数</td>
</tr>
<tr>
<td>public V get(object key)</td>
<td>根据键取得对应值</td>
</tr>
<tr>
<td>public Set<K> keySet()</td>
<td>获取键的集合</td>
</tr>
<tr>
<td>Collection<V> values();</td>
<td>获取值的集合</td>
</tr>
</tbody></table>
<h2 id="4-遍历-1"><a href="#4-遍历-1" class="headerlink" title="4.遍历"></a>4.遍历</h2><h3 id="4-1键找值"><a href="#4-1键找值" class="headerlink" title="4.1键找值"></a>4.1键找值</h3><ul>
<li>先获取Map集合的全部键的Set集合。</li>
<li>遍历键的Set集合，然后通过键提取对应值。</li>
</ul>
<h3 id="4-2键值对"><a href="#4-2键值对" class="headerlink" title="4.2键值对"></a>4.2键值对</h3><ul>
<li><p>先把Map集合转换成Set集合, liSet集合中每个元素都是键值对实体类型了。</p>
</li>
<li><p>遍历Set集合，然后提取键以及提取值。</p>
</li>
<li><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>
<td>获取所有键值对对象的集合</td>
</tr>
<tr>
<td>K getKey()</td>
<td>获得键</td>
</tr>
<tr>
<td>V getValue()</td>
<td>获取值</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4-3Lambda遍历"><a href="#4-3Lambda遍历" class="headerlink" title="4.3Lambda遍历"></a>4.3Lambda遍历</h3><ul>
<li>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</li>
</ul>
<p>API</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>default void forEach( BiConsumer&lt;? super K，? super V&gt; action)</td>
<td>结合lambda遍历Map集合</td>
</tr>
</tbody></table>
<h2 id="5-TreeMap"><a href="#5-TreeMap" class="headerlink" title="5.TreeMap"></a>5.TreeMap</h2><p>概述和特点</p>
<ul>
<li>由键决定特性:不重复、无索引、可排序</li>
<li>可排序:按照键数据的大小默认升序(有小到大)排序。只能对键排序。</li>
<li>注意: TreeMap集合是一定要排序的，可以默认排序，也可以将键按照指定的规则进行排序</li>
</ul>
<h1 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h1><p>概述</p>
<ul>
<li>不可变集合，就是不可被修改的集合。</li>
<li>集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错。</li>
</ul>
<p>为什么要创建不可变集合?</p>
<ul>
<li>如果某个数据不能被修改,把它防御性地拷贝到不可变集合中是个很好的实践。</li>
<li>或者当集合对象被不可信的库调用时，不可变形式是安全的。</li>
</ul>
<p>如何创建不可变集合?</p>
<ul>
<li>在List、 Set、Map接口中，都存在of方法，可以创建- -个不可变的集合。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static <E> Set<E> of.(E..elements)</td>
<td>创建一个具有指定元素的Set集合对象</td>
</tr>
<tr>
<td>static &lt;K,V&gt; Map&lt;K, V&gt; of.(E lements)</td>
<td>创建一个具有指定元素的Map集合对象</td>
</tr>
<tr>
<td>static <E> List<E> of.(E elements)</td>
<td>创建一个具有指定元素的List集合对象</td>
</tr>
</tbody></table>
<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><h2 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream流 概念。</li>
<li>目的:<ul>
<li>用于简化集合和数组操作的API。</li>
</ul>
</li>
</ul>
<p>思想</p>
<ol>
<li>先得到集合或者数组的Stream流(就是一根传送带)。</li>
<li>把元素放上去。</li>
<li>然后就用这个Stream流简化的API来方便的操作元素。</li>
</ol>
<h2 id="2-Stream流的三类方法"><a href="#2-Stream流的三类方法" class="headerlink" title="2.Stream流的三类方法"></a>2.Stream流的三类方法</h2><ul>
<li><p>获取Stream流</p>
<ul>
<li><p>创建一条流水线， 并把数据放到流水线上准备进行操作</p>
</li>
<li><p>集合</p>
<ul>
<li>可以使用Collection接口中的默认方法stream()生成流</li>
<li><code>default Stream&lt;E&gt; stream()</code></li>
</ul>
</li>
<li><p>数组</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> Stream<T> stream(T[] array)</td>
<td>获取当前数组的Stream流</td>
</tr>
<tr>
<td>public static<T> Stream<T> of(T… values)</td>
<td>获取当前数组/可变数据的Stream流</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>中间方法</p>
<ul>
<li>流水线上的操作。 一次操作完毕之后，还可以继续进行其他操作。</li>
</ul>
</li>
<li><p>终结方法</p>
<ul>
<li>一个Stream流只能有- -个终结方法,是流水线上的最后一个操作</li>
</ul>
</li>
</ul>
<h2 id="3-常用API-2"><a href="#3-常用API-2" class="headerlink" title="3.常用API"></a>3.常用API</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Stream<T> filter<br>(Predicate&lt;? super T&gt; predicate)</td>
<td>用于对流中的数据进行过滤。</td>
</tr>
<tr>
<td>Stream<T> limit(1ong maxSize)</td>
<td>获取前几个元素</td>
</tr>
<tr>
<td>Stream<T> skip(long n)</td>
<td>跳过前几个元素</td>
</tr>
<tr>
<td>Stream<T> distinct()</td>
<td>去除流中重复的元素。依赖(hashCode和equals方法)</td>
</tr>
<tr>
<td>static <T> Stream<T> concat<br>(Stream a, Stream b)</td>
<td>合并a和b两个流为一个流</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>中间方法也称为非终结方法，调用完成后返回新的Stream流可以继续使用，支持链式编程。</li>
<li>在Stream流中无法直接修改集合、数组中的数据。</li>
</ul>
<h2 id="4-收集Stream流"><a href="#4-收集Stream流" class="headerlink" title="4.收集Stream流"></a>4.收集Stream流</h2><ul>
<li>收集Stream流的含义:就是把Stream流操作后的结果数据转回到集合或者数组中去。</li>
<li>Stream流: 方便操作集合/数组的手段。</li>
</ul>
<p>方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>R collect(Collector collector)</td>
<td>开始收集Stream流，指定收集器</td>
</tr>
<tr>
<td>pub1ic static <T> Collector toList()</td>
<td>把元素收集到List集合中</td>
</tr>
<tr>
<td>public static <T> Collector toSet()</td>
<td>把元素收集到Set集合中</td>
</tr>
<tr>
<td>public static Col1ector toMap(Function keyMapper ，Function valueMapper)</td>
<td>把元素收集到Map集合中</td>
</tr>
</tbody></table>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>异常是程序在“编译”或者”执行”的过程中可能出现的问题，注意:语法错误不算在异常体系中。</li>
<li>比如:数组索引越界、空指针异常、 日期格式化异常，等…</li>
<li>异常一旦出现了，如果没有提前处理,程序就会退出JVM虚拟机而终止</li>
<li>研究异常并且避免异常，然后提前处理异常，体现的是程序的安全，健壮性。</li>
</ul>
<p>体系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(Throwable)===&gt;B(Error)</span><br><span class="line">A==&gt;C(Exception)</span><br><span class="line">C==&gt;D(RuntimeException及其子类)</span><br><span class="line">C==&gt;E(除RuntimeException之外的所有异常)</span><br></pre></td></tr></table></figure>

<p>Error:</p>
<ul>
<li>系统级别问题、JVM退出等,</li>
<li>代码无法控制。</li>
</ul>
<p>Exception:</p>
<ul>
<li> java.lang包下， 称为异常类,它表示程序本身可以处理的问题</li>
<li>RuntimeException及其子类:运行时异常,编译阶段不会报错。(空指针异常, 数组索引越界异常)</li>
<li>除RuntimeException之外所有的异常:编译时异常，编译期必须处理的，否则程序不能通过编译。(日 期格式化异常)。</li>
</ul>
<p>总结</p>
<ul>
<li>编译时异常就是在编译的时候出现的异常</li>
<li>运行时异常就是在运行时出现的异常。</li>
</ul>
<h2 id="2-运行时异常"><a href="#2-运行时异常" class="headerlink" title="2.运行时异常"></a>2.运行时异常</h2><ul>
<li>直接继承自RuntimeException或者其子类,编译阶段不会报错,运行时可能出现的错误。</li>
<li>般是程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误，</li>
</ul>
<p>示例</p>
<ul>
<li>数组索引越界异常: ArrayIndexOutOfBoundsException</li>
<li>空指针异常: NullPointerException,直接输出没有问题，但是调用空指针的变量的功能就会报错。</li>
<li>数学操作异常: ArithmeticException</li>
<li>类型转换异常: ClassCastException</li>
<li>数字转换异常: NumberFormatException</li>
</ul>
<h2 id="3-编译时异常"><a href="#3-编译时异常" class="headerlink" title="3.编译时异常"></a>3.编译时异常</h2><ul>
<li>不是RuntimeException或者其子类的异常，编译阶就报错，必须处理，否则代码不通过。</li>
</ul>
<p>作用</p>
<ul>
<li>是担心程序员的技术不行，在编译阶段就爆出一个错误,目的在于提醒不要出错!</li>
<li>编译时异常是可遇不可求。遇到了就遇到了呗。</li>
</ul>
<h2 id="4-异常处理流程"><a href="#4-异常处理流程" class="headerlink" title="4.异常处理流程"></a>4.异常处理流程</h2><h3 id="4-1默认处理流程"><a href="#4-1默认处理流程" class="headerlink" title="4.1默认处理流程"></a>4.1默认处理流程</h3><ol>
<li>默认会在出现异常的代码那里自动的创建一一个 异常对象: ArithmeticException。</li>
<li>异常会从方法中出现的点这里拋出给调用者，调用者最终抛出给JVM虚拟机。</li>
<li>虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。</li>
<li>直接从当前执行的异常点干掉当前程序。</li>
<li>后续代码没有机会执行了，因为程序已经死亡。</li>
</ol>
<h3 id="4-2-编译时异常处理"><a href="#4-2-编译时异常处理" class="headerlink" title="4.2 编译时异常处理"></a>4.2 编译时异常处理</h3><ul>
<li>出现异常直接抛出去给调用者，调用者也继续抛出去。</li>
<li>出现异常自己捕获处理，不麻烦别人。</li>
<li>前两者结合，出现异常直接抛出去给调用者,调用者捕获处理。</li>
</ul>
<ol>
<li><p>throws</p>
<ul>
<li><p>throws:用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。</p>
</li>
<li><p>这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。</p>
</li>
<li><p>抛出异常格式</p>
<p><code>方法throws异常1，异常2，异常3 ..&#123;&#125;</code></p>
</li>
<li><p>规范做法</p>
<p><code>方法throws Exception&#123;&#125;</code></p>
</li>
</ul>
</li>
<li><p>try…catch…</p>
<ul>
<li><p>监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。</p>
</li>
<li><p>这种方式还可以，发生异常的方法自己独立完成异常的处理,程序可以继续往下执行。</p>
</li>
<li><p>建议格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 可能出现异常的代码!</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace(); <span class="comment">// 直接打印异常栈信息</span></span><br><span class="line">&#125;</span><br><span class="line">Exception<span class="string">&#x27;可以捕获处理一切异常类型!</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>前两者结合</p>
<ul>
<li>方法直接将异通过throws抛出去给调用者</li>
<li>调用者收到异常后直接捕获处理。</li>
</ul>
</li>
</ol>
<h3 id="4-3运行时异常处理方式"><a href="#4-3运行时异常处理方式" class="headerlink" title="4.3运行时异常处理方式"></a>4.3运行时异常处理方式</h3><ul>
<li>运行时异常编译阶段不会出错，是运行时才可能出错的，所以编译阶段不处理也可以。</li>
<li>按照规范建议还是处理:建议在最外层调用处集中捕获处理即可。</li>
</ul>
<h2 id="5-自定义异常"><a href="#5-自定义异常" class="headerlink" title="5.自定义异常"></a>5.自定义异常</h2><ul>
<li>Java无法为这个世界上全部的问题提供异常类。</li>
<li>如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了。</li>
</ul>
<p>好处：</p>
<ul>
<li>可以使用异常的机制管理业务问题，如提醒程序员注意。</li>
<li>同时一旦出现bug，可以用异常的形式清晰的指出出错的地方。</li>
</ul>
<ol>
<li>自定义编译时异常<ul>
<li>定义一个异常类继承Exception.</li>
<li>重写构造器。</li>
<li>在出现异常的地方用throw new自定义对象抛出。</li>
<li>作用:编译时异常是编译阶段就报错，提醒更加强烈，-定需要处理! !</li>
</ul>
</li>
<li>自定义运行时异常<ul>
<li>定义一个异常类继承RuntimeException.</li>
<li>重写构造器。</li>
<li>在出现异常的地方用throw new自定义对象抛出!</li>
<li>作用:提醒不强烈,编译阶段不报错! !运行时才可能出现!</li>
</ul>
</li>
</ol>
<h1 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h1><h2 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1.概述"></a>1.概述</h2><p>输出语句的弊端</p>
<ul>
<li>信息只能展示在控制台</li>
<li>不能将其记录到其他的位置(文件,数据库)</li>
<li>想取消记录的信息需要修改代码才可以完成</li>
</ul>
<p>日志技术具备的优势</p>
<ul>
<li>可以将系统执行的信息选择性的记录到指定的位置(控制台、文件中、数据库中)。</li>
<li>可以随时以开关的形式控制是否记录日志，无需修改源代码。</li>
</ul>
<p>优势</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">输出语句</th>
<th align="center">日志技术</th>
</tr>
</thead>
<tbody><tr>
<td>输出位置</td>
<td align="center">只能是控制台</td>
<td align="center">可以将日志信息写入到文件或者数据库中</td>
</tr>
<tr>
<td>取消日志</td>
<td align="center">需要修改代码，灵活性比较差</td>
<td align="center">不需要修改代码，灵活性比较好</td>
</tr>
<tr>
<td>多线程</td>
<td align="center">性能较差</td>
<td align="center">性能较好</td>
</tr>
</tbody></table>
<h2 id="2-体系"><a href="#2-体系" class="headerlink" title="2.体系"></a>2.体系</h2><p>日志规范接口</p>
<ul>
<li>Commons Logging    简称JCL<ul>
<li>Simple Logging Facade for Java    简称：slf4j</li>
</ul>
</li>
</ul>
<p>日志规范:</p>
<ul>
<li>一些接口，提供给日志的实现框架设计的标准。</li>
</ul>
<p>日志框架:</p>
<ul>
<li>牛人或者第三方公司已经做好的日志记录实现代码，后来者直接可以拿去使用。</li>
<li>Log4j</li>
<li>JUL</li>
<li>(java . util .loggiing)</li>
<li>Logback</li>
<li>其他实现</li>
</ul>
<p>因为对Commons Logging的接口不满意，有人就搞了SLF4。因为对Log4j的性能不满意,有人就搞了Logback。</p>
<h2 id="3-logback概述"><a href="#3-logback概述" class="headerlink" title="3.logback概述"></a>3.logback概述</h2><p>Logback是由log4j创始人设计的另-一个开源日志组件，性能比log4j要好</p>
<p>Logback是基于slf4j的日志规范实现的框架。</p>
<p>Logback主要分为三个技术模块:</p>
<ul>
<li>logback-core: logback-core 模块为其他两个模块奠定了基础，必须有。</li>
<li>logback-classic: 它是log4j的-个改良版本，同时它完整实现了”slf4j API。</li>
<li>logback-access 模块与Tomcat和Jetty等Servlet容器集成，以提供HTTP访问日志功能</li>
</ul>
<h2 id="4-入门"><a href="#4-入门" class="headerlink" title="4.入门"></a>4.入门</h2><p>需求:导入Logback日志技术到项目中,用于纪录系统的日志信息<br>分析:</p>
<ol>
<li><p>在项目下新建文件夹lib,导入Logback的相关jar包到该文件夹下，并添加到项目依赖库中去。</p>
</li>
<li><p>将Logback的核心配置文件logback.xml直接拷贝到src目录下(必须是src下)。</p>
</li>
<li><p>在代码中获取日志的对象</p>
<p><code>public static final Logger LOGGER = LoggerFactory. getLogge(&quot;类对象&quot;);</code></p>
</li>
</ol>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="1-概述-7"><a href="#1-概述-7" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>File类在包java.io.File下、代表操作系统的文件对象(文件、文件夹)。</li>
<li>File类提供了诸如:定位文件,获取文件本身的信息、删除文件、创建文件(文件夹)等功能。</li>
</ul>
<p>创建对象</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public File(String pathname )</td>
<td>根据文件路径创建文件对象</td>
</tr>
<tr>
<td>public File(String parent, String child)</td>
<td>从父路径名字符串和子路径名字符串创建文件对象</td>
</tr>
<tr>
<td>public File(File parent, String child)</td>
<td>根据父路径对应文件对象和子路径名字符串创建文件对象</td>
</tr>
</tbody></table>
<ul>
<li>File对象可以定位文件和文件夹</li>
<li>File封装的对象仅仅是一个路径名，这个路径可以是存在的，也可以是不存在的。</li>
</ul>
<p>绝对路径和相对路径</p>
<ul>
<li><p>绝对路径:从盘符开始</p>
<p><code>File file1 = new File(&quot;D: \\itheima\la.txt&quot;);</code></p>
</li>
<li><p>相对路径:不带盘符，默认直接到src下的目录寻找文件。</p>
<p><code>File file3 = new File(&quot;src\a.txt&quot;);</code></p>
</li>
</ul>
<p>​    </p>
<h2 id="2-常用API-1"><a href="#2-常用API-1" class="headerlink" title="2.常用API"></a>2.常用API</h2><h3 id="2-1判断文件类型、获取文件信息"><a href="#2-1判断文件类型、获取文件信息" class="headerlink" title="2.1判断文件类型、获取文件信息"></a>2.1<strong>判断文件类型、获取文件信息</strong></h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean isDirectory() t</td>
<td>测试此抽象路径名表示的File是否为文件夹</td>
</tr>
<tr>
<td>public boolean isFile()</td>
<td>测试此抽象路径名表示的File是否为文件</td>
</tr>
<tr>
<td>public boolean exists()</td>
<td>测试此抽象路径名表示的F ile是否存在</td>
</tr>
<tr>
<td>public String getAbsolutePath()</td>
<td>返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>将此抽象路径名转换为路径名字符串</td>
</tr>
<tr>
<td>public String getName()</td>
<td>返回由此抽象路径名表示的文件或文件夹的名称</td>
</tr>
<tr>
<td>public long lastModified()</td>
<td>返回文件最后修改的时间毫秒值</td>
</tr>
</tbody></table>
<h3 id="2-2创建文件、删除文件"><a href="#2-2创建文件、删除文件" class="headerlink" title="2.2创建文件、删除文件"></a>2.2创建文件、删除文件</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean createNewFile( )</td>
<td>创建-一个新的空的文件</td>
</tr>
<tr>
<td>public boolean mkdir()</td>
<td>只能创建一级文件夹</td>
</tr>
<tr>
<td>public boolean mkdirs( )</td>
<td>可以创建多级文件夹</td>
</tr>
<tr>
<td>public boolean delete()</td>
<td>删除由此抽象路径名表示的文件或空文件夹</td>
</tr>
</tbody></table>
<ul>
<li>delete方法直接删除不走回收站;如果删除的是-一个文件，且文件没有被占用则直接删除。</li>
<li>delete方法默认只能删除空文件夹。</li>
</ul>
<h3 id="2-3遍历文件夹"><a href="#2-3遍历文件夹" class="headerlink" title="2.3遍历文件夹"></a>2.3遍历文件夹</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String[] list()</td>
<td>获取当前目录下所有的”一-级文件名称”到一个字符串数组中去返回。</td>
</tr>
<tr>
<td>public File[] listFiles()(常用)</td>
<td>获取当前目录 下所有的”- -级文件对象”<br>到一个文件对象数组中去返回(重点)</td>
</tr>
</tbody></table>
<p>listFiles方法注意事项:</p>
<ul>
<li>当调用者不存在时，返回null</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>什么是方法递归?</p>
<ul>
<li>方法直接调用自己或者间接调用自己的形式称为方法递归( recursion)。</li>
<li>递归做为一种算法在程序设计语言中广泛应用。</li>
</ul>
<p>递归的形式</p>
<ul>
<li>直接递归:方法自己调用自己。</li>
<li>间接递归:方法调用其他方法，其他方法又回调方法自己。</li>
</ul>
<p>方法递归存在的问题?</p>
<ul>
<li>递归如果没有控制好终止，会出现递归死循环，导致栈内存溢出现象。</li>
</ul>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><h2 id="1-常见字符集"><a href="#1-常见字符集" class="headerlink" title="1.常见字符集"></a>1.常见字符集</h2><p>基础知识</p>
<ul>
<li>计算机底层不可以直接存储字符的。计算机中底层只能存储二进制(0、1)</li>
<li>二进制是可以转换成十进制的</li>
<li>结论:计算机底层可以表示十进制编号。计算机可以给人类字符进行编号存储，这套编号规则就是字符集。</li>
</ul>
<p>ASCII字符集:</p>
<ul>
<li>ASCII(American Standard Code for Information Interchange,美国信息交换标准代码):包括了数字、英文、符号。</li>
<li>ASCII使用1个字节存储一个字符， 一个字节是8位， 总共可以表示128个字符信息， 对于英文,数字来说是够用的。</li>
</ul>
<p>GBK:</p>
<ul>
<li>window系统默认的码表。兼容ASCII码表， 也包含了几万个汉字,并支持繁体汉字以及部分日韩文字。</li>
<li>注意: GBK是中国的码表，-个中文以两个字节的形式存储。但不包含世界上所有国家的文字。</li>
</ul>
<p>Unicode码表:</p>
<ul>
<li>unicode (又称统- -码、 万国码、单-码)是计算机科学领域里的一项业界字符编码标准。</li>
<li>容纳世界上大多数国家的所有常见文字和符号。</li>
<li>由于Unicode会先通过UTF-8，UTF-16, 以及UTF-32的编码成二进制后再存储到计算机，其中最为常见的就是UTF-8。</li>
<li>注意<ul>
<li>Unicode是万国码， 以UTF-8编码后- 一个中文- 般以三个字节的形式存储。</li>
<li>UTF-8也要兼容ASCII编码表。</li>
<li>技术人员都应该使用UTF-8的字符集编码。</li>
<li>编码前和编码后的字符集需要一致,否则会出现中文乱码。</li>
</ul>
</li>
</ul>
<h2 id="2-编码、解码"><a href="#2-编码、解码" class="headerlink" title="2.编码、解码"></a>2.编码、解码</h2><p>String编码</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>byte[] getBytes()</td>
<td>使用平台的默认字符集将该String编码为一系列字节， 将结果存储到新的字节数</td>
</tr>
<tr>
<td>byte[] getBytes(String charsetName)</td>
<td>使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中</td>
</tr>
</tbody></table>
<p>String解码</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String(byte[] bytes )</td>
<td>通过使用平台的默认字符集解码指定的字节数组来构造新的</td>
</tr>
<tr>
<td>String(byte[] bytes, <br>String charsetName)</td>
<td>通过指定的字符集解码指定的字节数组来构造新的String</td>
</tr>
</tbody></table>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="1-概述-8"><a href="#1-概述-8" class="headerlink" title="1.概述"></a>1.概述</h2><p>I0流也称为输入、输出流,就是用来读写数据的。</p>
<ul>
<li>I表示intput, 是数据从硬盘文件读入到内存的过程,称之输入,负责读。</li>
<li>0表示output, 是内存程序的数据从内存到写出到硬盘文件的过程,称之输出，负责写。</li>
</ul>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h2><ul>
<li>按流的方向<ol>
<li>输入流</li>
<li>输出流</li>
</ol>
</li>
<li>按流中的数据最小单位分为<ol>
<li>字节流</li>
<li>字符流</li>
</ol>
</li>
</ul>
<p>总结流的四大类:</p>
<ul>
<li>字节输入流: 以内存为基准,来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流称为字节输大流。</li>
<li>字节输出流:以内存为基准,把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流。</li>
<li>字符输入流:以内存为基准,来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流称为字符输入流。</li>
<li>字符输出流:以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(IO流体系)==&gt;B(字节流)</span><br><span class="line">A==&gt;C(字符流)</span><br><span class="line">B==&gt;D(InputStream)</span><br><span class="line">B==&gt;E(OutStream)</span><br><span class="line">C==&gt;F(Reader)</span><br><span class="line">C==&gt;G(Writer)</span><br><span class="line">D==&gt;H&#123;FileInputStream&#125;</span><br><span class="line">E==&gt;I&#123;FileOutputStream&#125;</span><br><span class="line">F==&gt;J&#123;FileReader&#125;</span><br><span class="line">G==&gt;K&#123;FileWriter&#125;</span><br><span class="line">L(抽象类)</span><br></pre></td></tr></table></figure>

<h3 id="2-1字节流"><a href="#2-1字节流" class="headerlink" title="2.1字节流"></a>2.1字节流</h3><h4 id="文件字节输入流-FileInputStream"><a href="#文件字节输入流-FileInputStream" class="headerlink" title="文件字节输入流: FileInputStream"></a>文件字节输入流: FileInputStream</h4><ul>
<li>作用:以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FileInputStream(File file)</td>
<td>创建字节输入流管道与源文件对象接通</td>
</tr>
<tr>
<td>public FilelnputStream(String pathname)</td>
<td>创建字节输入流管道与源文件路径接通</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int read()</td>
<td>每次读取一个字节返回，如果字节已经没有可读的返回-1</td>
</tr>
<tr>
<td>public int read(byte[] buffer)</td>
<td>每次读取一个字节数组返回，如果字节已经没有可读的返回-1</td>
</tr>
<tr>
<td>public byte[] readAllBytes()</td>
<td>直 接将当前字节输入流对应的文件对象的字节数据装到一一个字节数组返回</td>
</tr>
</tbody></table>
<h4 id="文件字节输出流-FileOutputStream"><a href="#文件字节输出流-FileOutputStream" class="headerlink" title="文件字节输出流: FileOutputStream"></a>文件字节输出流: FileOutputStream</h4><p>作用:以内存为基准，把内存中的数据以字节的形式写出到磁盘文件中去的流。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public File0utputStream(File file)</td>
<td>创建字节输出流管道与源文件对象接通</td>
</tr>
<tr>
<td>public File0utputStream(File file, boolean append)</td>
<td>创建字节输出流管道与源文件对象接通，可追加数据</td>
</tr>
<tr>
<td>public File0utputStream(String filepath)</td>
<td>创建字节输出流管道与源文件路径接通</td>
</tr>
<tr>
<td>public File0utputStream(String filepath, boolean append )</td>
<td>创建字节输出流管道与源文件路径接通，可追加数据</td>
</tr>
</tbody></table>
<p>常用API</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void write(int a)</td>
<td>写一个字节出去</td>
</tr>
<tr>
<td>public void write(byte[] buffer)</td>
<td>写一个字节数组出去</td>
</tr>
<tr>
<td>public void write(byte[] buffer ，int pos ，int len)</td>
<td>写一个字节数组的一部分出去。</td>
</tr>
</tbody></table>
<p>流的关闭与刷新</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flush()</td>
<td>刷新流，还可以继续写数据</td>
</tr>
<tr>
<td>close()</td>
<td>关闭流，释放资源，但是在关闭之前会先刷新流。- -旦关闭，就不能再写数据</td>
</tr>
</tbody></table>
<h3 id="2-2-字符流"><a href="#2-2-字符流" class="headerlink" title="2.2 字符流"></a>2.2 字符流</h3><h4 id="文件字符输入流-Reader"><a href="#文件字符输入流-Reader" class="headerlink" title="文件字符输入流: Reader"></a>文件字符输入流: Reader</h4><p>作用:以内存为基准,把磁盘文件中的数据以字符的形式读取到内存中去。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FileReader(File file)</td>
<td>创建字符输入流管道与源文件对象接通</td>
</tr>
<tr>
<td>public FileReader(String pathname)</td>
<td>创建字符输入流管道与源文件路径接通</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int rexd()</td>
<td>每次读取一个字符返回，如果字符已经没有可读的返回-1</td>
</tr>
<tr>
<td>public int read(char] buffer)</td>
<td>每次读取一个字符数组，返回读取的字符个数，如果字符已经没有可读的返回-1</td>
</tr>
</tbody></table>
<h4 id="文件字符输出流-Writer"><a href="#文件字符输出流-Writer" class="headerlink" title="文件字符输出流 Writer"></a>文件字符输出流 Writer</h4><p>作用:以内存为基准，把内存中的数据以字符的形式写出到磁盘文件中去的流。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FileWriter(File file)</td>
<td>创建字符输出流管道与源文件对象接通</td>
</tr>
<tr>
<td>public FileWriter(File file, boolean append)</td>
<td>创建字符输出流管道与源文件对象接通，可追加数据</td>
</tr>
<tr>
<td>public FileWriter(String filepath)</td>
<td>创建字符输出流管道与源文件路径接通</td>
</tr>
<tr>
<td>public FileWriter(String filepath, boolean append)</td>
<td>创建字符输出流管道与源文件路径接通，可追加数据</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int c)</td>
<td>写一个字符</td>
</tr>
<tr>
<td>void write(char[ cbuf)</td>
<td>写一个字符数组</td>
</tr>
<tr>
<td>void write(char[] cbuf, int off,int len)</td>
<td>写一个字符数组的一部分</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>写一个字符串</td>
</tr>
<tr>
<td>void write(String str,int off,int len)</td>
<td>写一个字符串的一部分</td>
</tr>
<tr>
<td>void write(int c)</td>
<td>写一个字符</td>
</tr>
</tbody></table>
<h2 id="3-缓冲流"><a href="#3-缓冲流" class="headerlink" title="3.缓冲流"></a>3.缓冲流</h2><h3 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h3><ul>
<li>缓冲流也称为高效流、或者高级流。之前学习的字节流可以称为原始流。</li>
<li>作用:缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能</li>
<li>分类<ol>
<li>字节缓冲输入流: BufferedInputStream</li>
<li>字节缓冲输出流: BufferedoutputStream</li>
<li>字符缓冲输入流: BufferedReader</li>
<li>字符缓冲输出流: BufferedWriter</li>
</ol>
</li>
</ul>
<h3 id="3-1字节缓冲流"><a href="#3-1字节缓冲流" class="headerlink" title="3.1字节缓冲流"></a>3.1字节缓冲流</h3><p>字节缓冲流性能优化原理:</p>
<ul>
<li>字节缓冲输入流自带了8KB缓冲池，以后我们直接从缓冲池读取数据，所以性能较好。</li>
<li>字节缓冲输出流自带了8KB缓冲池,数据就直接写入到缓冲池中去，写数据性能极高了。</li>
</ul>
<p>特点</p>
<ul>
<li>字节缓冲输入流: BufferedInputStream, 提高字节输入流读取数据的性能，读写功能上并无变化。</li>
<li>字节缓冲输出流: BufferedOutputStream, 提高字节输出流读取数据的性能,读写功能上并无变化。</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BufferedInputStream(InputStream is)”</td>
<td>可以把低级的字节输入流包装成一一个高级的缓冲字节输入流管道， 从而提高字节输入流读数据的性能</td>
</tr>
<tr>
<td>public BufferedOutputStream(OutputStream os)</td>
<td>public BufferedOutputStream(OutputStream os)写数据的性能</td>
</tr>
</tbody></table>
<h3 id="3-2字符缓冲流"><a href="#3-2字符缓冲流" class="headerlink" title="3.2字符缓冲流"></a>3.2字符缓冲流</h3><p>字符缓冲输入流</p>
<ul>
<li>字符缓冲输入流: BufferedReader。</li>
<li>作用:提高字符输入流读取数据的性能，除此之外多了按照行读取数据的功能。</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BufferedReader(Reader r)</td>
<td>可以把低级的字符输入流包装成一个高级的缓冲字符输入流管道，<br> 从而提高字符输入流读数据的性能</td>
</tr>
</tbody></table>
<p>字符缓冲输入流新增功能</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String readLine()</td>
<td>读取一行数据返回，如果读取没有完毕，无行可读返回null</td>
</tr>
</tbody></table>
<p>字符缓冲输出流</p>
<ul>
<li>字符缓冲输 出流: BufferedWriter。</li>
<li>作用: 提高字符输出流写取数据的性能，除此之外多了换行功能</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BufferedWriter(Writer w)</td>
<td>可以把低级的字符输出流包装成一个高级的<br>缓冲字符输出流管道,从而提高字符输出流写数据的性能</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void newLine()</td>
<td>换行操作</td>
</tr>
</tbody></table>
<h2 id="4-转换流"><a href="#4-转换流" class="headerlink" title="4.转换流"></a>4.转换流</h2><h3 id="4-1字符输入转换流"><a href="#4-1字符输入转换流" class="headerlink" title="4.1字符输入转换流"></a>4.1字符输入转换流</h3><ul>
<li>可以提取文件(GBK)的原始字节流，原始字节不会存在问题。</li>
<li>然后把字节流以指定编码转换成字符输入流，这样字符输入流中的字符就不乱码了</li>
<li>字符输入转换流: InputStreamReader, 可以把原始的字节流按照指定编码转换成字符输入流。</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public InputStreamReader(InputStream is)</td>
<td>可以把原始的字节流按照代码默认编码<br>转换成字符输入流。几乎不用，与默认的FileReader一样。</td>
</tr>
<tr>
<td>public InputStreamReader(InputStream is，String charset)</td>
<td>可以把原始的字节流按照指定编码转<br>换成字符输入流，这样字符流中的字符就不乱码了(重点)</td>
</tr>
</tbody></table>
<h3 id="4-2字符输出转换流"><a href="#4-2字符输出转换流" class="headerlink" title="4.2字符输出转换流"></a>4.2字符输出转换流</h3><table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public OutputStreamWriter(OutputStream os)</td>
<td>可以把原始的字节输出流按照代码默认编码转换成字符输出流。几乎不用。</td>
</tr>
<tr>
<td>public OutputStreamWriter(OutputStream oS, String charset)</td>
<td>可以把原始的字 节输出流按照指定编码转换成字符输出流(重点)</td>
</tr>
</tbody></table>
<h2 id="5-对象序列化"><a href="#5-对象序列化" class="headerlink" title="5.对象序列化"></a>5.对象序列化</h2><h3 id="5-1对象序列化"><a href="#5-1对象序列化" class="headerlink" title="5.1对象序列化"></a>5.1对象序列化</h3><ul>
<li>作用:以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化。</li>
<li>使用到的流是对象字节输出流: ObjectOutputStream</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ObjectOutputStream(OutputStream out)</td>
<td>把低级字节输出流包装成高级的对象字节输出流</td>
</tr>
</tbody></table>
<h3 id="5-2-对象反序列化"><a href="#5-2-对象反序列化" class="headerlink" title="5.2 对象反序列化"></a>5.2 对象反序列化</h3><ul>
<li>使用到的流是对象字节输入流: ObjectInputStream</li>
<li>作用:<ul>
<li>以内存为基准，把存储到磁盘文件中去的对象数据恢复成内存中的对象，称为对象反序列化。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ObjectInputStream( InputStream out)</td>
<td>把低级字节输如流包装成高级的对象字节输入流</td>
</tr>
</tbody></table>
<h2 id="6-打印流"><a href="#6-打印流" class="headerlink" title="6.打印流"></a>6.打印流</h2><ul>
<li>作用:打印流可以实现方便、高效的打印数据到文件中去。打印流-般是指: PrintStream, PrintWriter两个类。</li>
<li>可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97,打印boolean的true, 写出去就是true。</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public PrintStream(OutputStream os)</td>
<td>打印流直接通向字节输出流管道</td>
</tr>
<tr>
<td>public PrintStream(File f)</td>
<td>打印流直接通向文件对象</td>
</tr>
<tr>
<td>public PrintStream(String filepath)</td>
<td>打印流直接通向文件路径</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void print(Xxx xx)</td>
<td>打印任意类型的数据出去</td>
</tr>
</tbody></table>
<p>PrintWriter</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public PrintWriter(OutputStxeam os )</td>
<td>打印流直接通向字节输出流管道</td>
</tr>
<tr>
<td>public PrintWriter (Writer w)</td>
<td>打印流直接通向字符输出流管道</td>
</tr>
<tr>
<td>public PrintWriter (File f)</td>
<td>打印流直接通向文件对象</td>
</tr>
<tr>
<td>public PrintWriter (String filepath)</td>
<td>打印流直接通向文件路径</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void print(Xxx xx)</td>
<td>打印任意类型的数据出去</td>
</tr>
</tbody></table>
<p>PrintStream和PrintWriter的区别</p>
<ul>
<li>打印数据功能上是一模一样的，都是使用方便,性能高效(核心优势)</li>
<li>PrintStream继承自字节输出流OutputStream, 支持写字节数据的方法。</li>
<li>PrintWriter继承自字符输出流Writer, 支持写字符数据出去。</li>
</ul>
<h2 id="7-Properties"><a href="#7-Properties" class="headerlink" title="7.Properties"></a>7.Properties</h2><p>Properties属性集对象</p>
<ul>
<li>其实就是一个Map集合,但是我们- -般不会当集合使用，因为HashMap更好用。</li>
</ul>
<p>Properties核心作用:</p>
<ul>
<li>Properties代表的是 -一个属性文件,可以把自己对象中的键值对信息存入到-一个属性文件中去。</li>
<li>属性文件:后缀是.properties结尾的文件,里面的内容都是key=value,后续做系统配置信息的。</li>
</ul>
<p>Properties的APlI:<br>Properties和IO流结合的方法:</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void load(InputStream inStream)</td>
<td>从输入字节流读取属性列表(键和元素对)</td>
</tr>
<tr>
<td>void load(Reader reader )</td>
<td>从输入字符流读取属性列表(键和元素对)</td>
</tr>
<tr>
<td>void store(OutputStream out, String comments )</td>
<td>将此属性列表(键和元素对)写入此Properties表中，以适合于使用load(InputStream)方法的格式写入输出字节流</td>
</tr>
<tr>
<td>void store(Writer writer, String comments )</td>
<td>将此属性列表(键和元素对)写入此Properties表中，以适合于使用用load(Reader)方法的格式写入输出字符流</td>
</tr>
<tr>
<td>public 0bject setProperty(String key, String value)</td>
<td>保存键值对(put)</td>
</tr>
<tr>
<td>public String getProperty(String key)</td>
<td>使用此属性列表中指定的键搜索属性值(get)</td>
</tr>
<tr>
<td>public Set<String> stringPropertyNames()</td>
<td>所有键的名称的集合(keySet())</td>
</tr>
</tbody></table>
<h2 id="8-IO框架"><a href="#8-IO框架" class="headerlink" title="8.IO框架"></a>8.IO框架</h2><p>commons-io概述</p>
<ul>
<li>commons-io是 apache开源基金组织提供的- -组有关I0操作的类库，可以提高I0功能开发的效率。</li>
<li>commons-io工具包提供了很多有关io操作的类。有两个主要的类FileUtils, l0Utils</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String readFileToString(File file, String encoding)</td>
<td>读取文件中的数据，返回字符串</td>
</tr>
<tr>
<td>void copyFile(File srcFile, File destFile)</td>
<td>复制文件。</td>
</tr>
<tr>
<td>void copyDirectoryToDirectory(File srcDir, File destDir)</td>
<td>复制文件夹。</td>
</tr>
</tbody></table>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>什么是线程?</p>
<ul>
<li>线程(thread)是 一个程序内部的一条执行路径。</li>
<li>我们之前启动程序执行后，main方法的执行其实就是一条单独的执行路径。</li>
<li>程序中如果只有一条执行路径，那么这个程序就是单线程的程序。</li>
</ul>
<p>多线程</p>
<ul>
<li>多线程是指从软硬件.上实现多条执行流程的技术。</li>
</ul>
<h2 id="1-创建多线程"><a href="#1-创建多线程" class="headerlink" title="1.创建多线程"></a>1.创建多线程</h2><h3 id="1-1继承Thread类"><a href="#1-1继承Thread类" class="headerlink" title="1.1继承Thread类"></a>1.1继承Thread类</h3><ul>
<li>Java是通过java.lang.Thread 类来代表线程的。</li>
<li>按照面向对象的思想，Thread类应该提供了实现多线程的方式。</li>
</ul>
<p>多线程的实现方案一:继承Thread类</p>
<ol>
<li>定义一个子类MyThread继承线程类java.lang.Thread,重写run()方法</li>
<li>创建MyThread类的对象</li>
<li>调用线程对象的start()方法启动线程(启动后还是执行run方法的)</li>
</ol>
<p>方式一优缺点:</p>
<ul>
<li>优点:编码简单</li>
<li>缺点:线程类已经继承Thread,无法继承其他类，不利于扩展。</li>
</ul>
<h3 id="1-2实现Runnable接口"><a href="#1-2实现Runnable接口" class="headerlink" title="1.2实现Runnable接口"></a>1.2实现Runnable接口</h3><ol>
<li>定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法</li>
<li>创建MyRunnable任务对象</li>
<li>把MyRunnable任务 对象交给Thread处理。</li>
<li>调用线程对象的start()方 法启动线程</li>
</ol>
<p>Thread的构造器</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Thread(String name)</td>
<td>可以为当前线程指定名称</td>
</tr>
<tr>
<td>public Thread(Runnable target}</td>
<td>封装Runnable对象成为线程对象</td>
</tr>
<tr>
<td>public Thread(Runnable target,String name )</td>
<td>封装Runnable对象成为线程对象，并指定线程名称</td>
</tr>
</tbody></table>
<p>优缺点</p>
<ul>
<li>优点:线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</li>
<li>缺点:编程多一层对象包装，如果线程有执行结果是不可以直接返回的。</li>
</ul>
<p>多线程的实现方案二:实现Runnable接口(匿名内部类形式)</p>
<ol>
<li>可以创建Runnable的匿名 内部类对象。</li>
<li>交给Thread处理 。</li>
<li>调用线程对象的start()启动线程。</li>
</ol>
<h3 id="1-3利用Callable、FutureTask接口实现。"><a href="#1-3利用Callable、FutureTask接口实现。" class="headerlink" title="1.3利用Callable、FutureTask接口实现。"></a>1.3利用Callable、FutureTask接口实现。</h3><ol>
<li>得到任务对象<ol>
<li>定义类实现Callable接口，重写call方法,封装要做的事情。</li>
<li>用FutureTask把Callable对 象封装成线程任务对象。</li>
</ol>
</li>
<li>把线程任务对象交给Thread处理。</li>
<li>调用Thread的start方法启动线程，执行任务</li>
<li>线程执行完毕后、通过FutureTask的get方法去获取任务执行的结果。</li>
</ol>
<p>API</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FutureTask&lt;&gt;(Callable call)</td>
<td>把Callable对象封装成FutureTask对象。</td>
</tr>
<tr>
<td>public V get() throws Exception</td>
<td>获取线程执行call方法返回的结果。</td>
</tr>
</tbody></table>
<p>优缺点</p>
<ul>
<li>优点:<ul>
<li>线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</li>
<li>可以在线程执行完毕后去获取线程执行的结果。</li>
</ul>
</li>
<li>缺点:编码复杂一点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        Callable&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">My</span>(<span class="number">100</span>);</span><br><span class="line">        FutureTask&lt;String&gt; f = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(c);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s = f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception  e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>,<span class="number">500</span>).forEach(i-&gt; System.out.println(<span class="string">&quot;主线程&quot;</span>+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">My</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">My</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>,n).forEach(sum::addAndGet);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;子线程执行结果是&quot;</span>+sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Thread常用方法"><a href="#2-Thread常用方法" class="headerlink" title="2.Thread常用方法"></a>2.Thread常用方法</h2><p>Thread常用API说明</p>
<ul>
<li>Thread常 用方法:获取线程名称getName()、设置名称setName()、获取当前线程对象currentThread()。</li>
</ul>
<p>Thread获取和设置线程名称</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String getName()</td>
<td>获取当前线程的名称，默认线程名称是Thread-索引</td>
</tr>
<tr>
<td>void setName(String name)</td>
<td>将此线程的名称更改为指定的名称，通过构造器也可以设置线程名称</td>
</tr>
<tr>
<td>public static Thread currentThread():</td>
<td>返回对当前正在执行的线程对象的引用</td>
</tr>
</tbody></table>
<h2 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3.线程安全"></a>3.线程安全</h2><p>多个线程同时操作同一个共享资源的时候可能会出现业务安全问题,称为线程安全问题。</p>
<h2 id="4-线程同步"><a href="#4-线程同步" class="headerlink" title="4.线程同步"></a>4.线程同步</h2><h3 id="4-1目的："><a href="#4-1目的：" class="headerlink" title="4.1目的："></a>4.1目的：</h3><ul>
<li>为了解决线程安全问题。    </li>
</ul>
<p>线程同步的核心思想</p>
<ul>
<li>加锁, 把共享资源进行上锁,每次只能一个线程进 入访问完毕以后解锁,然后其他线程才能进来。</li>
</ul>
<h3 id="4-2同步代码块"><a href="#4-2同步代码块" class="headerlink" title="4.2同步代码块"></a>4.2同步代码块</h3><ul>
<li>作用:把出现线程安全问题的核心代码给上锁。</li>
<li>原理:每次只能-一个线程进入,执行完毕后自动解锁,其他线程才可以进来执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁对象) &#123;</span><br><span class="line">操作共享资源的代码(核心代码)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁对象要求</p>
<ul>
<li>理论上:锁对象只要对于当前同时执行的线程来说是同一个对象即可。</li>
<li>锁对象用任意唯一的对象不好,会影响其他无关线程的执行。</li>
<li>规范上:建议使用共享资源作为锁对象。</li>
<li>对于实例方法建议使用this作为锁对象。</li>
<li>对于静态方法建议使用字节码(类名.class) 对象作为锁对象。</li>
</ul>
<h3 id="4-3同步方法"><a href="#4-3同步方法" class="headerlink" title="4.3同步方法"></a>4.3同步方法</h3><ul>
<li>作用:把出现线程安全问题的核心方法给.上锁。</li>
<li>原理:每次只能一一个线程进入，执行完毕以后自动解锁,其他线程才可以进来执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符<span class="keyword">synchronized</span>返回值类型方法名称(形参列表) &#123;</span><br><span class="line">操作共享资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法底层原理</p>
<ul>
<li>同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。</li>
<li>如果方法是实例方法:同步方法默认用this作为的锁对象。但是代码要高度面向对象!</li>
<li>如果方法是静态方法:同步方法默认用类名.class作为的锁对象。</li>
</ul>
<h3 id="4-4Lock锁"><a href="#4-4Lock锁" class="headerlink" title="4.4Lock锁"></a>4.4Lock锁</h3><ul>
<li>为了更清晰的表达如何加锁和释放锁，JDK5以后提供了-个新的锁对象Lock,更加灵活、方便。</li>
<li>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。</li>
<li>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ReentrantLock()</td>
<td>获得Lock锁的实现类对象</td>
</tr>
<tr>
<td>void lock()</td>
<td>获得锁</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
</tbody></table>
<h2 id="5-线程通信"><a href="#5-线程通信" class="headerlink" title="5.线程通信"></a>5.线程通信</h2><p>什么是线程通信、如何实现?</p>
<ul>
<li>所谓线程通信就是线程间相互发送数据。</li>
</ul>
<p>线程通信常见形式</p>
<ul>
<li>通过共享一个数据的方式实现。</li>
<li>根据共享数据的情况决定自己该怎么做，以及通知其他线程怎么做。</li>
</ul>
<p>线程通信实际应用模型</p>
<ul>
<li>生产者与消费者模型:生产者线程负责生产数据，消费者线程负责消费生产者产生的数据。</li>
<li> 般要求:生产者线程生产完数据后唤醒消费者，然后等待自己，消费者消费完该数据后唤醒生产者,然后等待自己。</li>
</ul>
<p>线程通信的前提:线程通信通常是在多个线程操作同一-个共享资源的时候需要进行通信，且要保证线程安全。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或notifyAll()方法</td>
</tr>
<tr>
<td>void notify()</td>
<td>唤醒正在等待的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>唤醒正在等待的所有线程</td>
</tr>
</tbody></table>
<h2 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6.线程池"></a>6.线程池</h2><h3 id="6-1概述"><a href="#6-1概述" class="headerlink" title="6.1概述"></a>6.1概述</h3><p>线程池就是一一个可以复用线程的技术。</p>
<p>不使用线程池的问题</p>
<ul>
<li>如果用户每发起一一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。</li>
</ul>
<h3 id="6-2实现线程池"><a href="#6-2实现线程池" class="headerlink" title="6.2实现线程池"></a>6.2实现线程池</h3><p>JDK 5.0起提供了代表线程池的接口: ExecutorService</p>
<p>实现线程池对象</p>
<ol>
<li><p>使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象</p>
<ul>
<li><p>参数说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">						  <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">						  <span class="type">long</span> keepAliveTime ,</span></span><br><span class="line"><span class="params">						  TimeUnit unit,</span></span><br><span class="line"><span class="params">						  BlockingQueue &lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">						  ThreadFactory threadF actory,</span></span><br><span class="line"><span class="params">						  RejectedExecut: ionHandler handler)</span></span><br><span class="line">参数一:指定线程池的线程数量(核心线程):corePoolSize	不能小于<span class="number">0</span></span><br><span class="line">参数二:指定线程池可支持的最大线程数:maximumPoolSize	最大数量&gt;=核心线程数量</span><br><span class="line">参数三:指定临时线程的最大存活时间: keepAliveTime	 不能小于<span class="number">0</span></span><br><span class="line">参数四:指定存活时间的单位(秒、分、时、天): unit	   时间单位</span><br><span class="line">参数五:指定任务队列: workQueue					  不能为<span class="literal">null</span></span><br><span class="line">参数六:指定用哪个线程工厂创建线程: threadFactory	不能为<span class="literal">null</span></span><br><span class="line">参数七:指定线程忙，任务满的时候，新任务来了怎么办:handler	不能为<span class="literal">null</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用Executors (线程池的工具类)调用方法返回不同特点的线程池对象</p>
</li>
</ol>
<h3 id="6-3线程池处理任务"><a href="#6-3线程池处理任务" class="headerlink" title="6.3线程池处理任务"></a>6.3线程池处理任务</h3><h4 id="6-3-1-ThreadPoolExecutor"><a href="#6-3-1-ThreadPoolExecutor" class="headerlink" title="6.3.1 ThreadPoolExecutor"></a>6.3.1 ThreadPoolExecutor</h4><p>ExecutorService的常用方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void execute( Runnable command)</td>
<td>执行任务/命令，没有返回值，一般用来执行Runnable 任务</td>
</tr>
<tr>
<td>Future<T> submit(Callable<T> task)</td>
<td>执行任务，返回未来任务对象获取线程结果，一般拿来执行Callable 任务</td>
</tr>
<tr>
<td>void shutdown()</td>
<td>等任务执行完毕后关闭线程池</td>
</tr>
<tr>
<td>List&lt; Runnable&gt; shutdownNow( )</td>
<td>立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</td>
</tr>
</tbody></table>
<p>新任务拒绝策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>详解</th>
</tr>
</thead>
<tbody><tr>
<td>ThreadPoolExecutor . AbortPolicy</td>
<td>丢弃任务并抛出RejectedExecutionException异常。是默认的策略</td>
</tr>
<tr>
<td>ThreadPoolExecutor .DiscardPolicy:</td>
<td>丢弃任务，但是不抛出异常这是不推荐的做法</td>
</tr>
<tr>
<td>ThreadPoolExecutor .Discard0ldestPolicy</td>
<td>抛弃队列中等待最久的任务然后把当前任务加入队列中</td>
</tr>
<tr>
<td>ThreadPoolExecutor . CallerRunsPolicy</td>
<td>由主线程负责调用任务的run(方法从而绕过线程池直接执行</td>
</tr>
</tbody></table>
<p><strong>任务占满了主线程和等待队列才会开启临时线程</strong></p>
<p>线程池处理Runnable 任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,<span class="number">5</span>,</span><br><span class="line">                <span class="number">6</span>, TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="type">my</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">my</span>();</span><br><span class="line">        pool.execute(m);</span><br><span class="line">        pool.execute(m);</span><br><span class="line">        pool.execute(m);</span><br><span class="line">        pool.execute(m);</span><br><span class="line">        pool.execute(m);</span><br><span class="line">        pool.execute(m);</span><br><span class="line">        pool.execute(m);</span><br><span class="line">        pool.execute(m);</span><br><span class="line">        pool.execute(m);</span><br><span class="line">        pool.execute(m);</span><br><span class="line">        pool.execute(m);</span><br><span class="line">        pool.execute(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;输出了&quot;</span>+i);</span><br><span class="line">                Thread.sleep(<span class="number">100000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Callable 任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,<span class="number">5</span>,</span><br><span class="line">                <span class="number">6</span>, TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="type">My</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">My</span>(<span class="number">100</span>);</span><br><span class="line">        Future&lt;String&gt; s1 = pool.submit(m);</span><br><span class="line">        Future&lt;String&gt; s2 = pool.submit(m);</span><br><span class="line">        Future&lt;String&gt; s3 = pool.submit(m);</span><br><span class="line">        Future&lt;String&gt; s4 = pool.submit(m);</span><br><span class="line">        Future&lt;String&gt; s5 = pool.submit(m);</span><br><span class="line">        Future&lt;String&gt; s6 = pool.submit(m);</span><br><span class="line">        Future&lt;String&gt; s7 = pool.submit(m);</span><br><span class="line">        Future&lt;String&gt; s8 = pool.submit(m);</span><br><span class="line">        Future&lt;String&gt; s9 = pool.submit(m);</span><br><span class="line">        Future&lt;String&gt; s0 = pool.submit(m);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(s1.get());</span><br><span class="line">            System.out.println(s2.get());</span><br><span class="line">            System.out.println(s3.get());</span><br><span class="line">            System.out.println(s4.get());</span><br><span class="line">            System.out.println(s5.get());</span><br><span class="line">            System.out.println(s6.get());</span><br><span class="line">            System.out.println(s7.get());</span><br><span class="line">            System.out.println(s8.get());</span><br><span class="line">            System.out.println(s9.get());</span><br><span class="line">            System.out.println(s0.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">My</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">My</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>,n).forEach(sum::addAndGet);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">&quot;执行结果是&quot;</span>+sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-2-Executors"><a href="#6-3-2-Executors" class="headerlink" title="6.3.2 Executors"></a>6.3.2 Executors</h4><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static ExecutorService newCachedThreadPool()</td>
<td>线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。</td>
</tr>
<tr>
<td>public static ExecutorService newFixedThreadPool(int nThreads)</td>
<td>创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充个新线程替代它。</td>
</tr>
<tr>
<td>public static ExecutorService newsingleThreadExecutor ()</td>
<td>创建只有一个线程的线程池对象， 如果该线程出现异常而结束，那么线程池会补充个新线程。</td>
</tr>
<tr>
<td>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td>
<td>创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</td>
</tr>
</tbody></table>
<p><strong>主意: Executors的底层其实也是基于线程池的实现类ThreadPoolExecutor创建线程池对象的。</strong></p>
<p>Executors使用可能存在的陷阱</p>
<ul>
<li>大型并发系统环境中使用Executors如果不注意 可能会出现系统风险。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>存在问题</th>
</tr>
</thead>
<tbody><tr>
<td>public static ExecutorService newFixedThreadPool(int nThreads )</td>
<td>允许请求的任务队列长度是Integer.MAX _VALUE,可能出现OOM错误( java.lang.OutOfMemoryError )</td>
</tr>
<tr>
<td>public static ExecutorService newSingleThreadExecutor()</td>
<td>允许请求的任务队列长度是Integer.MAX _VALUE,可能出现OOM错误( java.lang.OutOfMemoryError )</td>
</tr>
<tr>
<td>public static ExecutorService newCachedThreadPool()</td>
<td>创建的线程数量最大上限是Integer.MAX _VALUE,线程数可能会随着任务1:1增长，也可能出现OOM错误</td>
</tr>
<tr>
<td>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td>
<td>创建的线程数量最大上限是Integer.MAX _VALUE,线程数可能会随着任务1:1增长，也可能出现OOM错误</td>
</tr>
</tbody></table>
<h2 id="7-定时器"><a href="#7-定时器" class="headerlink" title="7.定时器"></a>7.定时器</h2><p>定时器</p>
<ul>
<li>定时器是一种控制任务延时调用，或者周期调用的技术。</li>
<li>作用:闹钟、定时邮件发送。</li>
</ul>
<p>定时器的实现方式</p>
<ul>
<li>方式一:Timer</li>
<li>方式二: ScheduledExecutorService</li>
</ul>
<h3 id="7-1-Timer定时器"><a href="#7-1-Timer定时器" class="headerlink" title="7.1 Timer定时器"></a>7.1 Timer定时器</h3><table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Timer( )</td>
<td>创建Timer定时器对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void schedule(TimerTask task, 1ong delay, long period)</td>
<td>开启一个定时器，<br>按照计划处理T imerTask任务</td>
</tr>
</tbody></table>
<p>Timer定时器的特点和存在的问题</p>
<ol>
<li>Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入。</li>
<li>可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行。</li>
</ol>
<h3 id="7-2ScheduledExecutorService定时器"><a href="#7-2ScheduledExecutorService定时器" class="headerlink" title="7.2ScheduledExecutorService定时器"></a>7.2ScheduledExecutorService定时器</h3><p>ScheduledExecutorService是jdk1 .5中引入了并发包，目的是为了弥补Timer的缺陷, ScheduledExecutorService内部为线程池。</p>
<table>
<thead>
<tr>
<th>Executors的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td>
<td>得到线程池对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>ScheduledExecutorService的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate( Runnable command, long initialDelay, long period,TimeUnit unit)</td>
<td>周期调度方法</td>
</tr>
</tbody></table>
<p>ScheduledExecutorService的优点</p>
<ol>
<li>基于线程池，某个任务的执行情况不会影响其他定时任务的执行。</li>
</ol>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络通信基本模式</p>
<ul>
<li>常见的通信模式有如下2种形式: Client-Server(CS)、Browser/Server(BS)</li>
</ul>
<h2 id="1-三要素"><a href="#1-三要素" class="headerlink" title="1.三要素"></a>1.三要素</h2><p>IP地址</p>
<ul>
<li>:设备在网络中的地址，是唯一的标识。<ul>
<li>ipconfig:查看本机IP地址</li>
<li>ping IP地址:检查网络是否连通</li>
</ul>
</li>
<li>特殊IP地址<ul>
<li>本机IP: 127.0.0.1或者localhost:称为回送地址也可称本地回环地址，只会寻找当前所在本机。</li>
</ul>
</li>
</ul>
<p>端口:</p>
<ul>
<li>应用程序在设备中唯一的标识。</li>
</ul>
<p>协议:</p>
<ul>
<li>数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。</li>
</ul>
<h3 id="1-1IP地址"><a href="#1-1IP地址" class="headerlink" title="1.1IP地址"></a>1.1IP地址</h3><ul>
<li>全称”互联网协议地址”，是分配给.上网设备的唯一标志。</li>
<li>常见的IP分类为: IPv4和IPv6</li>
<li>IPv6: 128位(16个字节) ,号称可以为地球每一粒沙子编号。</li>
<li>IPv6分成8个整数，每个整数用四个十六进制位表示，数之间用冒号(: )分开。</li>
<li>形式<ul>
<li>公网地址</li>
<li>私有地址(局域网使用)。<ul>
<li>192.168.开头的就是常见的局域网地址,范围即为192.168.0.0–192.168.255.255, 专门为组织机构内部使用。</li>
</ul>
</li>
</ul>
</li>
<li>命令</li>
</ul>
<p>此类表示Internet协议(IP) 地址。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static InetAddress getLocalHost( )</td>
<td>返回本主机的地址对象</td>
</tr>
<tr>
<td>public static InetAddress getByName(String host)</td>
<td>得到指定主机的IP地址对象，参数是域名或者IP地址</td>
</tr>
<tr>
<td>public String getHostName( )</td>
<td>获取此IP地址的主机名</td>
</tr>
<tr>
<td>public String getHostAddress()</td>
<td>返回IP地址</td>
</tr>
<tr>
<td>public boolean isReachable(int timeout )</td>
<td>在指定毫秒内连通该IP地址对应的主机，连通返回true</td>
</tr>
</tbody></table>
<h3 id="1-2端口号"><a href="#1-2端口号" class="headerlink" title="1.2端口号"></a>1.2端口号</h3><p>端口号</p>
<ul>
<li>端口号:标识正在计算机设备上运行的进程(程序) ,被规定为一个16位的二进制，范围是0~65535。</li>
</ul>
<p>端口类型</p>
<ul>
<li>周知端口: 0~1023,被预先定义的知名应用占用(如: HTTP占用80，FTP占用21)</li>
<li>注册端口: 1024~49151, 分配给用户进程或某些应用程序。( 如: Tomcat占用8080, MySQL占用3306)</li>
<li>动态端口: 49152到65535,之所以称为动态端口，是因为它- -般不固定分配某种进程，而是动态分配。</li>
<li><strong>注意:我们自己开发的程序选择注册端口，且-一个设备中不能出现两个程序的端口号-样，否则出错。</strong></li>
</ul>
<h3 id="1-3协议"><a href="#1-3协议" class="headerlink" title="1.3协议"></a>1.3协议</h3><p>通信协议</p>
<ul>
<li>连接和通信数据的规则被称为网络通信协议</li>
</ul>
<p>网络通信协议有两套参考模型</p>
<ul>
<li>OSI参考模型: 世界互联协议标准，全球通信规范，由于此模型过于理想化，未能在因特网上进行广泛推广。</li>
<li>TCP/IP参考模型(或TCP/IP协议): 事实上的国际标准。</li>
</ul>
<table>
<thead>
<tr>
<th>OSI参考模型</th>
<th>TCP/IP参考模型</th>
<th>各层对应</th>
<th>面向操作</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用层</td>
<td>HTTP、FTP、 DNS、SMT…</td>
<td>应用程序需要关注的:<br/>浏览器，邮箱。<br>程序员一般在这一层开发</td>
</tr>
<tr>
<td>表示层</td>
<td>应用层</td>
<td>HTTP、FTP、 DNS、SMT…</td>
<td>应用程序需要关注的:<br/>浏览器，邮箱。<br>程序员一般在这一层开发</td>
</tr>
<tr>
<td>会话层</td>
<td>应用层</td>
<td>HTTP、FTP、 DNS、SMT…</td>
<td>应用程序需要关注的:<br/>浏览器，邮箱。<br>程序员一般在这一层开发</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>TCP、UDP..</td>
<td>选择使用的TCP , UDP协议</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
<td>IP、ICMP..</td>
<td>封装源和目标IP，<br/>进行路径选择</td>
</tr>
<tr>
<td>数据链路层</td>
<td>数据链路层+物理</td>
<td>物理寻址、比特流…</td>
<td>物理设备中传输</td>
</tr>
<tr>
<td>物理层</td>
<td>数据链路层+物理</td>
<td>物理寻址、比特流…</td>
<td>物理设备中传输</td>
</tr>
</tbody></table>
<p>传输层的2个常见协议</p>
<ul>
<li>TCP(Transmission Control Protocol) : 传输控制协议</li>
<li>UDP(User Datagram Protocol): 用户数据报协议</li>
</ul>
<p>TCP协议特点</p>
<ul>
<li>使用TCP协议,必须双方先建立连接,它是一种面向连接的可靠通信协议。</li>
<li>传输前，采用“三次握手”方式建立连接，所以是可靠的。</li>
<li>在连接中可进行大数据量的传输。</li>
<li>连接、发送数据都需要确认，且传输完毕后,还需释放已建立的连接,通信效率较低。</li>
</ul>
<p>TCP协议通信场景</p>
<ul>
<li>对信息安全要求较高的场景，例如:文件下载、金融等数据通信。</li>
</ul>
<p>UDP协议:</p>
<ul>
<li>UDP是一种无连接、不可靠传输的协议。</li>
<li>将数据源IP、目的地IP和端口封装成数据包，不需要建立连接</li>
<li>每个数据包的大小限制在64KB内</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
<li>可以广 播发送,发送数据结束时无需释放资源，开销小，速度快。</li>
</ul>
<p>UDP协议通信场景</p>
<ul>
<li>语音通话,视频会话等。</li>
</ul>
<h2 id="2-UDP通信"><a href="#2-UDP通信" class="headerlink" title="2.UDP通信"></a>2.UDP通信</h2><h3 id="2-1入门"><a href="#2-1入门" class="headerlink" title="2.1入门"></a>2.1入门</h3><p>UDP协议的特点</p>
<ul>
<li>UDP是一种无连接、不可靠传输的协议。</li>
<li>将数据源IP、目的地IP和端口以及数据封装成数据包，大小限制在64KB内，直接发送出去即可。</li>
</ul>
<p>DatagramPacket:数据包对象</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public DatagramPacket(byte[] buf, int length, InetAddress address, int port)</td>
<td>创建发送端数据包对象<br>buf:要发送的内容，字节数组<br/>length:要发送内容的字节长度<br/>address:接收端的IP地址对象<br/>port:接收端的端口号</td>
</tr>
<tr>
<td>oublic DatagramPacket(byte[] buf, int length)</td>
<td>创建接收端的数据包对象<br/>buf:用来存储接收的内容<br/>length:能够接收内容的长度</td>
</tr>
</tbody></table>
<p>DatagramPacket常用方法.</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int getLength()</td>
<td>获得实际接收到的字节个数</td>
</tr>
</tbody></table>
<p>DatagramSocket:发送端和接收端对象</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public DatagramSocket( )</td>
<td>创建发送端的Socket对象，系统会随机分配个端口号。</td>
</tr>
<tr>
<td>public DatagramSocket(int port)</td>
<td>创建接收端的Socket对象并指定端口号</td>
</tr>
</tbody></table>
<p>DatagramSocket类成员方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void send(DatagramPacket dp)</td>
<td>发送数据包</td>
</tr>
<tr>
<td>public void receive(DatagramPacket p)</td>
<td>接收数据包</td>
</tr>
</tbody></table>
<h3 id="2-2多发多收"><a href="#2-2多发多收" class="headerlink" title="2.2多发多收"></a>2.2多发多收</h3><p>用while写死循环</p>
<h4 id="2-2-1-UDP的三种通信方式"><a href="#2-2-1-UDP的三种通信方式" class="headerlink" title="2.2.1 UDP的三种通信方式"></a>2.2.1 UDP的三种通信方式</h4><ul>
<li>单播: 单台主机与单台主机之间的通信。</li>
<li>广播:当前主机与所在网络中的所有主机通信。</li>
<li>组播:当前主机与选定的一-组主机的通信。</li>
</ul>
<p>实现广播</p>
<ul>
<li>使用广播地址: 255.255.255.255 </li>
<li>具体操作:<ol>
<li>发送端发送的数据包的目的地写的是广播地址、且指定端口。<br>(255.255.255.255，9999)</li>
<li>本机所在网段的其他主机的程序只要匹配端口成功即就可以收到消息了。(9999)</li>
</ol>
</li>
</ul>
<p>实现组播</p>
<ul>
<li>使用组播地址: 224.0.0.0 ~ 239.255.255.255</li>
<li>具体操作:<ol>
<li>发送端的数据包的目的地是组播IP (例如: 224.0.1.1, 端口: 9999)</li>
<li>接收端必须绑定该组播IP(224.0.1.1),端口还要对应发送端的目的端口9999，这样即可接收该组播消息。</li>
<li>DatagramSocket的子类MulticastSocket可以在接收端绑定组播IP。</li>
</ol>
</li>
</ul>
<h2 id="3-TCP通信"><a href="#3-TCP通信" class="headerlink" title="3.TCP通信"></a>3.TCP通信</h2><p>TCP协议回顾:</p>
<ul>
<li>TCP是一 种面向连接，安全、可靠的传输数据的协议</li>
<li>传输前，采用“三次握手”方式，点对点通信，是可靠的</li>
<li>在连接中可进行大数据量的传输</li>
</ul>
<p>Socket</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Socket(String host，int port)</td>
<td>创建发送端的Socket对象与服务端连接，参数为服务端程序的ip和端口。</td>
</tr>
</tbody></table>
<ol>
<li>创建客户端的Socket对象，请求与服务端的连接。</li>
<li>使用socket对 象调用getOutputStream()方法得到字节输出流。</li>
<li>使用字节输出流完成数据的发送。</li>
</ol>
<ul>
<li>OutputStream getOutputStream():获得字节输出流对象(发)</li>
<li>InputStream getInputStream():获得字节输入流对象(收)</li>
</ul>
<p>ServerSocket(服务端)</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ServerSocket(int port)</td>
<td>注册服务端端口</td>
</tr>
</tbody></table>
<p>ServerSocket类成员方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Socket accept()</td>
<td>等待接收客户端的Socket通信连接<br>连接成功返回Socket对象与客户端建立端到端通信</td>
</tr>
</tbody></table>
<ol>
<li>创建ServerSocket对象， 注册服务端端口。</li>
<li>调用ServerSocket对象的accept()方法， 等待客户端的连接，并得到Socket管道对象</li>
<li>通过Socket对象调用getInputStream()方法得到字节输入流、 完成数据的接收。</li>
<li>释放资源:关闭socket管道</li>
</ol>
<p>多发多收</p>
<ol>
<li>可以使用死循环控制服务端收完消息继续等待接收下一个消息。</li>
<li>客户端也可以使用死循环等待用户不断输入消息。</li>
<li>客户端一旦输入了exit, 则关闭客户端程序,并释放资源。</li>
</ol>
<h2 id="4-BS架构"><a href="#4-BS架构" class="headerlink" title="4.BS架构"></a>4.BS架构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">my</span>(s).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">my</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">            ps.println(<span class="string">&quot;http/1.1 200 OK&quot;</span>);</span><br><span class="line">            ps.println(<span class="string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            ps.println();</span><br><span class="line">            ps.println(<span class="string">&quot;&lt;span style=&#x27;color : red;font-size:90px &#x27;&gt;《你好啊》&lt;/span&gt;&quot;</span>);</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><ul>
<li>单元测试就是针对最小的功能单元编写测试代码, Java程序最小的功能单元是方法，因此，单元测试就是针对Java</li>
<li>方法的测试，进而检查方法的正确性。</li>
</ul>
<p>目前测试方法是怎么进行的，存在什么问题</p>
<ul>
<li>只有一个main方法,如果-一个方法的测试失败了,其他方法测试会受到影响。</li>
<li>无法得到测试的结果报告，需要程序员自己去观察测试是否成功。<ul>
<li>无法实现自动化测试。</li>
</ul>
</li>
</ul>
<h2 id="1-Junit单元测试框架"><a href="#1-Junit单元测试框架" class="headerlink" title="1.Junit单元测试框架"></a>1.Junit单元测试框架</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><ul>
<li>jUnit是使 用Java语言实现的单元测试框架，它是开源的，Java开 发者都应当学习并使用JUnit编写单元测试。</li>
<li>此外，几乎所有的IDE工具都集成了JUnit,这样我们就可以直接在IDE中编写并运行JUnit测试, jUnit目 前最新版本是5。</li>
</ul>
<p>优点</p>
<ul>
<li>jUnit可以灵活的选择执行哪些测试方法，可以一键执行全 部测试方法。</li>
<li>Junit可以生成全部方法的测试报告。</li>
<li>单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。</li>
</ul>
<h3 id="1-2-入门"><a href="#1-2-入门" class="headerlink" title="1.2 入门"></a>1.2 入门</h3><ol>
<li>将JUnit的jar包导入到项目中<ul>
<li>IDEA通常整合好了Junit框架，一般不需要导入。</li>
<li>如果IDEA没有整合好，需要自己手工导入如下2个jUnit的jar包到模块</li>
</ul>
</li>
<li>编写测试方法:该测试方法必须是公共的无参数无返回值的非静态方法。</li>
<li>在测试方法_上使用@Test注解:标注该方法是一-个测试方法</li>
<li>在测试方法中完成被测试方法的预期正确性测试。</li>
<li>选中测试方法,选择”JUnit运行”，如果测试良好则是绿色;如果测试失败，则是红色</li>
</ol>
<h3 id="1-3注解"><a href="#1-3注解" class="headerlink" title="1.3注解"></a>1.3注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>测试方法</td>
</tr>
<tr>
<td>@Before</td>
<td>用来修饰实例方法，该方法会在每一一个测试方法执行之前执行一-次。</td>
</tr>
<tr>
<td>@After</td>
<td>用来修饰实例方法，该方法会在每一个测试方法执行之 后执行一次。</td>
</tr>
<tr>
<td>@BeforeClass</td>
<td>用来静态修饰方法，该方法会在所有测试方法之前只执行一-次。</td>
</tr>
<tr>
<td>@AfterClass</td>
<td>用来静态修饰方法，该方法会在所有测试方法之后只执行一-次。</td>
</tr>
</tbody></table>
<ul>
<li>开始执行的方法:初始化资源。</li>
<li>执行完之后的方法:释放资源。</li>
</ul>
<h2 id="2-反射"><a href="#2-反射" class="headerlink" title="2.反射"></a>2.反射</h2><h3 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h3><ul>
<li>反射是指对于任何-个Class类，在”运行的时候”都可以直接得到这个类全部成分。</li>
<li>在运行时,可以直接得到这个类的构造器对象: Constructor</li>
<li>在运行时,可以直接得到这个类的成员变量对象: Field</li>
<li>在运行时,可以直接得到这个类的成员方法对象: Method</li>
<li>这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。</li>
</ul>
<p>反射的关键:</p>
<ul>
<li><p>反射的第一步都是先得到编译后的Class类对象,然后就可以得到Class的全部成分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld.java -&gt; javac -&gt; HelloWorld.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Class</span> c= HelloWorld.class; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-获取class类的对象"><a href="#2-2-获取class类的对象" class="headerlink" title="2.2 获取class类的对象"></a>2.2 获取class类的对象</h3><p>class类中的静态方法</p>
<ol>
<li>forName(String className)</li>
<li>类名.crass</li>
<li>对象.getClass()</li>
</ol>
<h3 id="2-3获取构造器对象"><a href="#2-3获取构造器对象" class="headerlink" title="2.3获取构造器对象"></a>2.3获取构造器对象</h3><p>使用反射技术获取构造器对象并使用</p>
<ol>
<li>获得class对象</li>
<li>获得Constructor对象</li>
<li>创建对象</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor&lt;?&gt;[] getConstructors()</td>
<td>返回所有构造器对象的数组(只能拿public的)</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[] getDeclaredConstructors()</td>
<td>返回所有构造器对象的数组，存在就能拿到</td>
</tr>
<tr>
<td>Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td>返回单个构造器对象(只能拿public的)</td>
</tr>
<tr>
<td>Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td>返回单个构造器对象，存在就能拿到</td>
</tr>
</tbody></table>
<p>获取构造器的作用依然是初始化一个对象返回。</p>
<p>Constructor类中用于创建对象的方法</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>T newlnstance(Object.. initargs)</td>
<td>根据指定的构造器创建对象</td>
</tr>
<tr>
<td>public void setAccessible(boolean flag)</td>
<td>设置为true,表示取消访问检查，进行暴力反射</td>
</tr>
</tbody></table>
<h3 id="2-4获取成员变量对象"><a href="#2-4获取成员变量对象" class="headerlink" title="2.4获取成员变量对象"></a>2.4获取成员变量对象</h3><ol>
<li>获得class对象</li>
<li>获得Field对象</li>
<li>赋值或者获取值</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Field[] getFields()</td>
<td>返回所有成员变量对象的数组(只能拿public的)</td>
</tr>
<tr>
<td>Field[] getDeclaredFields()</td>
<td>返回所有成员变量对象的数组，存在就能拿到</td>
</tr>
<tr>
<td>Field getField(String name)</td>
<td>返回单个成员变量对象(只能拿public的)</td>
</tr>
<tr>
<td>Field getDeclaredField(String name)</td>
<td>返回单个成员变量对象，存在就能拿到</td>
</tr>
</tbody></table>
<p>Field类中用于取值、赋值的方法</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void set(Object obj, Object value):</td>
<td>赋值</td>
</tr>
<tr>
<td>Object get(Object obj)</td>
<td>获取值。</td>
</tr>
</tbody></table>
<h3 id="2-5获取方法对象"><a href="#2-5获取方法对象" class="headerlink" title="2.5获取方法对象"></a>2.5获取方法对象</h3><ol>
<li>获得class对象</li>
<li>获得Method对象</li>
<li>运行方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Method[] getMethods()</td>
<td>返回所有成员方法对象的数组(只能拿public的)</td>
</tr>
<tr>
<td>Method[] getDeclaredMethods()</td>
<td>返回所有成员方法对象的数组，存在就能拿到</td>
</tr>
<tr>
<td>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回单个成员方法对象(只能拿public的)</td>
</tr>
<tr>
<td>Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回单个成员方法对象， 存在就能拿到</td>
</tr>
</tbody></table>
<p>使用反射技术获取方法对象并使用</p>
<ul>
<li>获取成员方法的作用依然是在某个对象中进行执行此方法</li>
</ul>
<p>Method类中用于触发执行的方法</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>object invoke(0bject obj, object… args)</td>
<td>运行方法<br>参数一:用obj对象调用该方法<br>参数二:调用方法的传递的参数(如果没有就不写)<br>返回值:方法的返回值(如果没有就不写)</td>
</tr>
</tbody></table>
<h3 id="2-6-作用"><a href="#2-6-作用" class="headerlink" title="2.6 作用"></a>2.6 作用</h3><p>反射的作用-绕过编译阶段为集合添加数据</p>
<ul>
<li>反射是作用在运行时的技术, 此时集合的泛型将不能产生约束了,此时是可以为集合存入其他任意类型的元素的。</li>
<li>泛型只是在编译阶段可以约束集合只能操作某种数据类型,在编译成Class文件进入运行阶段的时候，其真实类型都是ArrayList了，泛型相当于被擦除了。</li>
</ul>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>概述</p>
<ul>
<li>Java注解(Annotation) 又称Java标注，是JDK5.0引入的一-种注释机制。</li>
<li>Java语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。</li>
</ul>
<p>作用</p>
<ul>
<li>对Java中类、方法、成员变量做标记，然后进行特殊处理，至于到底做何种处理由业务需求来决定。</li>
<li>例如: JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。</li>
</ul>
<h1 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1.自定义注解"></a>1.自定义注解</h1><p>自定义注解就是自己做一-个注解来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span>注解名称&#123;</span><br><span class="line"><span class="keyword">public</span>属性类型属性名() <span class="keyword">default</span> 默认值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特殊属性</p>
<ul>
<li>value属性， 如果只有一-个value属性的情况下，使用value属性的时候可以省略value名称不写!!</li>
<li>但是如果有多个属性,且多个属性没有默认值，那么value名称是不能省略的。</li>
</ul>
<h1 id="2-元注解"><a href="#2-元注解" class="headerlink" title="2.元注解"></a>2.元注解</h1><p>元注解:就是注解注解的注解。</p>
<p>元注解有两个:</p>
<ul>
<li>@Target: 约束自定义注解只能在哪些地方使用,</li>
<li>@Retention: 申明注解的生命周期</li>
</ul>
<p>@Target中可使用的值定义在ElementType枚举类中，常用值如下</p>
<ul>
<li>TYPE, 类,接口</li>
<li>FIELD, 成员变量</li>
<li>METHOD, 成员方法</li>
<li>PARAMETER, 方法参数</li>
<li>CONSTRUCTOR, 构造器</li>
<li>LOCAL_ _VARIABLE,局部变量</li>
</ul>
<p>@Retention中可使用的值定义在RetentionPolicy枚举类中，常用值如下</p>
<ul>
<li>SOURCE:注解只作用在源码阶段，生成的字节码文件中不存在</li>
<li>CLASS:注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值</li>
<li>RUNTIME:注解作用在源码阶段，字节码文件阶段，运行阶段 (开发常用）</li>
</ul>
<h2 id="3-注解解析"><a href="#3-注解解析" class="headerlink" title="3.注解解析"></a>3.注解解析</h2><p>注解的解析</p>
<ul>
<li>注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容</li>
</ul>
<p>与注解解析相关的接口</p>
<ul>
<li>Annotation:注解的顶级接口，注解都是Annotation类型的对象</li>
<li>AnnotatedElement:该接口定义了与注解解析相关的解析方法</li>
</ul>
<table>
<thead>
<tr>
<th>说明</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>Annotation[] getDeclaredAnnotations()</td>
<td>获得当前对象上使用的所有注解，返回注解数组</td>
</tr>
<tr>
<td>T getDeclaredAnnotation(Class<T> annotationClass)</td>
<td>根据注解类型获得对应注解对象</td>
</tr>
<tr>
<td>boolean isAnnotationPresent(Class<Annotation> annotationClass</td>
<td>判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false</td>
</tr>
</tbody></table>
<ul>
<li>所有的类成分Class, Method ,Field ，Constructor，都实现了AnnotatedElement接口他们都拥有解析注解的能力:</li>
</ul>
<p>解析注解的技巧</p>
<ul>
<li>注解在哪个成分上，我们就先拿哪个成分对象</li>
<li>比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解</li>
<li>比如注解作用在类上，则要该类的Class对象，再来拿上面的注解</li>
<li>比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解</li>
</ul>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理</p>
<ul>
<li>代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事，动态代理就是用来对业务功能（方法）进行代理的。</li>
<li>关键步骤<ol>
<li>必须有接口，实现类要实现接口（代理通常是基于接口实现的）</li>
<li>创建一个实现类的对象，该对象为业务对象，紧接着为业务对象做一个代理对象。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">My</span> <span class="variable">s</span> <span class="operator">=</span> (My) ProxyUtil.getProxy(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">        s.login(<span class="string">&quot;pc1608&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public static object newProxyInstance(ClassLoader Loader，CLass&lt;？&gt;[] interfaces，</span></span><br><span class="line"><span class="comment"> InvocationHandler h）</span></span><br><span class="line"><span class="comment"> 参数一：类加载器，负责加载代理类到内存中使用。</span></span><br><span class="line"><span class="comment"> 参数二：获取被代理对象实现的全部接口。代理要为全部接口的全部方法进行代理</span></span><br><span class="line"><span class="comment"> 参数三：代理的核心处理逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyUtil</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  Proxy.newProxyInstance(student.getClass().getClassLoader(),</span><br><span class="line">                student.getClass().getInterfaces(),</span><br><span class="line">                (proxy, method, args) -&gt; &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                参数一：代理对象本身。一般不管</span></span><br><span class="line"><span class="comment">                参数二：正在被代理的方法</span></span><br><span class="line"><span class="comment">                参数三：被代理方法，应诊传入的参数</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(student, args);</span><br><span class="line">                    <span class="type">long</span> <span class="variable">endTime</span>  <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                    System.out.println(method.getName()+<span class="string">&quot;方法耗时&quot;</span>+(endTime-startTime)/<span class="number">1000</span>+<span class="string">&quot;s&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点</p>
<ul>
<li>非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理。</li>
<li>可以为被代理对象的所有方法做代理。</li>
<li>可以在不改变方法源码的情况下，实现对方法功能的增强。</li>
<li>不仅简化了编程工作、提高了软件系统的可扩展性，同时也提高了开发效率</li>
</ul>
<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="1-概述-9"><a href="#1-概述-9" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>XML是可扩展标记语言（extensibleMarkupLanguage）的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</li>
</ul>
<p>XML的几个特点和使用场景</p>
<ul>
<li>一是纯文本，默认使用UTF-8编码；二是可嵌套；</li>
<li>如果把XML内容存为文件，那么它就是一个XML文件。</li>
<li>XML的使用场景：XML内容经常被当成消息进行网络传输，或者作为配置文件用于存储系统的信息。</li>
</ul>
<h2 id="2-创建"><a href="#2-创建" class="headerlink" title="2.创建"></a>2.创建</h2><ul>
<li>就是创建一个XML类型的文件，要求文件的后缓必须使用xml，如hello_world.xml</li>
</ul>
<p>语法规则</p>
<p>XML文件的后缀名为：xm<br>文档声明必须是第一行</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=1.0” encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> </span><br><span class="line">version：XML默认的版本号码、该属性是必须存在的</span><br><span class="line">encoding：本XML文件的编码</span><br></pre></td></tr></table></figure>

<p>XML的标签（元素）规则</p>
<ul>
<li>标签由一对尖括号和合法标识符组成：<name></name>，必须存在一个根标签，有且只能有一</li>
<li>标签必须成对出现，有开始，有结束：<name></name></li>
<li>特殊的标签可以不成对，但是必须有结束标记，如：<br/></li>
<li>标签中可以定义属性，属性和标签名空格隔开，属性值必须用引号引起来&lt;studentid=<br>“1”&gt;</name></li>
<li>标签需要正确的嵌套</li>
</ul>
<p>其他组成</p>
<ul>
<li><p>XML文件中可以定义注释信息：&lt;！–注释内容–&gt;</p>
</li>
<li><p>XML文件中可以存在以下特殊字符</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">81t；&lt;	小于</span><br><span class="line">&amp;gt; &gt;`	大于</span><br><span class="line">&amp;amp；&amp; 和</span><br><span class="line">&amp;apos；&#x27; 单引号</span><br><span class="line">&amp;quot；“ 引号</span><br></pre></td></tr></table></figure></li>
<li><p>XML文件中可以存在CDATA区：<![CDATA[内容]]> </p>
</li>
</ul>
<h2 id="3-文档约束"><a href="#3-文档约束" class="headerlink" title="3.文档约束"></a>3.文档约束</h2><ul>
<li>文档约束：是用来限定xml文件中的标签以及属性应该怎么写。</li>
</ul>
<p>文档约束的分类</p>
<ul>
<li>DTD</li>
<li>schema</li>
</ul>
<p>schemal约束</p>
<ol>
<li>编写schema约束文档，后缀必须是.xsd，具体的形式到代码中观看。</li>
<li>在需要编写的XML文件中导入该schema约束文档</li>
<li>按照约束内容编写XML文件的标签。</li>
</ol>
<h2 id="4-XML解析"><a href="#4-XML解析" class="headerlink" title="4.XML解析"></a>4.XML解析</h2><p>概述</p>
<ul>
<li>使用程序读取XML中的数据</li>
</ul>
<p>解析方式</p>
<ol>
<li>SAX解析</li>
<li>DOM解析</li>
</ol>
<p>Dom常见的解析工具</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>JAXP</td>
<td>SUN公司提供的一套XML的解析的API</td>
</tr>
<tr>
<td>JDOM</td>
<td>JDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。</td>
</tr>
<tr>
<td>dom4j</td>
<td>是JDOM的升级品，用来读写XML文件的。具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom技术，同时它也是一个开放源代码的软件，Hibernate也用它来读写配置文件。</td>
</tr>
<tr>
<td>jsoup</td>
<td>功能强大DOM方式的XML解析开发包，尤其对HTML解析更加方便</td>
</tr>
</tbody></table>
<p>Document对象：整个xml文档<br>Element对象：标签<br>Attribute对象：属性<br>Text对象：文本内容</p>
<h3 id="Dom4j-解析出XML文件"><a href="#Dom4j-解析出XML文件" class="headerlink" title="Dom4j 解析出XML文件"></a>Dom4j 解析出XML文件</h3><p>Dom4j解析XML-得到Pocument对象</p>
<p>SAXReader类</p>
<table>
<thead>
<tr>
<th>构造器/方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public SAxReader（）</td>
<td>创建Dom4J的解析器对象</td>
</tr>
<tr>
<td>Document read(String ur）</td>
<td>加载XML文件成为Document对象</td>
</tr>
</tbody></table>
<p>Document类</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Element getRootElemento</td>
<td>获得根元素对象</td>
</tr>
</tbody></table>
<h3 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h3><p>概述</p>
<ul>
<li>XPath在解析XML文档方面提供了一独树一帜的路径思想，更加优雅，高效</li>
<li>XPath使用路径表达式来定位XML文档中的元素节点或属性节点。</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">John Doe</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2022/0306undefined.html">http://example.com/2022/0306undefined.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">John Doe</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2022/0306undefined.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-03-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            John Doe
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/0224undefined.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-02-24
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            John Doe
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">John Doe</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">57.1k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/pc1608" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>






</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
