<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java基础</title>
    <url>/java/javaSe/</url>
    <content><![CDATA[<p>方法名</p>
<h1 id="java-基本语法"><a href="#java-基本语法" class="headerlink" title="java 基本语法"></a>java 基本语法</h1><h2 id="1、注释"><a href="#1、注释" class="headerlink" title="1、注释"></a>1、注释</h2><ul>
<li><p><strong>什么事注释</strong></p>
<ul>
<li>注释是写在程序中对代码进行解释说明的文字,方便自己和其他人查看，以便理解程序的。</li>
</ul>
</li>
<li><p><strong>注释有哪些</strong></p>
<ul>
<li><p>单行注释</p>
<p><code>//注释内容，只能写一行</code></p>
</li>
<li><p>多行注释</p>
<pre><code class="java">/*
    注释内容1
    注释内容2
*/
</code></pre>
</li>
<li><p><strong>文档注释</strong></p>
<ul>
<li><p>对文档中的注释是可以提取到一个程序说明文档中去的</p>
<pre><code class="java">/**
    注释内容
    注释内容
*/
</code></pre>
<span id="more"></span></li>
</ul>
</li>
</ul>
</li>
<li><p>注释不影响程序运行</p>
</li>
<li><p>小技巧</p>
<table>
<thead>
<tr>
<th>快捷键进行注释</th>
<th>功能效果</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+ /</td>
<td>单行注释(对当前行进行注释)</td>
</tr>
<tr>
<td>Ctrl+ Shift + /</td>
<td>对选中的代码进行多行注释</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="2、字面量"><a href="#2、字面量" class="headerlink" title="2、字面量"></a>2、字面量</h2><ul>
<li><p>计算机是用来处理数据的，字面量就是告诉程序员:数据在程序中的书写格式。</p>
<p><strong>常用数据</strong></p>
<table>
<thead>
<tr>
<th>常用数据</th>
<th>生活中的写法</th>
<th>程序中的写法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>整数</td>
<td>666,-88</td>
<td>666,-88</td>
<td>写法一致</td>
</tr>
<tr>
<td>小数</td>
<td>13.14 ,-5.12</td>
<td>13.14 ,-5.12</td>
<td>写法一致</td>
</tr>
<tr>
<td>字符</td>
<td>a,b,我</td>
<td>‘a’ ,‘b’ ,‘我’</td>
<td>程序中使用单引号，有且只有一个字符</td>
</tr>
<tr>
<td>字符串</td>
<td>hello world</td>
<td>“hello world”</td>
<td>程序中使用双引号，内容可有可无</td>
</tr>
<tr>
<td>布尔值</td>
<td>真假</td>
<td>true  false</td>
<td>只有两个值：true代表真，false代表假</td>
</tr>
<tr>
<td>空值</td>
<td></td>
<td>值是：null</td>
<td>一个特殊的值，空值</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h2><p><strong>什么是变量</strong></p>
<ul>
<li>变量就是用来存储-一个数据的内存区域(可以理解成盒子) ,且里面存储的数据可以变化。</li>
</ul>
<p>变量定义的格式</p>
<p>数据类型[^type]  变量名称[^name] = 初始值[^value]</p>
<p>[^type]:强制限制盒子中存储数据的形式。例如: int (整数类型)、double(小数类型)<br>[^name]:首字母建议小写，有意义<br>[^value]:存储的初始数据</p>
<h2 id="4、变量使用注意事项"><a href="#4、变量使用注意事项" class="headerlink" title="4、变量使用注意事项"></a>4、变量使用注意事项</h2><ul>
<li>变量要先声明在使用</li>
<li>变量声明后，不能存储其他类型的数据</li>
<li>变量的有效范围是从定义开始到“;”结束，且在用一个范围内不能定义2个同名的变量</li>
<li>变量定义的时候可以没有初始值，但是使用的时候必须给初始值</li>
</ul>
<h2 id="5、变量里的数据在计算机中的底层原理"><a href="#5、变量里的数据在计算机中的底层原理" class="headerlink" title="5、变量里的数据在计算机中的底层原理"></a>5、变量里的数据在计算机中的底层原理</h2><ul>
<li><p>二进制</p>
<ul>
<li>只有0、1，按照逢2进1的方式表示数据</li>
</ul>
</li>
<li><p>十进制转二进制算法</p>
<ul>
<li>除二取余法</li>
</ul>
</li>
<li><p>计算机中数据的最小单位</p>
<ul>
<li><p>最小保存单位：使用8个二进制为一组来保存数据，我们称之为一个字节(byte,简称B)</p>
<p>其中，每个二进制位称之为一位(bit,简称b)，1byte = 8bit 简写 1B = 8b</p>
</li>
</ul>
</li>
<li><p>图片数据</p>
<ul>
<li>图片就是无数个像素点组成的</li>
<li>每个像素点的数据：用<code>0~255*255*255</code>表示其颜色</li>
</ul>
</li>
<li><p>声音数据</p>
<ul>
<li>用二进制存储</li>
</ul>
</li>
<li><p>二进制转十进制</p>
<ul>
<li>每个位的数 乘以权重相加</li>
</ul>
</li>
<li><p>八进制、十六进制</p>
<ul>
<li>为了便于观察和表示二进制，推出了八进制和十六进制</li>
<li>没三位二进制作为一个单元，最小数是0，最大数是7，共八个数字，就是八进制。</li>
<li>没四位二进制作为一个单元，最小数是0，最大数是15，共16个数字，一次用0~9</li>
<li>A B C D E F代表的就是十六进制</li>
</ul>
</li>
<li><p>java程序中支持书写二进制、八进制、十六进制的数据，分别需以0B、0、0X或者0x开头</p>
</li>
<li><p>计算机的数据单位</p>
</li>
<li><p>计算机最小的组成单元是：字节，1B = 8b</p>
</li>
<li><p>在B的基础上，计算机发展出了KB、MB、GB、TB这些数据单位，相邻之间以1024进位</p>
</li>
</ul>
<h2 id="6、数据类型"><a href="#6、数据类型" class="headerlink" title="6、数据类型"></a>6、数据类型</h2><h3 id="6-1数据类型的分类"><a href="#6-1数据类型的分类" class="headerlink" title="6.1数据类型的分类"></a>6.1数据类型的分类</h3><ul>
<li><p>引用数据类型(除基本数据类型之外的，如String)</p>
</li>
<li><p>基本数据类型：4大类8种</p>
<ul>
<li><p>整数</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>取值范围</th>
<th>内存占用</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>-2^7^~2^7^-1</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>-2^15^~2^15^-1</td>
<td>2</td>
</tr>
<tr>
<td>int(默认)</td>
<td>-2^31^~2^31^-1</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>-2^63^~2^63^-1</td>
<td>8</td>
</tr>
</tbody></table>
</li>
<li><p>浮点数</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>取值范围</th>
<th>内存占用</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>1.401298e-45~3.04823e+38</td>
<td>4</td>
</tr>
<tr>
<td>double(默认)</td>
<td>4.9000000e-324~1.797693e+308</td>
<td>8</td>
</tr>
</tbody></table>
</li>
<li><p>字符</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>取值范围</th>
<th>内存占用</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>0~65535</td>
<td>2</td>
</tr>
</tbody></table>
</li>
<li><p>布尔</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>取值范围</th>
<th>内存占用</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>true,false</td>
<td>1</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="7、关键字、标识符"><a href="#7、关键字、标识符" class="headerlink" title="7、关键字、标识符"></a>7、关键字、标识符</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li>Java自己保留的一些单词,作为特殊功能的，例如: public、 class, byte、 short、 int、 long、 double…</li>
<li>我们不能用来作为类名或者是变量名称，否则报错。</li>
<li>注意:关键字很多，不用刻意去记。</li>
</ul>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul>
<li><p>标志符就是由一-些字符、符号组合起来的名称，用于给类，方法，变量等起名字的规矩。</p>
</li>
<li><p>标识符的要求</p>
<ul>
<li>基本要求:由数字、字母、下划线( )和美元符($)等组成</li>
<li>强制要求:不能以数字开头、不能是关键字、区分大小写</li>
</ul>
</li>
<li><p>命名指导规范</p>
<ul>
<li>变量名称:     满足标识符规则，建议全英文、有意义、首字母小写,满足“驼峰模式”,例如: int studyNumber = 59。</li>
<li>类名称:        满足标识符规则，建议全英文、有意义、首字母大写,满足“驼峰模式”，例如: HelloWorld. java。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="1、自动类型转换"><a href="#1、自动类型转换" class="headerlink" title="1、自动类型转换"></a>1、自动类型转换</h2><ul>
<li>类型范围小的变量，可以直接赋值给类型范围大的变量。</li>
</ul>
<p>自动类型转换的其他形式</p>
<p><code>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</code></p>
<h2 id="2、表达式中的自动类型转换"><a href="#2、表达式中的自动类型转换" class="headerlink" title="2、表达式中的自动类型转换"></a>2、表达式中的自动类型转换</h2><ul>
<li><p>在表达式中，小范围的变量会自动转换成较大范围的类型在计算</p>
<p><code>byte、short、char、-&gt;int-&gt;long-&gt;float-&gt;double</code></p>
</li>
<li><p>注意事项</p>
<ul>
<li>表达式的最终结果类型由表达式中的最高类型决定</li>
<li>在表达式中，byte、short、char是直接转简称int类型参与计算的</li>
</ul>
</li>
</ul>
<h2 id="3、强制类型转化"><a href="#3、强制类型转化" class="headerlink" title="3、强制类型转化"></a>3、强制类型转化</h2><p><strong>问题</strong></p>
<ul>
<li><p>类型范围大的数据或变量，不能直接赋值给类型小的变量</p>
<p><code>数据类型 变量2 = (数据类型)变量1、数据</code></p>
</li>
</ul>
<p>注意事项</p>
<ul>
<li>强制类型转换可能造成数据(丢失)溢出</li>
<li>浮点型强转成整形，直接丢掉小数部分，保留整数部分返回</li>
</ul>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul>
<li>对字面量或者变量进行操作的符号</li>
</ul>
<h2 id="1、算数运算符"><a href="#1、算数运算符" class="headerlink" title="1、算数运算符"></a>1、算数运算符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加</td>
<td>+</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>-</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>X</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>与÷相同，在java中两个整数相除等于整除</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>获取的是两个数据做除法的余数</td>
</tr>
</tbody></table>
<ul>
<li><p>案例</p>
<ul>
<li><p>一个三位数，将其拆分为个位、十位、百位后，打印在控制台</p>
<pre><code class="java">int data = 369;
int a = data %10;
System.out.println(a);
int b = data / 10%10;
System.out.println(b);
int c = data / 100;
System.out.println(c);
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="2、-符号做连接符"><a href="#2、-符号做连接符" class="headerlink" title="2、+符号做连接符"></a>2、+符号做连接符</h2><ul>
<li>符号与字符串运算的时候是用作连接符的，其结果依然是-个字符串。</li>
</ul>
<h2 id="3、自增自减运算符"><a href="#3、自增自减运算符" class="headerlink" title="3、自增自减运算符"></a>3、自增自减运算符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>++</td>
<td>自增</td>
<td>变量自身的值加一</td>
</tr>
<tr>
<td>–</td>
<td>自减</td>
<td>变量自身的值减一</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li><p>++和–即=既可以放在变量的后边，也可以放在变量的前边</p>
</li>
<li><p>++、–只能操作变量，不能操作字面量</p>
</li>
<li><p>++、–如果不是单独使用(如在表达式中、或者同时有其他操作)，放在变量前后会有明显区别</p>
<ul>
<li>如果放在前面，先对变量进行+1、-1，再拿变量的值进行计算</li>
<li>放在变量的后边，先拿变量的值进行运算，在对变量值进行+1、-1</li>
</ul>
</li>
<li><p>案例</p>
<pre><code class="java">int c = 10;
int d = 5;
int r3 = c++ + ++c - --d - ++d + 1 + c--;
System.out.plintln(r3);//23
System.out.plintln(c);11
System.out.plintln(d);5
</code></pre>
</li>
</ul>
<h2 id="4、赋值运算符"><a href="#4、赋值运算符" class="headerlink" title="4、赋值运算符"></a>4、赋值运算符</h2><h3 id="4-1-基本赋值运算符"><a href="#4-1-基本赋值运算符" class="headerlink" title="4.1 基本赋值运算符"></a>4.1 基本赋值运算符</h3><ul>
<li>就是“=”</li>
<li><code>int a = 10;//先看“=”左边，把数值10费左边的变量a存储</code></li>
</ul>
<h3 id="4-2-扩展赋值运算符"><a href="#4-2-扩展赋值运算符" class="headerlink" title="4.2 扩展赋值运算符"></a>4.2 扩展赋值运算符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+=</td>
<td>加后赋值</td>
<td>a+=b等价于a=(a的数据类型)(a+b);将a+b的值给a</td>
</tr>
<tr>
<td>-=</td>
<td>减后赋值</td>
<td>a-=b等价于a=(a的数据类型)(a-b);将a-b的值给a</td>
</tr>
<tr>
<td>*=</td>
<td>乘后赋值</td>
<td>a*=b等价于a=(a的数据类型)(a<em>b);将a</em>b的值给a</td>
</tr>
<tr>
<td>/=</td>
<td>除后赋值</td>
<td>a/=b等价于a=(a的数据类型)(a/b);将a/b的值给a</td>
</tr>
<tr>
<td>%=</td>
<td>取余后赋值</td>
<td>a%=b等价于a=(a的数据类型)(a%b);将a%b的值给a</td>
</tr>
</tbody></table>
<p><em><strong>注意：扩展后的运算符隐含了强制转换的类型</strong></em></p>
<h3 id="4-3-关系运算符"><a href="#4-3-关系运算符" class="headerlink" title="4.3 关系运算符"></a>4.3 关系运算符</h3><ul>
<li>是对符号进行条件判断的符号，最终会返回一个比较的布尔结果(false,true)</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>a==b,判断a与b是否相等，成立为true,不成立为false</td>
</tr>
<tr>
<td>!=</td>
<td>a!=b,判断a与b是否不相等，成立为true,不成立为false</td>
</tr>
<tr>
<td>&gt;</td>
<td>a&gt;b,判断a是否大于b，成立为true,不成立为false</td>
</tr>
<tr>
<td>&gt;=</td>
<td>a&gt;=b,判断a是否大于或等于b，成立为true,不成立为false</td>
</tr>
<tr>
<td>&lt;</td>
<td>a&lt;b,判断a是否小于b，成立为true,不成立为false</td>
</tr>
<tr>
<td>&lt;=</td>
<td>a&lt;=b,判断a是否小于或等于b，成立为true,不成立为false</td>
</tr>
</tbody></table>
<h3 id="4-4逻辑运算符"><a href="#4-4逻辑运算符" class="headerlink" title="4.4逻辑运算符"></a>4.4逻辑运算符</h3><ul>
<li>可以把多个条件的布尔结果放在一起运算，最终返回一个布尔结果</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>介绍</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>逻辑与</td>
<td>必须都是true，结果才是true</td>
</tr>
<tr>
<td>|</td>
<td>逻辑或</td>
<td>只要有一个为true,结果就是true</td>
</tr>
<tr>
<td>！</td>
<td>逻辑非</td>
<td>你真我假，你假我真!true = false、!false = true</td>
</tr>
<tr>
<td>^</td>
<td>逻辑异或</td>
<td>如果两个条件都为false或者都是true结果是false,两个结果不同结果是true</td>
</tr>
</tbody></table>
<ul>
<li><p>短路逻辑运算符</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>介绍</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>短路与</td>
<td>判断结果与&amp;一样，过程是左边为false则右边不执行</td>
</tr>
<tr>
<td>||</td>
<td>短路或</td>
<td>判断结果与|一样，过程是左边为true则右边不执行</td>
</tr>
</tbody></table>
</li>
<li><p>注意</p>
<ul>
<li>逻辑&amp;、逻辑|“无论左边怎么样，右边都要执行</li>
</ul>
</li>
</ul>
<h3 id="4-5三元运算符"><a href="#4-5三元运算符" class="headerlink" title="4.5三元运算符"></a>4.5三元运算符</h3><ul>
<li><p>格式：<code>条件表达式？值1：值2；</code></p>
</li>
<li><p>执行流程：首先计算关系表达式的值，如果为true，返回值1，若为false，返回值2</p>
</li>
<li><p>例子：</p>
<pre><code class="java">double score = 98;
String result = score &gt; 60 ? &quot;及格&quot; : &quot;不及格&quot;;
System.out.println(result);//及格
</code></pre>
</li>
</ul>
<h3 id="4-5-运算优先级"><a href="#4-5-运算优先级" class="headerlink" title="4.5 运算优先级"></a>4.5 运算优先级</h3><ul>
<li><p>在表达式中,哪个运算符先执行后执行是要看优先级的,例如“*、 1”的优先级高于”+、-”。</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>()</td>
</tr>
<tr>
<td>2</td>
<td>! 、- 、++ 、 –</td>
</tr>
<tr>
<td>3</td>
<td>*、/、%</td>
</tr>
<tr>
<td>4</td>
<td>+、-</td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td>
</tr>
<tr>
<td>6</td>
<td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td>
</tr>
<tr>
<td>7</td>
<td>==、！=</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
</tr>
<tr>
<td>13</td>
<td>？：</td>
</tr>
<tr>
<td>14</td>
<td>=、+=、-=、*=、/=、%=、&amp;=</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h1><ul>
<li>流程控制语句<ul>
<li>顺序结构：程序默认流程</li>
<li>分支结构：if、switch</li>
<li>循环结构：for、while、do…while</li>
</ul>
</li>
</ul>
<h2 id="1-分支结构"><a href="#1-分支结构" class="headerlink" title="1 分支结构"></a>1 分支结构</h2><h3 id="1-1-if分支"><a href="#1-1-if分支" class="headerlink" title="1.1 if分支"></a>1.1 if分支</h3><ul>
<li><p>根据判定的结果决定执行某个分支的代码</p>
</li>
<li><p>if分支的作用</p>
</li>
<li><p>if分支有三种格式</p>
<ul>
<li><pre><code class="java">格式1：
if(条件表达式)&#123;
    语句体;
&#125;
</code></pre>
</li>
<li><pre><code class="java">格式2:
if(条件表达式)&#123;
    语句体；
&#125;else&#123;
    语句2;
&#125;
</code></pre>
</li>
<li><pre><code class="java">格式3:
if(条件表达式)&#123;
    语句体1;
&#125;else if(条件表达式2)&#123;
    语句体2;
&#125;else if(条件表达式3)&#123;
    语句体3;
&#125;
...
else&#123;
    语句体n+1;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-switch分支"><a href="#1-2-switch分支" class="headerlink" title="1.2 switch分支"></a>1.2 switch分支</h3><p><strong>也是匹配条件去执行分支，适合做值匹配的分支选择,结构清晰,格式良好。</strong></p>
<pre><code class="java">switch(表达式)&#123;
    case 值1:
        执行代码...;
        break;
    case 值2:
        执行代码...;
        break;
    ...
        case 值n-1:
        执行代码...;
        break;
    default:
        执行代码n;
&#125;
</code></pre>
<p>执行流程:</p>
<ol>
<li>先执行表达式的值，拿着这个值去与case后的值进行匹配。</li>
<li>匹配哪个case的值 为true就执行哪个case，遇到break就跳出switch分 支。</li>
<li>如果case后的值都不匹配则执行default代码。</li>
</ol>
<p>switch分支注意事项:</p>
<ol>
<li>表达式类型只能是byte、short. int、 char, JDK5开始支持枚举，JDK7开始支持String、<br>不支持double、float、 long。</li>
<li>case给出的值不允许重复，且只能是字面量，不能是变量。</li>
<li>不要忘记写break,否则会出现穿透现象。</li>
</ol>
<h2 id="2-循环结构"><a href="#2-循环结构" class="headerlink" title="2 循环结构"></a>2 循环结构</h2><h3 id="2-1-for循环"><a href="#2-1-for循环" class="headerlink" title="2.1 for循环"></a>2.1 for循环</h3><ul>
<li><p>控制一段代码反复执行很多次</p>
<pre><code class="java">格式:
for(初始化语句;循环条件;迭代语句)&#123;
    循环体语句(重复执行的代码);
&#125;
</code></pre>
</li>
</ul>
<h3 id="2-2-while循环"><a href="#2-2-while循环" class="headerlink" title="2.2 while循环"></a>2.2 while循环</h3><pre><code class="java">初始化语句;
while(循环条件)&#123;
    循环体语句(被重复执行的代码);
    迭代语句;
&#125;
</code></pre>
<h3 id="2-3-do…while循环"><a href="#2-3-do…while循环" class="headerlink" title="2.3 do…while循环"></a>2.3 do…while循环</h3><ul>
<li><p>先执行，在判断循环条件</p>
<pre><code class="java">初始化语句:
de&#123;
    循环体语句;
    迭代语句;
&#125;while(循环条件);
</code></pre>
</li>
</ul>
<h3 id="2-4-三中循环的区别"><a href="#2-4-三中循环的区别" class="headerlink" title="2.4 三中循环的区别"></a>2.4 三中循环的区别</h3><ul>
<li>for循环和while循环(先判断后执行)</li>
<li>do…while(第一次先执行后判断)</li>
<li>for和while的区别<ul>
<li>for循环和while循环的执行流程是一模-样的。</li>
<li>如果已知循环次数建议使用for循环，如果不清楚要循环多少次建议使用while循环。</li>
<li>for循环中，控制循环的变量只在循环中可以使用。While循环中，控制循环的变量在循环后还可以继续使用。</li>
</ul>
</li>
</ul>
<h3 id="2-5-死循环"><a href="#2-5-死循环" class="headerlink" title="2.5 死循环"></a>2.5 死循环</h3><ul>
<li><p>一直循环的执行下去，如果没有干预不会停止下来。</p>
<pre><code class="java">while(true)&#123;
    System.out.plintln(&quot;-----------&quot;)
&#125;
</code></pre>
</li>
</ul>
<h3 id="2-6-嵌套循环"><a href="#2-6-嵌套循环" class="headerlink" title="2.6 嵌套循环"></a>2.6 嵌套循环</h3><ul>
<li><p>循环中又包含循环</p>
<pre><code class="java">for(int i = 0;i &lt; 3;i++)&#123;
    for(int j = 0;j &lt; 5;j++)&#123;
        System.out.plintln(&quot;我爱你&quot;)
    &#125;
&#125;
</code></pre>
</li>
<li><p>嵌套循环的特点</p>
<ul>
<li>外部循环每循环一次，内部循环全部执行完一次</li>
</ul>
</li>
</ul>
<h2 id="3跳转关键字"><a href="#3跳转关键字" class="headerlink" title="3跳转关键字"></a>3跳转关键字</h2><ul>
<li>break:用于跳出并结束当前所在的循环执行</li>
<li>countine :用于跳出当前循环的再次执行，进入下一循环</li>
<li>break只能结束所在的循环，或者结束所在switch分支的执行</li>
<li>countine:只能在循环中使用</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li><p>数组就是用来存储一-批同种类型数据的内存区域( 可以理解成容器)</p>
</li>
<li><p>例子</p>
<pre><code class="java">20,10,80,60,90
int[] arr = &#123;20,10,80,60,90&#125;
&quot;牛二&quot;,&quot;西门&quot;,&quot;全蛋&quot;
String[] arr = &#123;&quot;牛二&quot;,&quot;西门&quot;,&quot;全蛋&quot;&#125;
</code></pre>
</li>
</ul>
<h2 id="1-数组的定义"><a href="#1-数组的定义" class="headerlink" title="1.数组的定义"></a>1.数组的定义</h2><h3 id="1-1-静态初始化数组"><a href="#1-1-静态初始化数组" class="headerlink" title="1.1 静态初始化数组"></a>1.1 静态初始化数组</h3><ul>
<li><p>定义数组的时候直接给数组赋值。</p>
</li>
<li><p>静态初始化数组的格式:</p>
<pre><code class="java">//完整格式
数据类型[]数组名 = new 数据类型[]&#123;元素1,元素2，元素3... &#125;;
double[] scores = new double[]&#123;89.9, 99.5, 59.5, 88.0&#125;;
int[] ages = new int[]&#123;1Z， 24, 36&#125;
//简化格式
数据类型[]数组名= &#123;元素1,元素2，元素3, ... &#125;;
int[] ages = &#123;12，24， 36&#125;;
</code></pre>
</li>
<li><p>数组属于引用数据类型，数组变量名中存储的数组在内存中的地址信息。</p>
</li>
</ul>
<h4 id="1-1-1-数组的访问"><a href="#1-1-1-数组的访问" class="headerlink" title="1.1.1 数组的访问"></a>1.1.1 数组的访问</h4><ul>
<li><p>数组名称[索引]</p>
<pre><code class="java">int[] arr = &#123;12,24,36&#125;;
//取值
System . out . println(arr[0]); // 12
//赋值
arr[2] = 100;
System. out。println(arr[2]); // 100
</code></pre>
</li>
<li><p>数组的长度属性：length</p>
<pre><code class="java">//获取数组的长度(就是数组元素的个数)
System. out. println(arr. length); // 3
</code></pre>
</li>
<li><p>数组的最大索引为</p>
<p><code>数组名.length-1//前提：元素个数大于0</code></p>
</li>
</ul>
<h4 id="1-1-2数组的注意事项"><a href="#1-1-2数组的注意事项" class="headerlink" title="1.1.2数组的注意事项"></a>1.1.2数组的注意事项</h4><ul>
<li><code>&#39;数据类型[]数组名&quot;也可以写成&quot;数据类型数组名[]”</code></li>
<li>什么类型的数组存放什么类型的数据，否则报错。</li>
<li>数组- -旦定义出来，程序执行的过程中，长度、类型就固定了。</li>
</ul>
<h3 id="1-2动态初始化数组"><a href="#1-2动态初始化数组" class="headerlink" title="1.2动态初始化数组"></a>1.2动态初始化数组</h3><ul>
<li><p>定义数组的时候只确定元素的类型和数组的长度，之后再存入具体数据。</p>
</li>
<li><p>数组的动态初始化格式:</p>
<pre><code class="java">数据类型[] 数组名= new 数据类型[长度];
int[ ] arr = new int[3];
//后赋值
arr[0] = 10;
System. out. println(arr[0]); // 10
</code></pre>
</li>
</ul>
<h4 id="1-2-1动态初始化数组的元素默认值"><a href="#1-2-1动态初始化数组的元素默认值" class="headerlink" title="1.2.1动态初始化数组的元素默认值"></a>1.2.1动态初始化数组的元素默认值</h4><ul>
<li><p>元素默认值规则</p>
<ul>
<li><p>基本类型</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte  short  int  char  long</td>
<td>0</td>
</tr>
<tr>
<td>float  double</td>
<td>0.0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
</tbody></table>
</li>
<li><p>引用类型</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>类、接口、数组、String</td>
<td>null</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>两种初始化的的使用场景总结、注意事项说明:</p>
<ul>
<li>动态初始化:只指定数组长度，后期赋值,适合开始知道数据的数量，但是不确定具体元素值的业务场景。</li>
<li>静态初始化:开始就存入元素值，适合一开始就能确定元素值的业务场景。</li>
<li>两种格式的写法是独立的严，不可以混用。</li>
</ul>
</li>
</ul>
<h2 id="2-数组的遍历"><a href="#2-数组的遍历" class="headerlink" title="2.数组的遍历"></a>2.数组的遍历</h2><p>数组遍历介绍</p>
<ul>
<li><p>遍历:就是一个一个数据的访问。</p>
</li>
<li><p>为什么要遍历?搜索、数据统计等等都需要用到遍历。</p>
<pre><code class="java">int[] ages = &#123;20， 30，40，50&#125;;
for (int i = 0; i &lt; ages.length; i++) &#123;
System.out.println(ages[i]);
&#125;
//第二种
for(int i:ages)&#123;
    System.out.println(i)
&#125;
</code></pre>
</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul>
<li>方法是- -种语法结构，它可以把一段代码封装成一个功能，以方便重复调用。</li>
<li>使用方法的好处是?<ul>
<li>提高了代码的复用性。</li>
<li>让程序的逻辑更清晰。</li>
</ul>
</li>
</ul>
<h2 id="1方法的定义"><a href="#1方法的定义" class="headerlink" title="1方法的定义"></a>1方法的定义</h2><p>方法定义的完整格式</p>
<pre><code class="java">修饰符返回值类型方法名(形参列表)&#123;
    方法体代码(需要执行的功能代码)
    return返回值;
&#125;
</code></pre>
<h2 id="2方法的调用"><a href="#2方法的调用" class="headerlink" title="2方法的调用"></a>2方法的调用</h2><ul>
<li><p>方法必须调用才可以跑起来，调用格式:<code>方法名(...);</code></p>
</li>
<li><p>注意事项</p>
<ul>
<li>如果方法不需要返回结果，返回值类型必须申明成void ( 无返回值) ,此时方法内部不可以使用return返回数据。</li>
<li>方法如果没有参数,或者返回值类型申明为void可以称为无参数、无返回值的方法,依次类推。</li>
</ul>
</li>
</ul>
<h2 id="3-方法的内存原理"><a href="#3-方法的内存原理" class="headerlink" title="3.方法的内存原理"></a>3.方法的内存原理</h2><p><em><strong>方法的调用流程-内存图解</strong></em></p>
<ul>
<li>方法没有被调用的时候，在方法区中的字节码文件中存放</li>
<li>方法被调用的时候，需要进入到栈内存中运行</li>
</ul>
<h2 id="4-方法的参数传递机制"><a href="#4-方法的参数传递机制" class="headerlink" title="4.方法的参数传递机制"></a>4.方法的参数传递机制</h2><h3 id="4-1-基本类型的参数传递"><a href="#4-1-基本类型的参数传递" class="headerlink" title="4.1 基本类型的参数传递"></a>4.1 基本类型的参数传递</h3><ul>
<li><em><strong>Java的参数传递机制:值传递</strong></em><ul>
<li>在传输实参给方法的形参的时候，并不是俊输实<br>参变量本身，而是传输实参变量中存储的值，这<br>就是值传递。</li>
</ul>
</li>
<li>注意:<ul>
<li>实参:如在方法内部定义的变量。</li>
<li>形参:如在定义方法时， “()”中所声明的参数。</li>
</ul>
</li>
</ul>
<h3 id="4-2-引用类型的参数传递"><a href="#4-2-引用类型的参数传递" class="headerlink" title="4.2 引用类型的参数传递"></a>4.2 引用类型的参数传递</h3><ul>
<li>引用类型的参数传输存储的地址值。<ul>
<li>方法内部访问到改地址，形参修改，实参对应的改地址也会修改，所以实参也会修改</li>
</ul>
</li>
</ul>
<h2 id="5-方法重载"><a href="#5-方法重载" class="headerlink" title="5.方法重载"></a>5.方法重载</h2><ul>
<li>形式<ul>
<li>同一个类中，出现多个方法名称相同,但是形参列表是不同的，那么这些方法就是重载方法。</li>
</ul>
</li>
<li>识别技巧<ul>
<li>只要是同一个类中，方法名称相同、形参列表不同，那么他们就是重载的方法，其他都不管!(如:修饰符，返回值类型都无所谓)</li>
<li>形参列表不同指的是:形参的个数、类型、顺序不同，不关心形参的名称。</li>
</ul>
</li>
</ul>
<h2 id="5-return关键字单独使用"><a href="#5-return关键字单独使用" class="headerlink" title="5.return关键字单独使用"></a>5.return关键字单独使用</h2><ul>
<li>return;—&gt;可以立即跳出并结束当前方法的执行; return关键 字单独使用可以放在任何方法中。</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1-设计对象并使用"><a href="#1-设计对象并使用" class="headerlink" title="1.设计对象并使用"></a>1.设计对象并使用</h2><h3 id="1-1-设计类"><a href="#1-1-设计类" class="headerlink" title="1.1 设计类"></a>1.1 设计类</h3><pre><code class="java">public class 类名&#123;
    1成员变量;
    2成员方法;
    3构造器;
    4代码块;
    5内部类;
&#125;
</code></pre>
<h3 id="1-2得到类的对象"><a href="#1-2得到类的对象" class="headerlink" title="1.2得到类的对象"></a>1.2得到类的对象</h3><pre><code class="java">类名对象名= new类名();
Car C = new Car();
</code></pre>
<h3 id="1-3使用对象"><a href="#1-3使用对象" class="headerlink" title="1.3使用对象"></a>1.3使用对象</h3><pre><code class="java">访问属性:对象名.成员变量
访问行为:对象名.方 法名(...)
</code></pre>
<h2 id="2-定义类的注意事项"><a href="#2-定义类的注意事项" class="headerlink" title="2.定义类的注意事项"></a>2.定义类的注意事项</h2><p>类名首字母建议大写，且有意义，满足“驼峰模式”。</p>
<ul>
<li>一个Java文件中可以定义多个class类,但只能一一个类是public修饰, 而且public修饰的类名必须成为代码文件名。</li>
<li>实际开发中建议还是-一个文件定义-个class类。</li>
<li>成员变量的完整定义格式是:修饰符数据类型变量名称=初始化值; 一般无需指定初始化值,存在默认值。</li>
</ul>
<h2 id="3-对象在内存中的运行机制"><a href="#3-对象在内存中的运行机制" class="headerlink" title="3.对象在内存中的运行机制"></a>3.对象在内存中的运行机制</h2><h3 id="3-1-多个对象的内存图"><a href="#3-1-多个对象的内存图" class="headerlink" title="3.1 多个对象的内存图"></a>3.1 多个对象的内存图</h3><ul>
<li>对象放在堆内存中</li>
<li>类 C = new 类 <ul>
<li>C变量名指的是对象在堆内存中的地址</li>
</ul>
</li>
<li>成员变量的数据放在对象中，存放于堆内存中</li>
</ul>
<h3 id="3-2-两个变量指向同一个对象内存图"><a href="#3-2-两个变量指向同一个对象内存图" class="headerlink" title="3.2 两个变量指向同一个对象内存图"></a>3.2 两个变量指向同一个对象内存图</h3><p>垃圾回收</p>
<ul>
<li>注意:当堆内存中的对象,没有被任何变量引用(指向)时，就会被判定为内存中的“垃圾”。</li>
<li>Java存在自动垃圾回收器，会定期进行清理。</li>
</ul>
<h2 id="4-构造器"><a href="#4-构造器" class="headerlink" title="4.构造器"></a>4.构造器</h2><ul>
<li><p>构造器的作用</p>
<ul>
<li>定义在类中的，可以用于初始化- -个类的对象，并返回对象的地址。</li>
</ul>
</li>
<li><p>调用构造器</p>
<ul>
<li><code>类变量名称= new构造器;</code></li>
</ul>
</li>
<li><p>构造器的格式</p>
<pre><code class="java">修饰符类名(形参列表)&#123;
    ...
&#125;
</code></pre>
</li>
<li><p>构造器的分类和作用</p>
<ul>
<li>无参数构造器( 默认存在的) :初始化对象时，成员变量的数据均采用默认值。</li>
<li>有参数构造器:在初始化对象的时候，同时可以接收参数为对象进行赋值。</li>
</ul>
</li>
</ul>
<h2 id="5-this关键字"><a href="#5-this关键字" class="headerlink" title="5.this关键字"></a>5.this关键字</h2><ul>
<li><p>可以出现在构造器方法中</p>
</li>
<li><p>代表当前对象的地址</p>
</li>
<li><p>可以用于指定访问当前对象的成员变量、成员方法。</p>
</li>
<li><p>this出现在有参数构造器中的用法</p>
<pre><code class="java">public class Car &#123;
    string name;
    double price;
    public Car(string namde, double price)&#123;
    name = name ;
    price = price;
&#125;
</code></pre>
</li>
</ul>
<h2 id="6-封装"><a href="#6-封装" class="headerlink" title="6.封装"></a>6.封装</h2><h3 id="6-1封装思想概述"><a href="#6-1封装思想概述" class="headerlink" title="6.1封装思想概述"></a>6.1封装思想概述</h3><ul>
<li>面向对象三大特征：继承、封装、多态</li>
<li>封装：告诉我们，如何正确设计对象的属性和方法</li>
<li>封装的原则:对象代表什么，就得封装对应的数据，并提供数据对应的行为。</li>
</ul>
<h3 id="6-2如何更好的封装"><a href="#6-2如何更好的封装" class="headerlink" title="6.2如何更好的封装"></a>6.2如何更好的封装</h3><ul>
<li>一般建议对成员变量使用private(私有、隐藏)关键字修饰进( private修饰的成员只能在当前类中访问)。</li>
<li>为每个成员变量提供配套public修饰的的getter. setter方法暴露其取值和赋值。</li>
</ul>
<h2 id="7-标准JavaBean"><a href="#7-标准JavaBean" class="headerlink" title="7.标准JavaBean"></a>7.标准JavaBean</h2><ul>
<li>也可以称为实体类，其对象可以用于在程序中封装数据。</li>
<li>标准JavaBean须满足如下书写要求:<ul>
<li>成员变量使用private修饰。</li>
<li>提供成员变量对应的setXxx() / getXxx()方法。</li>
<li>必须提供一个无参构造器;有参数构造器是可写可不写的。</li>
</ul>
</li>
</ul>
<h2 id="8-成员变量、局部变量的区别"><a href="#8-成员变量、局部变量的区别" class="headerlink" title="8.成员变量、局部变量的区别"></a>8.成员变量、局部变量的区别</h2><table>
<thead>
<tr>
<th>区别</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>类中位置不同</td>
<td>类中，方法外</td>
<td>常用于方法中</td>
</tr>
<tr>
<td>初始化值不同</td>
<td>有默认值，无需初始化</td>
<td>没有默认值，使用前需要赋值</td>
</tr>
<tr>
<td>内存位置不同</td>
<td>堆内存</td>
<td>栈内存</td>
</tr>
<tr>
<td>生命周期不同</td>
<td>随着对象的创建而存在，随着对象的消失而消失</td>
<td>随着方法的调用而调用，随着方法的小时而消失</td>
</tr>
<tr>
<td>作用域</td>
<td></td>
<td>在归属的大括号中</td>
</tr>
</tbody></table>
<h2 id="9-static"><a href="#9-static" class="headerlink" title="9.static"></a>9.static</h2><h3 id="9-1概述"><a href="#9-1概述" class="headerlink" title="9.1概述"></a>9.1概述</h3><ul>
<li><p>tatic是静态的意思， 可以修饰成员变量和成员方法。</p>
</li>
<li><p>tatic修饰成员变量表示该成员变量只在内存中只存储一份,可以被共享访问、修改。</p>
</li>
<li><p>静态成员变量(有static修饰， 属于类，内存中加载一 次) :常表示如在线人数信息、等需要被共享的信息，可以被共享访问。</p>
<ul>
<li><pre><code class="java">类名.静态成员变量。(推荐)
对象.静态成员变量。(不推荐)
</code></pre>
</li>
</ul>
</li>
<li><p>实例成员变量(无static修饰, 存在于每个对象中) :常表示姓名name、年龄age、等属于每个对象的信息。</p>
</li>
</ul>
<h3 id="9-2-static修饰成员变量内存机制"><a href="#9-2-static修饰成员变量内存机制" class="headerlink" title="9.2 static修饰成员变量内存机制"></a>9.2 static修饰成员变量内存机制</h3><p>staic修饰成员变量一个类中只有一个，所有对象共享</p>
<h3 id="9-3-static修饰成员方法"><a href="#9-3-static修饰成员方法" class="headerlink" title="9.3 static修饰成员方法"></a>9.3 static修饰成员方法</h3><p>成员方法的分类</p>
<ul>
<li>静态成员方法(有static修饰， 归属于类) ,建议用类名访问，也可以用对象访问。</li>
<li>实例成员方法(无static修饰， 归属于对象)，只能用对象触发访问。</li>
<li>使用场景<ul>
<li>表示对象自己的行为的，且方法中需要访问实例成员的，则该方法必须申明成实例方法。</li>
<li>如果该方法是以执行一个共用功能为目的，则可以申明成静态方法。</li>
</ul>
</li>
</ul>
<h3 id="9-4-static访问注意事项"><a href="#9-4-static访问注意事项" class="headerlink" title="9.4 static访问注意事项:"></a>9.4 static访问注意事项:</h3><ul>
<li>静态方法只能访问静态的成员，不可以直接访问实例成员。<br>上</li>
<li>实例方法可以访问静态的成员，也可以访问实例成员。</li>
<li>静态方法中是不可以出现this关键字的。</li>
</ul>
<h3 id="9-5工具类"><a href="#9-5工具类" class="headerlink" title="9.5工具类"></a>9.5工具类</h3><ul>
<li>类中都是一些静态方法， 每个方法都是以完成一个共用的功能为目的，这个类用来给系统开发人员共同使用的。</li>
</ul>
<p>案例：在企业的管理系统中，通常需要在一一个 系统的很多业务处使用验证码进行防刷新等安全控制。</p>
<ul>
<li>问题:<ul>
<li>同一个功能多处开发，会出现代码重复度过高。</li>
</ul>
</li>
<li>使用工具类的好处<ul>
<li>一是调用方便，二是提高了代码复用(一次编写，处处可用)</li>
</ul>
</li>
<li>为什么工具类中的方法不用实例方法做?<ul>
<li>实例方法需要创建对象调用。</li>
<li>此时用对象只是为了调用方法，这样只会浪费内存。</li>
</ul>
</li>
<li>工具类定义时的其他要求:<ul>
<li>由于工具里面都是静态方法，直接用类名即可访问，因此，工具类无需创建对象，建议将工具类的构造器进行私有。</li>
</ul>
</li>
</ul>
<h3 id="9-6-代码块"><a href="#9-6-代码块" class="headerlink" title="9.6 代码块"></a>9.6 代码块</h3><ul>
<li><p>代码块概述</p>
<ul>
<li>代码块是类的5大成分之一(成员变量、构造器,方法，代码块，内部类) ,定义在类中方法外。</li>
<li>在Java类下,使用{}括起来的代码被称为代码块。<br>代码块分为</li>
</ul>
</li>
<li><p>静态代码块:</p>
<ul>
<li>格式: static{}<br>特点:需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次</li>
<li>使用场景: 在类加载的时候做- -些静 态数据初始化的操作,以便后续使用。</li>
</ul>
</li>
<li><p>构造代码块(了解，见的少) :</p>
<ul>
<li>格式: {}</li>
<li>特点:每次创建对象，调用构造器执行时，都会执行该代码块中的代码,并且在构造器执行前执行</li>
<li>使用场景:初始化实例资源。</li>
</ul>
</li>
</ul>
<h3 id="9-7单例设计模式"><a href="#9-7单例设计模式" class="headerlink" title="9.7单例设计模式"></a>9.7单例设计模式</h3><p>什么是设计模式(Design pattern)</p>
<ul>
<li>开发中经常遇到- -些问题，- -个问题通常有n种解法的，但其中肯定有-种解法是最优的，这个最优的解法被人总结出<br>来了，称之为设计模式。</li>
<li>设计模式有20多种，对应20多种软件开发中会遇到的问题。</li>
<li>学设计模式主要是学2点:<ol>
<li>这种模式用来解决什么问题。</li>
<li>遇到这种问题了，该模式是怎么写的，他是如何解决这个问题的。</li>
</ol>
</li>
</ul>
<p>单例模式</p>
<ul>
<li>可以保证系统中，应用该模式的这个类永远只有一个实例，即- -个类永远只能创建一个对象。</li>
<li>例如任务管理器对象我们只需要一个就可以解决问题了,这样可以节省内存空间。</li>
</ul>
<p>单例的实现方式很多</p>
<ul>
<li><p>饿汉单例模式。</p>
<ul>
<li><p>在用类获取对象的时候，对象已经提前为你创建好了。</p>
</li>
<li><p>设计模式</p>
<ol>
<li>定义一个类，把构造器私有。</li>
<li>定义一个静态变量存储一一个对象。</li>
</ol>
</li>
<li><pre><code class="java">private Test2()&#123;
    &#125;
public static Test2 test = new Test2();

public static void main(String[] args) &#123;
    Test2 t = Test2.test;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>懒汉单例模式。</p>
<ul>
<li><p>在真正需要该对象的时候，才去创建一 个对象(延迟加载对象)。</p>
</li>
<li><p>设计步骤</p>
<ol>
<li>定义一个类,把构造器私有。</li>
<li>定义一个静态变量存储一个对象。</li>
<li>提供一个返回单例对象的方法</li>
</ol>
</li>
<li><pre><code class="java">private Test2()&#123;
    &#125;
private static Test2 instance ;
public static Test2 getInstance()&#123;
    if (instance == null)&#123;
        instance = new Test2();
    &#125;
    return instance;
&#125;

public static void main(String[] args) &#123;
    Test2 t = Test2.getInstance();
&#125;#
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="10-继承"><a href="#10-继承" class="headerlink" title="10.继承"></a>10.继承</h2><h3 id="10-1概述"><a href="#10-1概述" class="headerlink" title="10.1概述"></a>10.1概述</h3><ul>
<li>Java中提供一个关键字extends, 用这个关键字，我们可以让-个类和另-个类建立起父子关系。</li>
<li><code>public class Student extends People &#123; &#125;</code></li>
<li>Student称为子类( 派生类)，People称为父类(基类 或超类)。</li>
<li>作用:当子类继承父类后，就可以直接使用父类公共的属性和方法了</li>
</ul>
<p>使用继承的好处</p>
<ol>
<li>可以提高代码的复用性</li>
<li>减少代码冗余</li>
<li>增强类的扩展性</li>
</ol>
<p>继承的格式<code>子类 extend 父类</code></p>
<p>继承后子类的特点</p>
<ol>
<li>子类继承父类,子类可以得到父类的属性和行为，子类可以使用。</li>
<li>java中子类更强大</li>
</ol>
<h3 id="10-2继承的设计规范"><a href="#10-2继承的设计规范" class="headerlink" title="10.2继承的设计规范"></a>10.2继承的设计规范</h3><p>继承的设计规范</p>
<ul>
<li>子类们相同特征(共性属性,共性方法)放在父类中定义，子类独有的的属性和行为应该定义在子类自己里面。</li>
<li>如果子类的独有属性、行为定义在父类中,会导致其它子类也会得到这些属性和行为，这不符合面向对象逻辑。</li>
</ul>
<h3 id="10-3-继承的特点"><a href="#10-3-继承的特点" class="headerlink" title="10.3 继承的特点"></a>10.3 继承的特点</h3><ol>
<li>子类可以继承父类的属性和行为,但是子类不能继承父类的构造器。<ol>
<li> 子类有自己的构造器，父类构造器用于初始化父类对象。</li>
<li>子类可以继承父类私有成员，但是不能直接访问。</li>
<li>子类可以直接使用父类静态成员，<u>但不算继承（共享非继承）</u></li>
</ol>
</li>
<li>Java是单继承模式:一个类只能继承一个直接父类。</li>
<li>Java不支持多继承、但是支持多层继承。<ul>
<li>子类A继承父类B，父类B可以继承父类C</li>
</ul>
</li>
<li>Java中 所有的类都是0bject类的子类。<ul>
<li>Java中所有类，要么直接继承了Object,要么默认继承&lt;了Object ,要么间接继承了Object, Object是祖宗类。</li>
</ul>
</li>
</ol>
<h3 id="10-4-继承后，成员变量和成员方法的访问特点"><a href="#10-4-继承后，成员变量和成员方法的访问特点" class="headerlink" title="10.4 继承后，成员变量和成员方法的访问特点"></a>10.4 继承后，成员变量和成员方法的访问特点</h3><p>在子类方法中访问成员(成员变量、成员方法)满足:就近原则</p>
<ul>
<li>先子类局部范围找</li>
<li>然后子类成员范围找</li>
<li>然后父类成员范围找，如果父类范围还没有找到则报错。</li>
</ul>
<p>如果子父类中，出现了重名的成员，会优先使用子类的，此时如果-定要在 子类中使用父类的怎么办?</p>
<ul>
<li>可以通过super关键字，指定访问父类的成员。</li>
</ul>
<h3 id="10-5-继承后，方法重写"><a href="#10-5-继承后，方法重写" class="headerlink" title="10.5 继承后，方法重写"></a>10.5 继承后，方法重写</h3><p>概念</p>
<ul>
<li>在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。</li>
</ul>
<p>应用场景</p>
<ul>
<li>当子类需要父类功能，但父类功能不能完全满足自己需求是时</li>
<li>子类可以重写父类中的方法</li>
</ul>
<p>@Override重写注解</p>
<ul>
<li>@Override是放在重写后的方法上，作为重写是否正确的校验注解。</li>
<li>加上该注解后如果重写错误，编译阶段会出现错误提示。</li>
<li>建议重写方法都加@Override注解，代码安全，优雅!</li>
</ul>
<p>方法重写注意事项和要求</p>
<ul>
<li>重写方法的名称、 形参列表必须与被重写方法的名称和参数列表一致。</li>
<li>私有方法不能被重写。</li>
<li>子类重写父类方法时，访问权限必须大于或者等于父类(暂时 了解:缺省&lt; protected &lt; public)</li>
</ul>
<h3 id="10-6-继承后子类构造器的特点"><a href="#10-6-继承后子类构造器的特点" class="headerlink" title="10.6 继承后子类构造器的特点"></a>10.6 继承后子类构造器的特点</h3><p>子类继承父类后构造器的特点:</p>
<ul>
<li>子类中所有 的构造器默认都会先访问父类中无参的构造器，再执行自己。</li>
<li>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化,子类将无法使用父类的数据。</li>
<li>子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化。</li>
<li>子类构造器的第一行语句默认都是: super(), 不写也存在。</li>
</ul>
<h3 id="10-7-继承后子类构造器访问父类无参构造器"><a href="#10-7-继承后子类构造器访问父类无参构造器" class="headerlink" title="10.7 继承后子类构造器访问父类无参构造器"></a>10.7 继承后子类构造器访问父类无参构造器</h3><p>作用</p>
<ul>
<li>初始化继承自父类的数据。</li>
<li>如果父类中没有无参数构造器，只有有参构造器，会报错。因为子类默认是调用父类无参构造器的。</li>
<li>子类构造器中可以通过书写super(..), 手动调用父类的有参数构造器</li>
</ul>
<h3 id="10-8-this和supper"><a href="#10-8-this和supper" class="headerlink" title="10.8 this和supper"></a>10.8 this和supper</h3><table>
<thead>
<tr>
<th>关键字</th>
<th>访问成员变量</th>
<th>访问成员方法</th>
<th>访问构造方法</th>
</tr>
</thead>
<tbody><tr>
<td>this</td>
<td>this.成员变量<br>访问本类成员变量</td>
<td>this.成员方法<br>访问本类成员方法</td>
<td>this(…)<br>访问本类构造器</td>
</tr>
<tr>
<td>super</td>
<td>super.成员变量<br>访问父类成员变量</td>
<td>super.成员方法<br>访问父类成员方法</td>
<td>super(…)<br>访问父类构造器</td>
</tr>
</tbody></table>
<p>this(..)和super(..)使用注意点:</p>
<ul>
<li>子类通过 this ..去调用本类的其他构造器，本类其他构造器会通过super去手动调用父类的构造器，最终还是会调用父类构造器的。</li>
<li>注意: thi(.. )super(..)都只能放在构造器的第一行,所以二者不能共存在同一-个构造器中。</li>
</ul>
<h2 id="11-抽象类"><a href="#11-抽象类" class="headerlink" title="11.抽象类"></a>11.抽象类</h2><p>概述</p>
<ul>
<li>某个父类知道其所有子类要完成某功能，但是每个子类完成情况都不一样,父类就只定义该功能的基本要求,具体实现由子类完成，这个类就可以是一 个抽象类,抽象类其实就是一 种不完全的设计图。</li>
<li>抽象类必须使用abstract修饰:<ul>
<li><code>修饰符abstract class类名&#123;&#125;</code></li>
</ul>
</li>
</ul>
<p>抽象方法</p>
<ul>
<li>就是抽象类中定义的子类必须完成的功能的基本要求。<ul>
<li><code>修 饰符abstract返回值类型方法名称(形参列表); </code></li>
</ul>
</li>
<li>没有方法体，只有方法签名,必须abstract修饰。</li>
</ul>
<p>抽象的使用总结与注意事项</p>
<ul>
<li>抽象类用来被继承的，抽象方法是交给子类重写实现的。</li>
<li>一个类如果继承了抽象类,那么这个类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。</li>
</ul>
<p>特征</p>
<ul>
<li>有得有失:得到了抽象方法,失去了创建对象的能力。</li>
<li>抽象类不能创建对象。</li>
<li>类有的成员(成员变量、方法、构造器)抽象类都具备</li>
<li>抽象类中不一定有 抽象方法,有抽象方法的类一定是抽象类</li>
<li>一个类继承了抽象类必须重写完抽象类的全部抽象方法,否则这个类也必须定义成抽象类。</li>
<li>不能用abstract修饰变量、代码块、构造器。</li>
<li>final和abstract是什么关系?<ul>
<li>互斥关系</li>
<li>abstract定 义的抽象类作为模板让子类继承, final定义的类不能被继承。</li>
<li>抽象方法定义通用功能让子类重写，final定义的方法子类不能重写。</li>
</ul>
</li>
</ul>
<p>使用场景</p>
<ul>
<li>当系统中出现同一个功能多处在开发，而该功能中大部分代码是一样的，只有其中部分可能不同的时候。</li>
</ul>
<p>使用步骤</p>
<ul>
<li>把功能定义成一个所谓的模板方法,放在抽象类中，模板方法中只定义通用且能确定的代码。</li>
<li>模板方法中不能决定的功能定义成抽象方法让具体子类去实现。</li>
</ul>
<h2 id="12-接口"><a href="#12-接口" class="headerlink" title="12.接口"></a>12.接口</h2><h3 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h3><ul>
<li><p>接口就是体现规范的，其中用抽象方法定义的一-组行为规范，接口是更加彻底的抽象。</p>
</li>
<li><p>体现了现实世界中“如果你是这类事物..则必须完成某些行为”的思想。</p>
</li>
<li><p>接口的格式如下:</p>
<ul>
<li><pre><code class="java">接口用关键字interface来定义
public interface接口名&#123;
    //常量
    //抽象方法
&#125;
</code></pre>
</li>
<li><p>JDK8之前接口中只能是抽象方法和常量，没有其他成分了。</p>
</li>
<li><p>接口不能实例化</p>
</li>
<li><p>接口中的成员都是public修饰的,写不写都是,因为规范的目的是为了公开化。</p>
</li>
</ul>
</li>
</ul>
<p>用法:</p>
<ul>
<li><p>接口是用来被类实现(implements) 的，实现接口的类称为实现类。实现类可以理解成所谓的子类。</p>
<ul>
<li><pre><code class="java">修饰符class实现类implements接口1,接口2,接口....&#123;
&#125;
实现的关键字: implements
</code></pre>
</li>
</ul>
</li>
<li><p>接口可以被类单实现，也可以被类多实现。</p>
</li>
</ul>
<p>JDK8版本开始后，Java只对接口的成员方法进行了新增</p>
<ul>
<li>项目Version2.0需要对Inter接口丰富，加入10个新的抽象方法，此时改了接口就要所有实现类实现这些方法。</li>
<li>允许接口中直接定义带有方法体的方法<ol>
<li>默认方法<ul>
<li>类似之前写的普通实例方法:必须用default修饰</li>
<li>默认会public修饰。 需要用接口的实现类的对象来调用</li>
</ul>
</li>
<li>静态方法<ul>
<li>默认会public修饰， 必须static修饰。</li>
<li>注意:接口的静态方法必须用本身的接口名来调用。</li>
</ul>
</li>
<li>私有方法<ul>
<li>就是私有的实例方法:，必须使用private修饰， 从JDK 1.9才开始有的。</li>
<li>只能在本类中被其他的默认方法或者私有方法访问。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="13-多态"><a href="#13-多态" class="headerlink" title="13.多态"></a>13.多态</h2><h3 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h3><ul>
<li>同类型的对象，执行同一个行为，会表现出不同的行为特征。</li>
</ul>
<p>常见形式</p>
<pre><code class="java">父类类型对象名称= new子类构造器;
接口 对象名称= new实现类构造器; 
</code></pre>
<p>多态中成员访问特点</p>
<ul>
<li>方法调用:编译看左边，运行看右边。</li>
<li>变量调用:编译看左边，运行也看左边。 (多态侧重行为多态)</li>
</ul>
<p>多态的前提</p>
<ul>
<li>有继承/实现关系;有父类引用指向子类对象;有方法重写。</li>
</ul>
<h3 id="13-2-优势"><a href="#13-2-优势" class="headerlink" title="13.2 优势"></a>13.2 优势</h3><ul>
<li><p>王多态形式下，右边对象可以实现解耦合,便于扩展和维护。</p>
<pre><code class="java">Animala = new Dog(;
a.run(); //后续业务行为随对象而变，后续代码无需修改
</code></pre>
</li>
<li><p>定义方法的时候，使用父类型作为参数,该方法就可以接收这父类的一-切子类对象,体现出多态的扩展性与便利。</p>
</li>
<li><p>多态下会产生的一个问题:</p>
<ul>
<li>多态下不能使用子类的独有功能</li>
</ul>
</li>
</ul>
<h3 id="13-3类型转换"><a href="#13-3类型转换" class="headerlink" title="13.3类型转换"></a>13.3类型转换</h3><ul>
<li>自动类型转换(从子到父)<ul>
<li>子类对象赋值给父类类型的变量指向。</li>
</ul>
</li>
<li>强制类型转换吗( 从父到子)<ul>
<li>此时必须进行强制类型转换: 子类对象变量= (子类)父类类型的变量</li>
<li>作用: 可以解决多态下的劣势,可以实现调用子类独有的功能。</li>
<li>注意:<ul>
<li>如果转型后的类型和对象真实类型不是同一种类型,那么在转换的时候就会出现ClassCastException</li>
<li>Java建议强转转换前使用instanceof判断当前对象的真实类型，再进行强制转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="14-内部类"><a href="#14-内部类" class="headerlink" title="14.内部类"></a>14.内部类</h2><h3 id="14-1概述"><a href="#14-1概述" class="headerlink" title="14.1概述"></a>14.1概述</h3><ul>
<li><p>内部类就是定义在一个类里面的类,里面的类可以理解成(寄生) ,外部类可以理解成(宿主)。</p>
<pre><code class="java">public class People&#123;
//内部类
public class Heart&#123;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>内部类的使用场景、作用</p>
<ul>
<li>当一个事物的内部，还有一个部分需要-个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构可以选择使用内部类来设计。</li>
<li>内部类通 常可以方便访问外部类的成员，包括私有的成员。</li>
<li>内部类提供 了更好的封装性，内部类本身就可以用private protectecd等修饰，封装性可以做更多控制。</li>
</ul>
<p>内部类的分类</p>
<ul>
<li>静态内部类[了解]</li>
<li>成员内部类(非静态内部类) [了 解]</li>
<li>局部内部类[了解]</li>
<li>匿名内部类(重点)</li>
</ul>
<h3 id="14-2静态内部类"><a href="#14-2静态内部类" class="headerlink" title="14.2静态内部类"></a>14.2静态内部类</h3><p>概述</p>
<ul>
<li><p>什么是静态内部类?</p>
<ul>
<li><p>有static修饰，属于外部类本身。</p>
</li>
<li><p>它的特点和使用与普通类是完全- -样的，类有的成分它都有,只是位置在别人里面而已。</p>
<pre><code class="java">public class Outer&#123;
//静态成员内部类
public static class Inner&#123;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>静态内部类创建对象的格式:</p>
<pre><code class="java">格式:外部类名.内部类名对象名= new外部类名.内部类构造器;
范例: Outer.Inner in = new Outer.Inner();
</code></pre>
</li>
<li><p>静态内部类可以直接访问外部类的静态成员</p>
</li>
<li><p>静态内部类不可以直接访问外部类的实例成员</p>
</li>
</ul>
<h3 id="14-3-成员内部类"><a href="#14-3-成员内部类" class="headerlink" title="14.3 成员内部类"></a>14.3 成员内部类</h3><p>概述</p>
<ul>
<li><p>无static修饰，属于外部类的对象。</p>
</li>
<li><p>jDK16之前，成员内部类中不能定义静态成员，JDK 16开始也可以定义静态成员了。</p>
<pre><code class="java">public class Outer &#123;
//成员内部类
public class Inner &#123;
    &#125;
&#125;
</code></pre>
</li>
<li><p>成员内部类可以直接访问外部类的静态成员</p>
</li>
<li><p>成员内部类可以直接访问外部类的实例成员</p>
</li>
</ul>
<p>$在成员内部类中访问所在外部类对象,格式:外部类名.this。$</p>
<h3 id="14-4-局部内部类"><a href="#14-4-局部内部类" class="headerlink" title="14.4 局部内部类"></a>14.4 局部内部类</h3><ul>
<li>局部内部类放在方法、代码块、构造器等执行体中。</li>
<li>局部内部类的类文件名为:外部类$N内部类.class。</li>
</ul>
<h3 id="14-5-匿名内部类"><a href="#14-5-匿名内部类" class="headerlink" title="14.5 匿名内部类"></a>14.5 匿名内部类</h3><p>概述</p>
<ul>
<li><p>本质上是一一个没有名字的局部内部类，定义在方法中、代码块中、等。</p>
</li>
<li><p>作用:</p>
<ul>
<li>方便创建子类对象，最终目的为了简化代码编写。</li>
</ul>
</li>
<li><p>格式</p>
<pre><code class="java">new类|抽象类名|或者接口名() &#123;
重写方法;
&#125;;
</code></pre>
</li>
</ul>
<p>特点总结:</p>
<ul>
<li>匿名内部类是一一个没有名字的内部类。</li>
<li>匿名内部类写出来就会产生一个匿名内部类的对象。</li>
<li>匿名内部类的对象类型相当于是当前new的那个的类型的子类类型。</li>
</ul>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="1-String概述"><a href="#1-String概述" class="headerlink" title="1.String概述"></a>1.String概述</h2><ul>
<li>java.lang.String类代表字符串，String类定义的变量可以用于指向字符串对象,然后操作该字符串。</li>
<li>Java程序中的所有字符串文字(例如”abc” )都为此类的对象。</li>
</ul>
<p>String类的特点详解</p>
<ul>
<li>String其实常被称为不可变字符串类型，它的对象在创建后不能被更改。<ul>
<li>String变量每次的修改其实都是产生并指向了新的字符串对象。</li>
<li>原来的字符串对象都是没有改变的，所以称不可变字符串。</li>
</ul>
</li>
</ul>
<h2 id="2-String类创建对象的两种方式"><a href="#2-String类创建对象的两种方式" class="headerlink" title="2.String类创建对象的两种方式"></a>2.String类创建对象的两种方式</h2><ul>
<li><p>方式一：直接使用定义。(推荐方式)</p>
</li>
<li><p>方式二:通过String类的构造器创建对象。</p>
<ul>
<li><table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String()</td>
<td>创建一个空白字符串对象，不含有任何内容</td>
</tr>
<tr>
<td>public String(String original)</td>
<td>根据传入的字符串内容，来创建字符串对象</td>
</tr>
<tr>
<td>public String(char[] chs)</td>
<td>根据字符数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td>public String(byte[] chs)</td>
<td>根据字节数组的内容，来创建字符串对象</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li>以“”方式给出的字符串对象，在字符串常量池中存储，而且相同内容只会在其中存储一份。</li>
<li>通过构造器new对象，每new一次都会产生一个新对象，放在堆内存中。</li>
</ul>
</li>
</ul>
<h2 id="3-String内容比较"><a href="#3-String内容比较" class="headerlink" title="3.String内容比较"></a>3.String内容比较</h2><p>推荐使用String类提供的”equals” 比较:只关心内容一样即可</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean equals (Object anObject)</td>
<td>将此字符串与指定对象进行比较。只关心字符内容是否致!</td>
</tr>
<tr>
<td>public boolean equalsIgnoreCase (String anotherString)</td>
<td>将此字符串与指定对象进行比较，忽略大小写比较字符串。只关心字符内容是否致!</td>
</tr>
</tbody></table>
<h2 id="4-String常用API"><a href="#4-String常用API" class="headerlink" title="4.String常用API"></a>4.String常用API</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int length()</td>
<td>返回此字符串的长度</td>
</tr>
<tr>
<td>public char charAt(int index)</td>
<td>获取某个索引位置处的字符</td>
</tr>
<tr>
<td>public char[] toCharArray():</td>
<td>将当前字符串转换成字符数组返回</td>
</tr>
<tr>
<td>public String substring( int beginIndex, int endIndex)</td>
<td>根据开始和结束索引进行截取，得到新的字符串(包前不包后</td>
</tr>
<tr>
<td>public String substring(int beginIndex)</td>
<td>从传入的索引处截取，截取到末尾，得到新的字符串</td>
</tr>
<tr>
<td>public String replace(CharSequence target,CharSequence replacement )</td>
<td>使用新值，将字符串中的旧值替换，得到新的字符串</td>
</tr>
<tr>
<td>public String[] split(String regex)</td>
<td>根据传入的规则切割字符串，得到字符串数组返回</td>
</tr>
</tbody></table>
<h1 id="ArrayLsit"><a href="#ArrayLsit" class="headerlink" title="ArrayLsit"></a>ArrayLsit</h1><h2 id="1-集合的概述"><a href="#1-集合的概述" class="headerlink" title="1.集合的概述"></a>1.集合的概述</h2><p>集合是与数组类似，也是一种容器，用于装数据的。</p>
<ul>
<li>数组定义完成并启动后,类型确定、长度固定。</li>
<li>问题:在个数不能确定，且要进行增删数据操作的时候，数组是不太合适的。</li>
</ul>
<p>集合的特点</p>
<ul>
<li>集合的大小不固定，启动后可以动态变化，类型也可以选择不固定。</li>
<li>集合非常适合做元素个数不确定，且要进行增删操作的业务场景。</li>
<li>集合的提供了许多丰富、好用的功能，而数组的功能很单一。</li>
</ul>
<h2 id="2-ArrayLsit集合"><a href="#2-ArrayLsit集合" class="headerlink" title="2.ArrayLsit集合"></a>2.ArrayLsit集合</h2><p>ArrayList是集合中的一种,它支持索引。</p>
<ul>
<li><p>ArrayList集合的对象获取</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ArrayList()</td>
<td>创建一个空的集合对象</td>
</tr>
</tbody></table>
</li>
<li><p>ArrayList集合添加元素的方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean add(E e)</td>
<td>将元素追加到此集合的末尾</td>
</tr>
<tr>
<td>public void add(int index,E element)</td>
<td>在此集合中指定位置加入指定的元素</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="3-ArrayLsit对于泛型的支持"><a href="#3-ArrayLsit对于泛型的支持" class="headerlink" title="3.ArrayLsit对于泛型的支持"></a>3.ArrayLsit对于泛型的支持</h2><p>概述</p>
<ul>
<li>ArrayList<E>:其实就是一一个泛型类,可以在编译阶段约束集合对象只能操作某种数据类型。</E></li>
<li>举例<ul>
<li>ArrayList<String> :此集合只能操作字符串类型的元素。</String></li>
<li>ArrayList<Integer>:此集合只能操作整数类型的元素。</Integer></li>
</ul>
</li>
</ul>
<h2 id="4-ArrayLsit常用API"><a href="#4-ArrayLsit常用API" class="headerlink" title="4.ArrayLsit常用API"></a>4.ArrayLsit常用API</h2><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public E get(int index)</td>
<td>返回指定索引处的元素</td>
</tr>
<tr>
<td>public int size()</td>
<td>返回集合中的元素的个数</td>
</tr>
<tr>
<td>public E remove(int index)</td>
<td>删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td>public boolean remove(Object 0)<a href="%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E5%80%BC">^remove</a></td>
<td>删除指定的元素，返回删除是否成功</td>
</tr>
<tr>
<td>public E set(int index,E element)</td>
<td>修改指定索引处的元素，返回被修改的元素</td>
</tr>
</tbody></table>
<h1 id="语法知识"><a href="#语法知识" class="headerlink" title="语法知识"></a>语法知识</h1><h2 id="1-包"><a href="#1-包" class="headerlink" title="1. 包"></a>1. 包</h2><p>概述</p>
<ul>
<li>包是用来分门别类的管理各种不同类的，类似于文件夹、建包利于程序的管理和维护。</li>
<li>建包的语法格式: package 公司域名倒写技术名称。报名建议全部英文小写，且具备意义</li>
<li>建包语句必须在第一行，一般IDEA工具会帮助创建</li>
</ul>
<p>导包</p>
<ul>
<li>相同包下的类可以直接访问，不同包下的类必须导包,才可以使用导包格式: import 包名.类名;</li>
<li>假如一个类中需要用到不同类，而这个两个类的名称是一样的, 那么默认只能导入一个类,另一个类要带包名访问。</li>
</ul>
<h2 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2.权限修饰符"></a>2.权限修饰符</h2><p>概述</p>
<ul>
<li>权限修饰符:是用来控制一-个成员能够被访问的范围的。</li>
<li>可以修饰成员变量、方法、构造器、内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制。</li>
</ul>
<p>权限修饰符的分类和具体作用范围:</p>
<ul>
<li><p>权限修饰符:有四种作用范围由小到大(private -&gt;缺省-&gt; protected - &gt; public )</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th align="center">同一个类中</th>
<th align="center">同一个包其他类</th>
<th align="center">不同包下的子类</th>
<th align="center">不同包下的无关类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>缺省</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td>public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
</li>
</ul>
<p>作用</p>
<ul>
<li>能够识别别人定义的成员的访问权限。</li>
<li>自己定义成员(方法,成员变量,构造器等) 一般满足如下要求:<ul>
<li>成员变量一般私有。</li>
<li>方法一般公开。</li>
<li>如果该成员只希望本类访问，使用private修饰。</li>
<li>如果该成员只希望本类，同一个包下的其他类和子类访问，使用protected修饰。</li>
</ul>
</li>
</ul>
<h2 id="3-final"><a href="#3-final" class="headerlink" title="3.final"></a>3.final</h2><p>作用</p>
<ul>
<li>final关键字是最终的意思，可以修饰(方法，变量，类)</li>
<li>修饰方法:表明该方法是最终方法，不能被重写。</li>
<li>修饰变量:表示该变量第一-次赋值后,不能再次被赋值(有且仅能被赋值一次)。</li>
<li>修饰类:表明该类是最终类,不能被继承。</li>
</ul>
<p>final修饰变量的注意</p>
<ul>
<li>final修饰的变量 是基本类型:那么变量存储的数据值不能发生改变。</li>
<li>final修饰的变量是引用类型:那么变量存储的地址值不能发生改变，但是地址指向的对象内容是可以发生变化的。</li>
</ul>
<h2 id="4-常量"><a href="#4-常量" class="headerlink" title="4.常量"></a>4.常量</h2><p>概述</p>
<ul>
<li>常量是使用了public static final修饰的成员变量,必须有初始化值,而且执行的过程中其值不能被改变。</li>
<li>常量的作用和好处:可以用于做系统的配置信息，方便程序的维护，同时也能提高可读性。</li>
<li>常量命名规范:<ul>
<li>英文单词全部大写，</li>
<li>多个单词下划线连接起来。</li>
</ul>
</li>
</ul>
<p>常量的执行原理</p>
<ul>
<li>在编译阶段会进行“宏替换”，把使用常量的地方全部替换成真实的字面量。</li>
<li>这样做的好处是让使用常量的程序的执行性能与直接使用字面量是一样的。</li>
</ul>
<p>选择常量做信息标志和分类:</p>
<ul>
<li>代码可读性好，实现了软编码形式。</li>
</ul>
<h2 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h2><p>概述</p>
<ul>
<li>枚举是Java中的一种特殊类型</li>
<li>枚举的作用: “是为了做信息的标志和信息的分类”。</li>
</ul>
<p>定义枚举的格式</p>
<pre><code class="java">修饰符enum枚举名称&#123;
第一行都是罗列枚举类实例的名称。
&#125;
</code></pre>
<p>枚举的特征</p>
<ul>
<li>枚举类都是继承了枚举类型: java.lang.Enum</li>
<li>枚举都是最终类，不可以被继承。</li>
<li>枚举的构造器都是私有的，枚举对外不能创建对象。</li>
<li>枚举类的第一行默认都是罗列枚举对象的名称的。</li>
<li>枚举相当于是多例模式</li>
</ul>
<p>枚举做信息标志和分类:</p>
<ul>
<li>代码可读性好，入参约束严谨,代码优雅,是最好的信息分类技术!建议使用!</li>
</ul>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1. Object类"></a>1. Object类</h2><p>0bject类的作用:</p>
<ul>
<li>一个类要么默认继承了0bject类,要么间接继承了Object类, 0bject类 是Java中的祖宗类。</li>
<li>Object类的方法是一切子类都可以直接使用的， 所以我们要学习0bject类的方法。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String toString()</td>
<td>默认是返回当前对象在堆内存中的地址信息:类的全限名@内存地址</td>
</tr>
<tr>
<td>public Boolean equals(Object o)</td>
<td>默认是比较当前对象与另-个对象的地址是否相同，相同返回true,不同返回false</td>
</tr>
</tbody></table>
<p>Objects概述</p>
<ul>
<li>Objects类 与Object还是继承关系，Objects类 是从JDK 1.7开始之后才有的。</li>
<li>Objects的equals方法比较的结果是一样的，但是更安全。</li>
</ul>
<h2 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2. StringBuilder"></a>2. StringBuilder</h2><p>概述</p>
<ul>
<li>StringBuilder是一个可变的字符串类,我们可以把它看成是一个对象容器。</li>
<li>作用:提高字符串的操作效率，如拼接、修改等。</li>
</ul>
<p>构造器</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuilder()</td>
<td>创建一个空白的可变的字符串对象，不包含任何内容</td>
</tr>
<tr>
<td>public StringBuilder()</td>
<td>创建一 个指定字符串内容的可变字符串对象</td>
</tr>
</tbody></table>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuilder append(任意类型)</td>
<td>添加数据并返回StringBuilder对象本身</td>
</tr>
<tr>
<td>public StringBuilder reverse()</td>
<td>将对象的内容反转</td>
</tr>
<tr>
<td>public int length()</td>
<td>返回对象内容长度</td>
</tr>
<tr>
<td>public String toString()</td>
<td>通过toString()就可以实现把StringBuilder转换为String</td>
</tr>
</tbody></table>
<h2 id="3-Math类"><a href="#3-Math类" class="headerlink" title="3.Math类"></a>3.Math类</h2><ul>
<li><p>包含执行基本数字运算的方法, Math类没有提供公开的构造器。</p>
</li>
<li><p>类的成员都是静态的，用类名就可以直接访问</p>
</li>
<li><p>常用方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static int abs(int a)</td>
<td>获取参数绝对值</td>
</tr>
<tr>
<td>public static double ceil(double a)</td>
<td>向上取整</td>
</tr>
<tr>
<td>public static double floor(double a)public static double floor(double a)</td>
<td>向下取整</td>
</tr>
<tr>
<td>public static int round(float a)</td>
<td>四舍五入</td>
</tr>
<tr>
<td>public static int max(int a,int b)</td>
<td>获取两个int值中的较大值</td>
</tr>
<tr>
<td>public static double pow(double a,double b)</td>
<td>返回a的b次幂的值</td>
</tr>
<tr>
<td>public static double randpm()</td>
<td>返回值为double的随机值，范围[0.0,1.0)</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="4-System"><a href="#4-System" class="headerlink" title="4. System"></a>4. System</h2><p>概述</p>
<ul>
<li>System的功能是通用的，都是直接用类名调用即可，所以System不能被实例化。</li>
</ul>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static void exit(int status)</td>
<td>终止当前运行的Java虚拟机，非<br>零表示异常终止</td>
</tr>
<tr>
<td>public static long currentTimeMillis()</td>
<td>返回当前系统的时间毫秒值形式</td>
</tr>
<tr>
<td>public static void arraycopy(数据源数组，<br>起始索引,目的地数组,起始索引,拷贝个数)数组拷贝</td>
<td>数组拷 贝</td>
</tr>
</tbody></table>
<p>时间毫秒值</p>
<ul>
<li>计算机认为时间是有起点的，起始时间: 1970年1月1日 00:00:00</li>
<li>时间毫秒值:指的是从1970年1月1日 00:00:00走到此刻的总的毫秒数,应该是很大的。1s = 1000ms。</li>
</ul>
<p>原因:</p>
<ul>
<li>1969年8月，贝尔实验室的程序员肯汤普逊利用妻儿离开- -个月的机会，开始着手创造一一个全新的革命性的操作系统，他使用B编译语言在老旧的PDP-7机器上开发出了Unix的一个版本。随后，汤普逊和同事丹尼斯里奇改进了B语言,开发出了C语言,重写了UNIX。</li>
</ul>
<h2 id="5-BigDecimal"><a href="#5-BigDecimal" class="headerlink" title="5.BigDecimal"></a>5.BigDecimal</h2><p>作用</p>
<ul>
<li>用于解决浮点型运算精度失真的问题<ul>
<li><code>public static BigDecimal value0f(double val):包装浮 点数成为BigDecimal对象。</code></li>
</ul>
</li>
</ul>
<p>常用API</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BigDecimal add(BigDecimal b)</td>
<td>加法</td>
</tr>
<tr>
<td>public BigDecimal subtract(BigDecimal b)</td>
<td>减法</td>
</tr>
<tr>
<td>public BigDecimal multiply(BigDecimal b)</td>
<td>乘法</td>
</tr>
<tr>
<td>public BigDecimal divide(BigDecimal b)</td>
<td>除法</td>
</tr>
<tr>
<td>public BigDecimal divide (另一个BigDecimal对象， 精确几位，舍入模式)</td>
<td>除法</td>
</tr>
</tbody></table>
<h1 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h1><h2 id="1-Date"><a href="#1-Date" class="headerlink" title="1.Date"></a>1.Date</h2><p>概述</p>
<ul>
<li>Date类的对象在Java中代表的是当前所在系统的此刻日期时间。</li>
</ul>
<p>构造器</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Date()</td>
<td>创建一个Date对象，代表的是系统当前此刻日期时间。</td>
</tr>
</tbody></table>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public long getTime()</td>
<td>获取时间对象的毫秒值</td>
</tr>
</tbody></table>
<p>Date类记录时间的2种形式</p>
<ol>
<li><p>日期对象</p>
<pre><code class="java">// 1、创建一个日期对象代表了:当前系统的此刻日期时间对象
Date d = new Date();
System. out . println(d);
</code></pre>
</li>
<li><p>时间毫秒值</p>
<ul>
<li><p>指的是从1970年1月1日00:00:00走 到此刻的总的毫秒数,应该是很大的</p>
<pre><code class="java">// 2、获取当前时间毫秒值
long time
= d.getTime();
System. out . println(time) ;
</code></pre>
</li>
</ul>
</li>
<li><p>时间毫秒值-&gt;日期对象</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>构造器</td>
<td>public Date(long time)</td>
<td>把时间毫秒值转换成Date日期对象。</td>
</tr>
<tr>
<td>方法</td>
<td>public void setTime(long time)</td>
<td>设置日期对象的时间为当前时间毫秒值对应的时间</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="2-SimpleDateFormat"><a href="#2-SimpleDateFormat" class="headerlink" title="2. SimpleDateFormat"></a>2. SimpleDateFormat</h2><p>作用</p>
<ul>
<li>可以对Date对象或时间毫秒值格式化成我们喜欢的时间形式。</li>
<li>也可以把字符串的时间形式解析成日期对象。</li>
</ul>
<p>构造器</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public SimpleDateFormat()</td>
<td>构造一-个SimpleDateFormat,使用默认格式</td>
</tr>
<tr>
<td>public simpleDateFormat(String pattern)</td>
<td>构造一个SimpleDateFormat,使用指定的格式</td>
</tr>
</tbody></table>
<p>方法</p>
<table>
<thead>
<tr>
<th>格式化方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public final String format(Date date)</td>
<td>将日期格式化成日期/时间字符串</td>
</tr>
<tr>
<td>public final String format(Object time)</td>
<td>将时间毫秒值式化成日期/时间字符串</td>
</tr>
</tbody></table>
<p>格式化的时间形式的常用的模式对应关系如下:</p>
<table>
<thead>
<tr>
<th>y</th>
<th>年</th>
</tr>
</thead>
<tbody><tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<p>解析字符串时间成为日期对象</p>
<table>
<thead>
<tr>
<th>解析方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Date parse(String source)</td>
<td>从给指定字符串的开始解析文本以生成时间</td>
</tr>
</tbody></table>
<h2 id="3-Calendar"><a href="#3-Calendar" class="headerlink" title="3. Calendar"></a>3. Calendar</h2><p>概述</p>
<ul>
<li>Calendar代表 了系统此刻日期对应的日历对象。</li>
<li>Calendar是- 一个抽象类,不能直接创建对象。</li>
</ul>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int get(int field)</td>
<td>取日期中的某个字段信息。</td>
</tr>
<tr>
<td>public void set(int field,int value)</td>
<td>修改日历的某个字段信息。</td>
</tr>
<tr>
<td>public void add(int field, int amount)</td>
<td>为某个字段增加/减少指定的值</td>
</tr>
<tr>
<td>public final Date getTime()</td>
<td>拿到此刻日期对象。</td>
</tr>
<tr>
<td>public long getTimeInMillis()</td>
<td>拿到此刻时间毫秒值</td>
</tr>
</tbody></table>
<h2 id="4-新增日期类"><a href="#4-新增日期类" class="headerlink" title="4.新增日期类"></a>4.新增日期类</h2><p>概述</p>
<ul>
<li>从ava 8开始，java.time包提供 了新的日期和时间API,主要涉及的类型有:<ol>
<li>LocalDate:不包含具体时间的日期。</li>
<li>LocalTime:不含日期的时间。</li>
<li>LocalDateTime:包含了日期及时间。</li>
<li>Instant:代表的是时间戳。</li>
<li>DateTimeFormatter用于做时间的格式化和解析的</li>
<li>Duration:用于计算两个“时间”间隔</li>
<li>Period:用于计算两个“日期”间隔</li>
</ol>
</li>
<li>新增的API严格区分了时刻、本地日期、本地时间,并且,对日期和时间进行运算更加方便。</li>
<li>其次，新API的类型几乎全部是不变类型(和String的使用类似)，可以放心使用不必担心被修改。</li>
</ul>
<h3 id="4-1LocalDate、LocalTime、LocalDateTime"><a href="#4-1LocalDate、LocalTime、LocalDateTime" class="headerlink" title="4.1LocalDate、LocalTime、LocalDateTime"></a>4.1LocalDate、LocalTime、LocalDateTime</h3><ul>
<li>他们分别表示日期，时间，日期时间对象,他们的类的实例是不可变的对象。</li>
<li>他们三者构建对象和API都是通用的</li>
<li>构建对象方式</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>public static Xxxx.now();</td>
<td>静态方法，根据当前时间创建对象</td>
<td>LocaDate localDate = LocalDate.now();<br>LocalTime llocalTime = LocalTime.nom();<br>LocalDateTime localDateTime = LocalDateTime.nom();</td>
</tr>
<tr>
<td>public static Xxx.Of(..);</td>
<td>静态方法，指定日期/时间创建对象</td>
<td>LocalDate localDate1 = LocalDate. of(2099，11,11);<br> LocalTime localTime1 = LocalTime.of11, 11, 11);<br>LocalDateTime localDateTime1 = LocalDateTime.of(2020, 10, 6, 13,,22,43);</td>
</tr>
</tbody></table>
<p>LocalDateTime的转换API</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public LocalDate toLocalDate()</td>
<td>转换成一个LocalDate对象</td>
</tr>
<tr>
<td>public LocalTime toLocalTime()</td>
<td>转换成一个LocalTime对象</td>
</tr>
</tbody></table>
<p>修改相关的API</p>
<ul>
<li>LocalDateTime综合了LocalDate和LocalTime里面的方法，所以下面只用LocalDate和LocalTime来举例。</li>
<li>●这些方法返回的是- -个新的实例引用，因为LocalDateTime 、LocalDate 、LocalTime 都是不可变的。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>plusDays, plusWeeks, plusMonths, plusYears</td>
<td>向当前LocalDate对象添加几天、几周、几个月、几年</td>
</tr>
<tr>
<td>minusDays, minusWeeks, minusMonths, minusYears</td>
<td>从当前LocalDate对象减去几天、几周、几个月、几年</td>
</tr>
<tr>
<td>withDayOfMonth, withDayOfYear, withMonth, withYear</td>
<td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的</td>
</tr>
<tr>
<td>isBefore, isAfter</td>
<td>比较两个LocalDate</td>
</tr>
</tbody></table>
<h3 id="4-2-Instant时间戳"><a href="#4-2-Instant时间戳" class="headerlink" title="4.2 Instant时间戳"></a>4.2 Instant时间戳</h3><p>概述</p>
<ul>
<li>JDK8获取时间戳特别简单，且功能更丰富。Instant类由一 -个静态的工厂方法now()可以返回当前时间戳。</li>
<li>时间戳是包含日期和时间的，与java.util.Date很类似， 事实上Instant就是类似JDK8以前的Date。</li>
<li>Instant和Date这两个类可以进行转换。</li>
</ul>
<h3 id="4-3DateTimeFormatter"><a href="#4-3DateTimeFormatter" class="headerlink" title="4.3DateTimeFormatter"></a>4.3DateTimeFormatter</h3><ul>
<li>在JDK8中， 引入了一个全新的日期与时间格式器DateTimeFormatter.</li>
<li>正反都能调用format方法。</li>
</ul>
<pre><code class="java">LocalDateTime ldt = LocalDateTime . now( );
System.out.println(ldt);//2021-03-01T15:09:17.444190900
DateTimeFormatter dtf = DateTimeFormatter . ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
String ldtStr = ldt.format(dtf);
System. out. println(1dtStr);//2021-03-01 15:09:17
String ldtStr1 = dtf format (ldt);
System.out.println(ldtStr1);//2021-03-01 15:09:17
</code></pre>
<h3 id="4-4-Period"><a href="#4-4-Period" class="headerlink" title="4.4 Period"></a>4.4 Period</h3><ul>
<li><p>在Java8中, 我们可以使用以下类来计算8期间隔差异: java.time.Period</p>
</li>
<li><p>主要是Period类方法getYears(), getMonths() 和getDays()来计算,只能精确到年月日。</p>
</li>
<li><p>用于LocalDate之间的比较。</p>
</li>
<li><pre><code class="java">LocalDate today = LocalDate.now();
System.out.println(today);
// 2021-03-01
LocalDate birthDate = LocalDate.of(1995， 1, 11);
System.out.println(birthDate); // 1995-01-11
Period period = Period.between(birthDate, today); 
System.out.printf(&quot;年龄: %d年%d月%d日&quot;,period.getYears(),period. getMonths(),
period.getDays()) ;
</code></pre>
</li>
</ul>
<h3 id="4-5-Duration"><a href="#4-5-Duration" class="headerlink" title="4.5 Duration"></a>4.5 Duration</h3><ul>
<li>在Java8中， 我们可以使用以下类来计算时间间隔差异: java.time.Duration</li>
<li>提供了使用基于时间的值测量时间量的方法。</li>
<li>用于LocalDateTime之间的比较。也可用于Instant之间的比较。</li>
</ul>
<pre><code class="java">LocalDateTime today = LocalDateTime.now();
System.out.println(today);
I
LocalDateTime birthDate = LocalDateTime.of(1990,10,1,10,50,30);
System.out.println(birthDate);
Duration duration = Duration.between(birthDate,today);//第二 个参数减第一个参数
System.out.println(duration.toDays());//两个时间差的天数
System.out.println(duration.toHours());//两个时间差的小时数
System.out.println(duration.toMinutes());//两个时间差的分钟数
System.out.println(duration.toMillis());//两个时间差的毫秒数
System.out.println(duration.toNanos());//两个时间差的纳秒数
</code></pre>
<h3 id="4-6ChronoUnit"><a href="#4-6ChronoUnit" class="headerlink" title="4.6ChronoUnit"></a>4.6ChronoUnit</h3><ul>
<li>ChronoUnit类可用于在单个时间单位内测量-段时间， 这个工具类是最全的了，可以用于比较所有的时间单位</li>
</ul>
<pre><code class="java">LocalDateTime today = LocalDateTime.now();
System.out.println(today);
LocalDateTime birthDate = LocalDateTime.of(1990,10,1,10,50,30);
System.out.println(birthDate);
System.out.println(“相差的年数:”+ ChronoUnit.YEARS.between(birthDate, today)); 
System.out.println(&quot;相差的月数:”+ ChronoUnit.MONTHS.between(birthDate, today));
System.out.println(&quot;相差的周数:”+ChronoUnit.WEEKS.between(birthDate, today));
System.out.println(“相差的天数:”+ ChronoUnit.DAYS.between(birthDate, today));
System.out.println(&quot;相差的时数:”+ChronoUnit.HOURS.between(birthDate, today));
System.out.println(&quot;相差的分数:”+ChronoUnit.MINUTES.between(birthDate, today));
System.out.print1n(&quot;相差的秒数:”+ChronoUnit.SECONDS.between(birthDate, today));
System.out.print1n(&quot;相差的毫秒数:”+ChronoUnit.MILLIS.between(birthDate, today));
System.out.println(“相差的微秒数:”+ChronoUnit.MICROS.between(birthDate, today));
System.out.println(“相差的纺秒数:”+ ChronoUnit.NANOS.between(birthDate, today));
System.out.println(“相差的半天数:”+ChronoUnit.HALFDAYS.between(birthDate, today)); 
System.out.println(&quot;相差的十年数:”+ChronoUnit.DECADES.between(birthDate, today));
System.out.println(*相差的世纪(百年)数:”+ChronoUnit.CENTURIES. between(birthDate, today));
System.out.println(&quot;相差的千年数:”+ChronoUnit.MILLENNIA.between(birthDate, today));
System.out.print1n(&quot;相差的纪元数:”+ ChronoUnit.ERAS.between(birthDate, today));
</code></pre>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>概述</p>
<ul>
<li>其实就是8种基本数据类型对应的引用类型。</li>
</ul>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>引用数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>char</td>
<td>Charal[;ter</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<ul>
<li><p>Java为了实现一切皆对象，为8种基本类型提供了对应的引用类型。</p>
</li>
<li><p>后面的集合和泛型其实也只能支持包装类型不支持基本数据类型。</p>
</li>
<li><p>自动装箱:基本类型的数据和变量可以直接赋值给包装类型的变量。</p>
</li>
<li><p>自动拆箱:包装类型的变量可以直接赋值给基本数据类型的变量。</p>
</li>
</ul>
<p>包装类的特有功能</p>
<ul>
<li><p>包装类的变量的默认值可以是null,容错率更高。</p>
</li>
<li><p>可以把基本类型的数据转换成字符串类型(用处不大)</p>
<pre><code class="java">调用toString()方法得到字符串结果。
调用Integer.toString(基本类型的数据)。
</code></pre>
</li>
<li><p>可以把字符串类型的数值转换成真实的数据类型(真的很有用)</p>
<pre><code class="java">Integer.parselnt(“字符串类型的整数”)
Double.parseDouble(“字符串类型的小数”)。
</code></pre>
</li>
</ul>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul>
<li>正则表达式可以用一些规定的字符来制定规则，并用来校验数据格式的合法性。</li>
</ul>
<h3 id="2-匹配规则"><a href="#2-匹配规则" class="headerlink" title="2.匹配规则"></a>2.匹配规则</h3><ol>
<li><p>字符类</p>
<pre><code class="java">[abc]            只能是a, b,或c
[^abc]            除了a, b, c之外的任何字符
[a-ZA-Z]        a到z A到Z,包括(范围) 
[a-d[m-p]]        a到d,或m通过p: ([a-dm-p]联合)
[a-z&amp;&amp;[def]        d, e,或f(交集)
[a-z&amp;&amp;[^bc]]    a到z，除了b和C: ([ad-z]减法 )
[a-z&amp;&amp;[^m- p]]    a到z，除了m到p: ([a-lq-z]减法 )
</code></pre>
</li>
<li><p>预定义字符类</p>
<pre><code class="java">.        任何字符
\d        一个数字: [0-9]k
\D        非数字: [^0-9]
\s        一个空白字符: [ \t\n\x0B\f\r]
\S        非空白字符: [^\s]
\w        [a-zA-Z_ _0-9]英文、数字、下划线
\W        [^\w]一个非单词字符
</code></pre>
</li>
<li><p>贪婪的量词</p>
<pre><code class="java">X?            X,一次或根本不
X*            X，零次或多次
X+            X,一次或多次
X &#123;n&#125;        X，正好n次
X&#123;n,&#125;        X，至少n次
X &#123;n,m&#125;     X至少n但不超过m次
</code></pre>
</li>
<li><p>字符串对象提供了匹配正则表达式规则的API</p>
<p><code>public boolean matches (String regex): 判断是否匹配正则表达式，匹配返回true,不匹配返回false。</code></p>
</li>
</ol>
<p>正则表达式支持爬取信息</p>
<pre><code class="java">String rs =“来黑马程序学习Java,电话020- 43422424，或者联系邮箱”+
&quot;itcast@itcast .cn,电话18762832633，0203232323&quot; +
&quot;邮箱bozai@itcast.cn.400- 100-3233，4001003232&quot; ;
//需求:从上面的内容中爬取出电话号码和邮箱。
// 1. 定义爬取规则
String regex = &quot;(\w&#123;1,&#125;@\W&#123;2,10&#125;(\.\\w&#123;2,10&#125;)&#123;1,2&#125;)1&quot;
&quot;(1[3-9]\\d&#123;9&#125;)|(0\\d&#123;2,5&#125;-?\\d&#123;5,15&#125;)|400-?\\d&#123;3,8&#125;-?\\d&#123;3,8&#125;&quot;;
// 2. 编泽正则表达式成为- - 个四配规则对象
Pattern pattern = Pattern.compile(regex);
// 3.通过四配规则对象得到一- 个匹配数据内容的匹配器对象
Matcher matcher = pattern.matcher(rs);
// 4.通过匹配器去内容中爬取出信息
while(matcher.find())&#123;
System.out.print1n(matcher.group());
</code></pre>
<h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h2><p>数组操作工具类，专门用于操作数组元素的。</p>
<h2 id="2-常用API"><a href="#2-常用API" class="headerlink" title="2. 常用API"></a>2. 常用API</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static String toString(类型[ a)</td>
<td>打印数组</td>
</tr>
<tr>
<td>public static void sort(类型] a)</td>
<td>对数组进行默认升序排序</td>
</tr>
<tr>
<td>public static <T> void sort(类型[ a, Comparator&lt;? superT&gt;c)</T></td>
<td>使用 比较器对象自定义排序</td>
</tr>
<tr>
<td>public static int binarySearch(int[] a, int key)</td>
<td>二分搜索数组中的数据，存在返回索引，不存在返回-1</td>
</tr>
</tbody></table>
<h2 id="3-比较器"><a href="#3-比较器" class="headerlink" title="3.比较器"></a>3.比较器</h2><p>设置Comparator接口对应的比较器对象，来定制比较规则。</p>
<pre><code class="java">如果认为左边数据大于右边数据返回正整数
如果认为左边数据小于右边数据返回负整数
如果认为左边数据等于右边数据返回0
</code></pre>
<h2 id="4-Lanbda表达式"><a href="#4-Lanbda表达式" class="headerlink" title="4.Lanbda表达式"></a>4.Lanbda表达式</h2><p>概述</p>
<ul>
<li>Lambda表达式是JDK 8开始后的一种新语法形式。</li>
<li>作用:简化匿名内部类的代码写法。</li>
</ul>
<p>格式</p>
<pre><code class="java">(匿名内部类被重写方法的形参列表) -&gt; &#123;
被重写方法的方法体代码。
&#125;
注: -&gt;是语法形式，无实际含义
</code></pre>
<p>注意: </p>
<ul>
<li>Lambda表达式只能简化函数式接口的匿名内部类的写法形式</li>
<li>首先必须是接口、其次接口中有且仅有一个抽象方法的形式</li>
<li>通常我们会在接口上加上一个@FunctionalInterface注解，标记该接口必须是满足函数式接口。</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h2><p>集合和数组都是容器</p>
<p>数组</p>
<ul>
<li>数组定义完成并启动后，类型确定、长度固定。</li>
<li>在进行增删数据操作的时候，数组是不太合适的，增删数据都需要放弃原有数组或者移位。</li>
<li>适用场景<ul>
<li>当业务数据的个数是固定的，且都是同一批数据类型的时候，可以采取定义数组存储。</li>
</ul>
</li>
</ul>
<p>集合</p>
<ul>
<li>集合是Java中存储对象数据的一种容器。</li>
<li>集合的大小不固定，启动后可以动态变化，类型也可以选择不固定。集合更像气球。</li>
<li>集合非常适合做元素的增删操作。</li>
<li>集合中只能存储引用类型数据，如果要存储基本类型数据可以选用包装类。</li>
<li>适用场景<ul>
<li>数据的个数不确定，需要进行增删元素的时候。</li>
</ul>
</li>
</ul>
<h2 id="2-体系特点"><a href="#2-体系特点" class="headerlink" title="2.体系特点"></a>2.体系特点</h2><p>集合体系结构</p>
<ul>
<li>Collection 单例<a href="%E5%8D%95%E4%BE%8B%E9%9B%86%E5%90%88%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0(%E6%95%B0%E6%8D%AE)%E5%8F%AA%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E5%80%BC">^collection</a></li>
<li>Map双例<a href="%E5%8F%8C%E4%BE%8B%E9%9B%86%E5%90%88%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AA%E5%80%BC(%E9%94%AE%E5%80%BC%E5%AF%B9)">^map</a></li>
</ul>
<pre><code class="mermaid">graph TB
A(Collection)==&gt;B(List)
A==&gt;C(Set)
B==&gt;D([ArrayList])
B==&gt;E([LinkedList])
C==&gt;F([HashSet])
C==&gt;G([TreeSet])
F==&gt;I([LinkedHashSET])
J(接口)
K([实现类])
</code></pre>
<ul>
<li>List系列集合特点<ul>
<li>添加元素是有序、可重复、有索引</li>
<li>ArrayList、LinekdList :有序、可重复、有索引。</li>
</ul>
</li>
<li>Set系列集合:添加的元素是无序、不重复、无索引。<ul>
<li>HashSet:无序、不重复、无索引; LinkedHashSet: 有序、不重复、无索引。</li>
<li>TreeSet:按照大小默认升序排序、不重复、无索引</li>
</ul>
</li>
</ul>
<p><strong>集合都是支持泛型的，可以在编译阶段约束集合只能操作某种数据类型</strong></p>
<pre><code class="java">Collection&lt;String&gt; lists = new ArrayList&lt;String&gt;();
Collection&lt;String&gt; lists = new ArrayList&lt;&gt;(); // JDK 1. 7开始后面的泛型类型申明可以省略不写
</code></pre>
<p><strong>注意:集合和泛型都只能支持引用数据类型，不支持基本数据类型，所以集合中存储的元素都认为是对象。</strong></p>
<h2 id="3-常用API"><a href="#3-常用API" class="headerlink" title="3. 常用API"></a>3. 常用API</h2><p>Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean add(E e)</td>
<td>把给定的对象添加到当前集合中</td>
</tr>
<tr>
<td>public void clear()</td>
<td>清空集合中所有的元素</td>
</tr>
<tr>
<td>public boolean remove(E e)</td>
<td>把给定的对象在当前集合中删除</td>
</tr>
<tr>
<td>public boolean contains(Object obj)</td>
<td>判断当前集合中是否包含给定的对象</td>
</tr>
<tr>
<td>public boolean isEmpty()</td>
<td>判断当前集合是否为空</td>
</tr>
<tr>
<td>public int size()</td>
<td>返回集合中元素的个数。</td>
</tr>
<tr>
<td>public Object[] toArray()</td>
<td>把集合中的元素，存储到数组中</td>
</tr>
</tbody></table>
<h2 id="4-遍历"><a href="#4-遍历" class="headerlink" title="4.遍历"></a>4.遍历</h2><h3 id="4-1-迭代器"><a href="#4-1-迭代器" class="headerlink" title="4.1 迭代器"></a>4.1 迭代器</h3><p>概述</p>
<ul>
<li>遍历就是一个一个的把容器中的元素访问一-遍。</li>
<li>迭代器在Java中的代表是Iterator,迭代器是集合的专用遍历方式。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Iterator<E> iterator()</E></td>
<td>返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引</td>
</tr>
<tr>
<td>boolean hasNext()</td>
<td>询问当前位置是否有元素存在，存在返回true ,不存在返回false</td>
</tr>
<tr>
<td>E next()</td>
<td>获取当前位置的元素,并同时将迭代器对象移向下一一个位置，注意防止取出越界。</td>
</tr>
</tbody></table>
<h3 id="4-2-foreach循环"><a href="#4-2-foreach循环" class="headerlink" title="4.2 foreach循环"></a>4.2 foreach循环</h3><p>概述</p>
<ul>
<li>增强for循环:既可以遍历集合也可以遍历数组。</li>
<li>它是JDK5之后出现的，其内部原理是一个Iterator迭代器，遍历集合相当于是迭代器的简化写法。</li>
</ul>
<p>格式</p>
<pre><code class="java">for(元素数据类型变量名: 数组或者Collection集合) &#123;
//在此处使用变量即可，该变量就是元素
&#125;
</code></pre>
<h3 id="4-3-Lambda"><a href="#4-3-Lambda" class="headerlink" title="4.3 Lambda"></a>4.3 Lambda</h3><ul>
<li>得益于JDK 8开始的新技术Lambda表达式，提供了-种更简单、更直接的遍历集合的方式。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>default void forEach(Consumer&lt;? super T&gt; action):</td>
<td>结合lambda遍历集合</td>
</tr>
</tbody></table>
<h2 id="5-常见数据结构"><a href="#5-常见数据结构" class="headerlink" title="5.常见数据结构"></a>5.常见数据结构</h2><p>概述</p>
<ul>
<li>数据结构是计算机底层存储、组织数据的方式。是指数据相互之间是以什么方式排列在一起的。</li>
<li>通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率</li>
</ul>
<ol>
<li>栈数据结构的执行特点<ul>
<li>后进先出，先进后出</li>
</ul>
</li>
<li>常见数据结构之队列<ul>
<li>先进先出，后进后出</li>
</ul>
</li>
<li>数组<ul>
<li>查询速度快:查询数据通过地址值和索引定位，查询任意数据耗时相同。(元素 在内存中是连续存储的)</li>
<li>删除效率低:要将原始数据删除，同时后面每个数据前移。</li>
<li>添加效率极低:添加位置后的每个数据后移，再添加元素。</li>
</ul>
</li>
<li>链表<ul>
<li>链表中的元素是在内存中不连续存储的，每个元素节点包含数据值和下一个元素的地址。</li>
<li>链表查询慢。无论查询哪个数据都要从头开始找</li>
<li>链表增删相对快</li>
</ul>
</li>
</ol>
<h2 id="6-二叉树"><a href="#6-二叉树" class="headerlink" title="6.二叉树"></a>6.二叉树</h2><p><img src="/.com//%E4%BA%8C%E5%8F%89%E6%A0%91-164903521838945.png"></p>
<p><img src="/.com//%E6%A0%B9%E8%8A%82%E7%82%B9-164903521018844.png"></p>
<ul>
<li>只能有一个根节点，每个节点最多支持2个直接子节点。</li>
<li>节点的度:<ul>
<li>节点拥有的子树的个数,二_叉树的度不大于2叶子节点度为0的节点，也称之为终端结点。</li>
</ul>
</li>
<li>高度:<ul>
<li>叶子结点的高度为1，叶子结点的父节点高度为2,以此类推，根节点的高度最高。</li>
</ul>
</li>
<li>层:<ul>
<li>根节点在第一层， 以此类推</li>
</ul>
</li>
<li>兄弟节点:<ul>
<li>拥有共同父节点的节点互称为兄弟节点</li>
</ul>
</li>
</ul>
<p><img src="/.com//%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91-164903520018343.png"></p>
<ul>
<li>二叉查找树又称二叉排序树或者二叉搜索树。</li>
<li>特点:<ol>
<li>每一个节点上最多有两个子节点</li>
<li>左子树.上所有节点的值都小于根节点的值</li>
<li>右子树.上所有节点的值都大于根节点的值</li>
</ol>
</li>
<li>目的:<ul>
<li>提高检索数据的性能。</li>
</ul>
</li>
</ul>
<h3 id="7-平衡二叉树"><a href="#7-平衡二叉树" class="headerlink" title="7.平衡二叉树"></a>7.平衡二叉树</h3><p>平衡二叉树是在满足查找二叉树的大小规则下，让树尽可能矮小，以此提高查数据的性能。</p>
<p>要求</p>
<ul>
<li>任意节点的左右两个子树的高度差不超过1,任意节点的左右两个子树都是一 颗平衡二叉树</li>
</ul>
<p>平衡二叉树在添加元素后可能导致不平衡</p>
<ul>
<li>基本策略是进行左旋，或者右旋保证平衡。</li>
<li>平衡二叉树-旋转的四种情况<ul>
<li>左左<ul>
<li>当根节点左子树的左子树有节点插入，导致二叉树不平衡</li>
<li>左旋</li>
</ul>
</li>
<li>左右<ul>
<li>当根节点左子树的右子树有节点插入，导致二叉树不平衡</li>
<li>先左旋在右旋</li>
</ul>
</li>
<li>右右<ul>
<li>当根节点右子树的右子树有节点插入，导致二叉树不平衡<ul>
<li>右旋</li>
</ul>
</li>
</ul>
</li>
<li>右左<ul>
<li>当根节点右子树的左子树有节点插入，导致二叉树不平衡</li>
<li>先右旋在左旋</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-红黑树"><a href="#7-红黑树" class="headerlink" title="7.红黑树"></a>7.红黑树</h2><p>概述</p>
<ul>
<li>红黑树是一-种自平衡的二叉查找树，是计算机科学中用到的一-种数据结构。</li>
<li>1972年出现，当时被称之为平衡二叉B树。1978年被修改为如今的”红黑树”。</li>
<li>每一个节点可以是红或者黑;红黑树不是通过高度平衡的，它的平衡是通过“红黑规则”进行实现的。</li>
</ul>
<p><img src="/.com//%E7%BA%A2%E9%BB%91%E6%A0%91-164903518750942.png"></p>
<p>规则</p>
<ul>
<li>每一个节点或是红色的，或者是黑色的，根节点必须是黑色。</li>
<li>如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,叶节点是黑色的。</li>
<li>如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连的情况)。</li>
<li>对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点。</li>
</ul>
<p>添加节点</p>
<ul>
<li>添加的节点的颜色，可以是红色的，也可以是黑色的。</li>
<li>默认用红色效率高。</li>
</ul>
<h1 id="List系列集合"><a href="#List系列集合" class="headerlink" title="List系列集合"></a>List系列集合</h1><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h2><ul>
<li>ArrayList、LinekdList :有序，可重复,有索引</li>
<li>有序:存储和取出的元素顺序一致</li>
<li>有索引:可以通过索引操作元素</li>
<li>可重复:存储的元素可以重复.</li>
</ul>
<p>特有方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index, E element)</td>
<td>在此集合中的指定位置插入指定的元素</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>删除指定索引</td>
</tr>
<tr>
<td>E set(int index,E element )</td>
<td>修改指定索引</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>返回指定索引处的元素</td>
</tr>
</tbody></table>
<h2 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h2><ul>
<li>迭代</li>
<li>增强for循环</li>
<li>Lambda表达式</li>
<li>for循环( 因为List集合存在索引)</li>
</ul>
<h2 id="3-底层原理"><a href="#3-底层原理" class="headerlink" title="3. 底层原理"></a>3. 底层原理</h2><ul>
<li>ArrayList底层是基 于数组实现的:根据索引定位元素快,增删需要做元素的移位操作。</li>
<li>第一次创建集合并添加第一 个元素的时候, 在底层创建一个默认长度为10的数组。</li>
</ul>
<h2 id="4-LinkList"><a href="#4-LinkList" class="headerlink" title="4.LinkList"></a>4.LinkList</h2><p>特点</p>
<ul>
<li>底层数据结构是双链表,查询慢，首尾操作的速度是极快的,所以多了很多首尾操作的特有APl。</li>
</ul>
<p>特有功能</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void addFirst(E e)</td>
<td>在该列表开头插入指定的元素</td>
</tr>
<tr>
<td>public void addLast(E e)</td>
<td>将指定的元素追加到 此列表的末尾</td>
</tr>
<tr>
<td>public E getFirst()</td>
<td>返回此列表中的第-个元素</td>
</tr>
<tr>
<td>public E getLast()</td>
<td>返回此列表中的最后一个元素</td>
</tr>
<tr>
<td>public E removeFirst()</td>
<td>从此列表中删除并返回第一个元素</td>
</tr>
<tr>
<td>public E removeLast( )</td>
<td>从此列表中删除并返回最后-个元素</td>
</tr>
</tbody></table>
<h2 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5.泛型"></a>5.泛型</h2><p>概述</p>
<ul>
<li>泛型:是JDK5中引入的特性，可以在编译阶段约束操作的数据类型,并进行检查。</li>
<li>泛型的格式: &lt;数据类型&gt;;注意:泛型只能支持引用数据类型。</li>
<li>集合体系的全部接口和实现类都是支持泛型的使用的。</li>
</ul>
<p>好处</p>
<ul>
<li>统一数据类型</li>
<li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。</li>
</ul>
<h3 id="5-1-泛型类"><a href="#5-1-泛型类" class="headerlink" title="5.1 泛型类"></a>5.1 泛型类</h3><ul>
<li>定义类时同时定义了泛型的类就是泛型类。</li>
<li>泛型类的格式:修饰符class类名&lt;泛型变量&gt;{ }</li>
<li>此处泛型变量T可以随便写为任意标识，常见的如E、T、K、V等。</li>
</ul>
<h3 id="5-2-泛型方法"><a href="#5-2-泛型方法" class="headerlink" title="5.2 泛型方法"></a>5.2 泛型方法</h3><p>概述</p>
<ul>
<li>定义方法时同时定义了泛型的方法就是泛型方法。</li>
<li>泛型方法的格式:修饰符&lt;泛型变量&gt;方法返回值方法名称(形参列表){}</li>
</ul>
<p>作用</p>
<ul>
<li>方法中可以使用泛型接收-切实际类型的参数，方法更具备通用性。</li>
</ul>
<p>泛型方法的原理:</p>
<ul>
<li>把出现泛型变量的地方全部替换成传输的真实数据类型</li>
</ul>
<h3 id="5-3-泛型接口"><a href="#5-3-泛型接口" class="headerlink" title="5.3 泛型接口"></a>5.3 泛型接口</h3><p>概述</p>
<ul>
<li>使用了泛型定义的接口就是泛型接口。</li>
<li>泛型接口的格式:修饰符interface接口名称&lt;泛型变量&gt;{}</li>
</ul>
<p>泛型接口的原理:</p>
<ul>
<li>实现类可以在实现接口的时候传入自己操作的数据类型，这样重写的方法都将是针对于该类型的操作。</li>
</ul>
<h3 id="5-4泛型通配符"><a href="#5-4泛型通配符" class="headerlink" title="5.4泛型通配符"></a>5.4泛型通配符</h3><ul>
<li>?可以在“使用泛型”的时候代表一切类型。</li>
<li>ET K V是在定义泛型的时候使用的。</li>
</ul>
<h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><p>特点</p>
<ul>
<li>无序:存取顺序不一致</li>
<li>不重复:可以去除重复</li>
<li>无索引:没有带索引的方法,所以不能使用普通for循环遍历，也不能通过索引来获取元素。</li>
</ul>
<p>实现类特点</p>
<ul>
<li>HashSet:无序、不重复、无索引。</li>
<li>LinkedHashSet:有序、不重复、无索引。</li>
<li>TreeSet:排序、不重复、无索引。</li>
</ul>
<p>HashSet底层原理</p>
<ul>
<li>HashSet集合底层采取哈希表存储的数据。</li>
<li>哈希表是一种对于增删改查数据性能都较好的结构。</li>
</ul>
<p>哈希表的组成</p>
<ul>
<li>JDK8之前的，底层使用数组+链表组成</li>
<li>JDK8开始后，底层采用数组+链表+红黑树组成。</li>
</ul>
<h2 id="1-哈希值"><a href="#1-哈希值" class="headerlink" title="1.哈希值"></a>1.哈希值</h2><ul>
<li>是JDK根据对象的地址，按照某种规则算出来的int类型的数值。</li>
</ul>
<p>Object类的API</p>
<ul>
<li>public int hashCode():返回对象的哈希值</li>
</ul>
<p>对象的哈希值特点</p>
<ul>
<li>同一个对象多次调用hashCode()方法返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的。</li>
</ul>
<p>HashSet1.7版本原理解析:数组+链表+ (结合哈希算法)</p>
<ol>
<li>创建一个默认长度1 6的数组，数组名table</li>
<li>根据元素的哈希值跟数组的长度求余计算出应存入的位置( 哈希算法)</li>
<li>判断当前位置是否为null,如果是null直接存入</li>
<li>如果位置不为null,表示有元素，则调用equals方法比较</li>
<li>如果一样，则不存，如果不一-样，则存入数组<ul>
<li>JDK 7新元素占老元素位置，指向老元素</li>
<li>JDK 8中新元素挂在老元素下面</li>
</ul>
</li>
</ol>
<ul>
<li>结论:哈希表是一种对于增删改查数据性能都较好的结构。</li>
</ul>
<p>JDK1.8版本开始HashSet原理解析</p>
<ul>
<li>底层结构:哈希表(数组、链表、红黑树的结合体)</li>
<li>当挂在元素下面的数据过多时，查询性能降低,从DK8开始后，当链表长度超过8的时候，自动转换为红黑树。</li>
<li>结论: JDK8开始后，哈希表对于红黑树的引入进一-步提高了操作数据的性能。</li>
</ul>
<p>HashSet元素去重复的底层原理</p>
<ul>
<li>结论:如果希望Set集合认为2个内容一样的对象是重复的,<br>必须重写对象的hashCode()和equals()方法</li>
</ul>
<h2 id="2-LinkedHashSet集合"><a href="#2-LinkedHashSet集合" class="headerlink" title="2.LinkedHashSet集合"></a>2.LinkedHashSet集合</h2><p>概述</p>
<ul>
<li>有序、不重复、无索引。</li>
<li>这里的有序指的是保证存储和取出的元素顺序一致</li>
<li>原理:<ul>
<li>底层数据结构是依然哈希表，只是每个元素又额外的多了- -个双链表的机制记录存储的顺序。</li>
</ul>
</li>
</ul>
<h2 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3. TreeSet"></a>3. TreeSet</h2><p>概述</p>
<ul>
<li>不重复、无索引、可排序</li>
<li>可排序:按照元素的大小默认升序(有小到大)排序。</li>
<li>TreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好。</li>
<li>注意: TreeSet集合是一定要排序的，可以将元素按照指定的规则进行排序。</li>
</ul>
<p>TreeSet集合默认的规则</p>
<ul>
<li>对于数值类型: Integer , Double,官方默认按照大小进行升序排序。</li>
<li>对于字符串类型: 默认按照首字符的编号升序排序。</li>
<li>对于自定义类型如Student对象，TreeSet无法直接排序。</li>
<li>结论:<ul>
<li>想要使用TreeSet存储自定义类型，需要制定排序规则</li>
</ul>
</li>
<li>自定义排序规则<ul>
<li>TreeSet集合存储对象的的时候有2种方式可以设计自定义比较规则<ol>
<li>让自定义的类 (如学生类)实现Comparable接口重写里面的compareTo方法来定制比较规则。</li>
<li>TreeSet集合有参数构造器，可以设置Comparator接口对应的比较器对象，来定制比较规则。</li>
</ol>
</li>
<li>两种方式中，关于返回值的规则:<ol>
<li>如果认为第一个元素大于 第二个元素返回正整数即可。</li>
<li>如果认为第一个元素小于第二个元素返回负 整数即可。</li>
<li>如果认为第一个元素等于第二个元素返回0即可，此时Treeset集合只会保留一-个元素，认为两者重复。</li>
<li>注意:如果TreeSet集合存储的对象有实现比较规则，集合也自带比较器，默认使用集合自带的比较器排序。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="4.可变参数"></a>4.可变参数</h2><ul>
<li><p>可变参数用在形参中可以接收多个数据。</p>
</li>
<li><p>可变参数的格式: 数据类型…参数名称</p>
</li>
<li><p>可变参数的作用</p>
<ul>
<li>传输参数非常灵活，方便。可以不传输参数，可以传输1个或者多个，也可以传输一个数组</li>
</ul>
</li>
<li><p>可变参数在方法内部本质上就是一个数组。</p>
</li>
<li><p>可变参数的注意事项:</p>
<ol>
<li>一个形参列表中可变参数只能有一个</li>
<li>可变参数必须放在形参 列表的最后面</li>
</ol>
</li>
</ul>
<h2 id="5-集合工具类"><a href="#5-集合工具类" class="headerlink" title="5.集合工具类"></a>5.集合工具类</h2><p>Collections排序相关API</p>
<ul>
<li>使用范围:只能对于List集合的排序。</li>
</ul>
<ol>
<li><p>排序方式1</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> void sort(List<T> list)</T></T></td>
<td>将集合中元素按照默认规则排序</td>
</tr>
</tbody></table>
<ul>
<li>注意:本方式不可以直接对自定义类型的List集合排序，除非自定义类型实现了比较规则Comparable接口。</li>
</ul>
</li>
<li><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> void sort(List<T> list, Comparator&lt;? super T&gt; c)</T></T></td>
<td>将集合中元素按照<br>指定规则排序</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="Map集合体系"><a href="#Map集合体系" class="headerlink" title="Map集合体系"></a>Map集合体系</h1><h2 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>Map集合是一种双列集合,每个元素包含两个数据。</li>
<li>Map集合的每个元素的格式: key=value(键值对元素)。</li>
<li>Map集合也被称为“键值对集合</li>
</ul>
<p>Map集合整体格式:</p>
<ul>
<li>Collection集合的格式: [元素1,元素2,元素3..] </li>
<li>Map集合的完整格式: {key1=value1 , key2=value2 , key3=value3 …}</li>
</ul>
<h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h2><p>说明</p>
<ul>
<li>使用最多的Map集合是HashMap。</li>
</ul>
<p>Map集合体系特点</p>
<ul>
<li>Map集 合的特点都是由键决定的。</li>
<li>Map集合的键是无序,不重复的， 无索引的，值不做要求( 可以重复)。</li>
<li>Map集合后面重复的键对应的值会覆盖前面重复键的值。</li>
<li>Map集 合的键值对都可以为null。</li>
</ul>
<p>Map集合实现类特点</p>
<ul>
<li>HashMap:元素按照键是无序， 不重复，无索引，值不做要求。( 与Map体系一致)</li>
<li>LinkedHashMap:元素按照键是有序，不重复,无索引，值不做要求。</li>
<li>TreeMap:元素按照建是排序，不重复，无索引的,值不做要求。</li>
</ul>
<h2 id="3-常用API-1"><a href="#3-常用API-1" class="headerlink" title="3.常用API"></a>3.常用API</h2><ul>
<li>Map是双列集合的祖宗接口，它的功能是全部双列集合都可以继承使用的。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V put(K key,V value)</td>
<td>添加元素</td>
</tr>
<tr>
<td>V remove (0bject key)</td>
<td>根据键删除键值对元素</td>
</tr>
<tr>
<td>clear()</td>
<td>移除所有的键值对元素</td>
</tr>
<tr>
<td>boolean containsKey(0bject key)</td>
<td>判断集合是否包含指定的键</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断集合是否包含指定的值</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td>集合的长度，也就是集合中键值对的个数</td>
</tr>
<tr>
<td>public V get(object key)</td>
<td>根据键取得对应值</td>
</tr>
<tr>
<td>public Set<K> keySet()</K></td>
<td>获取键的集合</td>
</tr>
<tr>
<td>Collection<V> values();</V></td>
<td>获取值的集合</td>
</tr>
</tbody></table>
<h2 id="4-遍历-1"><a href="#4-遍历-1" class="headerlink" title="4.遍历"></a>4.遍历</h2><h3 id="4-1键找值"><a href="#4-1键找值" class="headerlink" title="4.1键找值"></a>4.1键找值</h3><ul>
<li>先获取Map集合的全部键的Set集合。</li>
<li>遍历键的Set集合，然后通过键提取对应值。</li>
</ul>
<h3 id="4-2键值对"><a href="#4-2键值对" class="headerlink" title="4.2键值对"></a>4.2键值对</h3><ul>
<li><p>先把Map集合转换成Set集合, liSet集合中每个元素都是键值对实体类型了。</p>
</li>
<li><p>遍历Set集合，然后提取键以及提取值。</p>
</li>
<li><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>
<td>获取所有键值对对象的集合</td>
</tr>
<tr>
<td>K getKey()</td>
<td>获得键</td>
</tr>
<tr>
<td>V getValue()</td>
<td>获取值</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4-3Lambda遍历"><a href="#4-3Lambda遍历" class="headerlink" title="4.3Lambda遍历"></a>4.3Lambda遍历</h3><ul>
<li>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</li>
</ul>
<p>API</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>default void forEach( BiConsumer&lt;? super K，? super V&gt; action)</td>
<td>结合lambda遍历Map集合</td>
</tr>
</tbody></table>
<h2 id="5-TreeMap"><a href="#5-TreeMap" class="headerlink" title="5.TreeMap"></a>5.TreeMap</h2><p>概述和特点</p>
<ul>
<li>由键决定特性:不重复、无索引、可排序</li>
<li>可排序:按照键数据的大小默认升序(有小到大)排序。只能对键排序。</li>
<li>注意: TreeMap集合是一定要排序的，可以默认排序，也可以将键按照指定的规则进行排序</li>
</ul>
<h1 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h1><p>概述</p>
<ul>
<li>不可变集合，就是不可被修改的集合。</li>
<li>集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错。</li>
</ul>
<p>为什么要创建不可变集合?</p>
<ul>
<li>如果某个数据不能被修改,把它防御性地拷贝到不可变集合中是个很好的实践。</li>
<li>或者当集合对象被不可信的库调用时，不可变形式是安全的。</li>
</ul>
<p>如何创建不可变集合?</p>
<ul>
<li>在List、 Set、Map接口中，都存在of方法，可以创建- -个不可变的集合。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static <E> Set<E> of.(E..elements)</E></E></td>
<td>创建一个具有指定元素的Set集合对象</td>
</tr>
<tr>
<td>static &lt;K,V&gt; Map&lt;K, V&gt; of.(E lements)</td>
<td>创建一个具有指定元素的Map集合对象</td>
</tr>
<tr>
<td>static <E> List<E> of.(E elements)</E></E></td>
<td>创建一个具有指定元素的List集合对象</td>
</tr>
</tbody></table>
<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><h2 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream流 概念。</li>
<li>目的:<ul>
<li>用于简化集合和数组操作的API。</li>
</ul>
</li>
</ul>
<p>思想</p>
<ol>
<li>先得到集合或者数组的Stream流(就是一根传送带)。</li>
<li>把元素放上去。</li>
<li>然后就用这个Stream流简化的API来方便的操作元素。</li>
</ol>
<h2 id="2-Stream流的三类方法"><a href="#2-Stream流的三类方法" class="headerlink" title="2.Stream流的三类方法"></a>2.Stream流的三类方法</h2><ul>
<li><p>获取Stream流</p>
<ul>
<li><p>创建一条流水线， 并把数据放到流水线上准备进行操作</p>
</li>
<li><p>集合</p>
<ul>
<li>可以使用Collection接口中的默认方法stream()生成流</li>
<li><code>default Stream&lt;E&gt; stream()</code></li>
</ul>
</li>
<li><p>数组</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> Stream<T> stream(T[] array)</T></T></td>
<td>获取当前数组的Stream流</td>
</tr>
<tr>
<td>public static<T> Stream<T> of(T… values)</T></T></td>
<td>获取当前数组/可变数据的Stream流</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>中间方法</p>
<ul>
<li>流水线上的操作。 一次操作完毕之后，还可以继续进行其他操作。</li>
</ul>
</li>
<li><p>终结方法</p>
<ul>
<li>一个Stream流只能有- -个终结方法,是流水线上的最后一个操作</li>
</ul>
</li>
</ul>
<h2 id="3-常用API-2"><a href="#3-常用API-2" class="headerlink" title="3.常用API"></a>3.常用API</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Stream<T> filter<br>(Predicate&lt;? super T&gt; predicate)</T></td>
<td>用于对流中的数据进行过滤。</td>
</tr>
<tr>
<td>Stream<T> limit(1ong maxSize)</T></td>
<td>获取前几个元素</td>
</tr>
<tr>
<td>Stream<T> skip(long n)</T></td>
<td>跳过前几个元素</td>
</tr>
<tr>
<td>Stream<T> distinct()</T></td>
<td>去除流中重复的元素。依赖(hashCode和equals方法)</td>
</tr>
<tr>
<td>static <T> Stream<T> concat<br>(Stream a, Stream b)</T></T></td>
<td>合并a和b两个流为一个流</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>中间方法也称为非终结方法，调用完成后返回新的Stream流可以继续使用，支持链式编程。</li>
<li>在Stream流中无法直接修改集合、数组中的数据。</li>
</ul>
<h2 id="4-收集Stream流"><a href="#4-收集Stream流" class="headerlink" title="4.收集Stream流"></a>4.收集Stream流</h2><ul>
<li>收集Stream流的含义:就是把Stream流操作后的结果数据转回到集合或者数组中去。</li>
<li>Stream流: 方便操作集合/数组的手段。</li>
</ul>
<p>方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>R collect(Collector collector)</td>
<td>开始收集Stream流，指定收集器</td>
</tr>
<tr>
<td>pub1ic static <T> Collector toList()</T></td>
<td>把元素收集到List集合中</td>
</tr>
<tr>
<td>public static <T> Collector toSet()</T></td>
<td>把元素收集到Set集合中</td>
</tr>
<tr>
<td>public static Col1ector toMap(Function keyMapper ，Function valueMapper)</td>
<td>把元素收集到Map集合中</td>
</tr>
</tbody></table>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>异常是程序在“编译”或者”执行”的过程中可能出现的问题，注意:语法错误不算在异常体系中。</li>
<li>比如:数组索引越界、空指针异常、 日期格式化异常，等…</li>
<li>异常一旦出现了，如果没有提前处理,程序就会退出JVM虚拟机而终止</li>
<li>研究异常并且避免异常，然后提前处理异常，体现的是程序的安全，健壮性。</li>
</ul>
<p>体系</p>
<pre><code class="mermaid">graph TB
A(Throwable)===&gt;B(Error)
A==&gt;C(Exception)
C==&gt;D(RuntimeException及其子类)
C==&gt;E(除RuntimeException之外的所有异常)
</code></pre>
<p>Error:</p>
<ul>
<li>系统级别问题、JVM退出等,</li>
<li>代码无法控制。</li>
</ul>
<p>Exception:</p>
<ul>
<li> java.lang包下， 称为异常类,它表示程序本身可以处理的问题</li>
<li>RuntimeException及其子类:运行时异常,编译阶段不会报错。(空指针异常, 数组索引越界异常)</li>
<li>除RuntimeException之外所有的异常:编译时异常，编译期必须处理的，否则程序不能通过编译。(日 期格式化异常)。</li>
</ul>
<p>总结</p>
<ul>
<li>编译时异常就是在编译的时候出现的异常</li>
<li>运行时异常就是在运行时出现的异常。</li>
</ul>
<h2 id="2-运行时异常"><a href="#2-运行时异常" class="headerlink" title="2.运行时异常"></a>2.运行时异常</h2><ul>
<li>直接继承自RuntimeException或者其子类,编译阶段不会报错,运行时可能出现的错误。</li>
<li>般是程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误，</li>
</ul>
<p>示例</p>
<ul>
<li>数组索引越界异常: ArrayIndexOutOfBoundsException</li>
<li>空指针异常: NullPointerException,直接输出没有问题，但是调用空指针的变量的功能就会报错。</li>
<li>数学操作异常: ArithmeticException</li>
<li>类型转换异常: ClassCastException</li>
<li>数字转换异常: NumberFormatException</li>
</ul>
<h2 id="3-编译时异常"><a href="#3-编译时异常" class="headerlink" title="3.编译时异常"></a>3.编译时异常</h2><ul>
<li>不是RuntimeException或者其子类的异常，编译阶就报错，必须处理，否则代码不通过。</li>
</ul>
<p>作用</p>
<ul>
<li>是担心程序员的技术不行，在编译阶段就爆出一个错误,目的在于提醒不要出错!</li>
<li>编译时异常是可遇不可求。遇到了就遇到了呗。</li>
</ul>
<h2 id="4-异常处理流程"><a href="#4-异常处理流程" class="headerlink" title="4.异常处理流程"></a>4.异常处理流程</h2><h3 id="4-1默认处理流程"><a href="#4-1默认处理流程" class="headerlink" title="4.1默认处理流程"></a>4.1默认处理流程</h3><ol>
<li>默认会在出现异常的代码那里自动的创建一一个 异常对象: ArithmeticException。</li>
<li>异常会从方法中出现的点这里拋出给调用者，调用者最终抛出给JVM虚拟机。</li>
<li>虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。</li>
<li>直接从当前执行的异常点干掉当前程序。</li>
<li>后续代码没有机会执行了，因为程序已经死亡。</li>
</ol>
<h3 id="4-2-编译时异常处理"><a href="#4-2-编译时异常处理" class="headerlink" title="4.2 编译时异常处理"></a>4.2 编译时异常处理</h3><ul>
<li>出现异常直接抛出去给调用者，调用者也继续抛出去。</li>
<li>出现异常自己捕获处理，不麻烦别人。</li>
<li>前两者结合，出现异常直接抛出去给调用者,调用者捕获处理。</li>
</ul>
<ol>
<li><p>throws</p>
<ul>
<li><p>throws:用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。</p>
</li>
<li><p>这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。</p>
</li>
<li><p>抛出异常格式</p>
<p><code>方法throws异常1，异常2，异常3 ..&#123;&#125;</code></p>
</li>
<li><p>规范做法</p>
<p><code>方法throws Exception&#123;&#125;</code></p>
</li>
</ul>
</li>
<li><p>try…catch…</p>
<ul>
<li><p>监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。</p>
</li>
<li><p>这种方式还可以，发生异常的方法自己独立完成异常的处理,程序可以继续往下执行。</p>
</li>
<li><p>建议格式</p>
<pre><code class="java">try&#123;
// 可能出现异常的代码!
&#125;catch (Exception e)&#123;
e.printStackTrace(); // 直接打印异常栈信息
&#125;
Exception&#39;可以捕获处理一切异常类型!
</code></pre>
</li>
</ul>
</li>
<li><p>前两者结合</p>
<ul>
<li>方法直接将异通过throws抛出去给调用者</li>
<li>调用者收到异常后直接捕获处理。</li>
</ul>
</li>
</ol>
<h3 id="4-3运行时异常处理方式"><a href="#4-3运行时异常处理方式" class="headerlink" title="4.3运行时异常处理方式"></a>4.3运行时异常处理方式</h3><ul>
<li>运行时异常编译阶段不会出错，是运行时才可能出错的，所以编译阶段不处理也可以。</li>
<li>按照规范建议还是处理:建议在最外层调用处集中捕获处理即可。</li>
</ul>
<h2 id="5-自定义异常"><a href="#5-自定义异常" class="headerlink" title="5.自定义异常"></a>5.自定义异常</h2><ul>
<li>Java无法为这个世界上全部的问题提供异常类。</li>
<li>如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了。</li>
</ul>
<p>好处：</p>
<ul>
<li>可以使用异常的机制管理业务问题，如提醒程序员注意。</li>
<li>同时一旦出现bug，可以用异常的形式清晰的指出出错的地方。</li>
</ul>
<ol>
<li>自定义编译时异常<ul>
<li>定义一个异常类继承Exception.</li>
<li>重写构造器。</li>
<li>在出现异常的地方用throw new自定义对象抛出。</li>
<li>作用:编译时异常是编译阶段就报错，提醒更加强烈，-定需要处理! !</li>
</ul>
</li>
<li>自定义运行时异常<ul>
<li>定义一个异常类继承RuntimeException.</li>
<li>重写构造器。</li>
<li>在出现异常的地方用throw new自定义对象抛出!</li>
<li>作用:提醒不强烈,编译阶段不报错! !运行时才可能出现!</li>
</ul>
</li>
</ol>
<h1 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h1><h2 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1.概述"></a>1.概述</h2><p>输出语句的弊端</p>
<ul>
<li>信息只能展示在控制台</li>
<li>不能将其记录到其他的位置(文件,数据库)</li>
<li>想取消记录的信息需要修改代码才可以完成</li>
</ul>
<p>日志技术具备的优势</p>
<ul>
<li>可以将系统执行的信息选择性的记录到指定的位置(控制台、文件中、数据库中)。</li>
<li>可以随时以开关的形式控制是否记录日志，无需修改源代码。</li>
</ul>
<p>优势</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">输出语句</th>
<th align="center">日志技术</th>
</tr>
</thead>
<tbody><tr>
<td>输出位置</td>
<td align="center">只能是控制台</td>
<td align="center">可以将日志信息写入到文件或者数据库中</td>
</tr>
<tr>
<td>取消日志</td>
<td align="center">需要修改代码，灵活性比较差</td>
<td align="center">不需要修改代码，灵活性比较好</td>
</tr>
<tr>
<td>多线程</td>
<td align="center">性能较差</td>
<td align="center">性能较好</td>
</tr>
</tbody></table>
<h2 id="2-体系"><a href="#2-体系" class="headerlink" title="2.体系"></a>2.体系</h2><p>日志规范接口</p>
<ul>
<li>Commons Logging    简称JCL<ul>
<li>Simple Logging Facade for Java    简称：slf4j</li>
</ul>
</li>
</ul>
<p>日志规范:</p>
<ul>
<li>一些接口，提供给日志的实现框架设计的标准。</li>
</ul>
<p>日志框架:</p>
<ul>
<li>牛人或者第三方公司已经做好的日志记录实现代码，后来者直接可以拿去使用。</li>
<li>Log4j</li>
<li>JUL</li>
<li>(java . util .loggiing)</li>
<li>Logback</li>
<li>其他实现</li>
</ul>
<p>因为对Commons Logging的接口不满意，有人就搞了SLF4。因为对Log4j的性能不满意,有人就搞了Logback。</p>
<h2 id="3-logback概述"><a href="#3-logback概述" class="headerlink" title="3.logback概述"></a>3.logback概述</h2><p>Logback是由log4j创始人设计的另-一个开源日志组件，性能比log4j要好</p>
<p>Logback是基于slf4j的日志规范实现的框架。</p>
<p>Logback主要分为三个技术模块:</p>
<ul>
<li>logback-core: logback-core 模块为其他两个模块奠定了基础，必须有。</li>
<li>logback-classic: 它是log4j的-个改良版本，同时它完整实现了”slf4j API。</li>
<li>logback-access 模块与Tomcat和Jetty等Servlet容器集成，以提供HTTP访问日志功能</li>
</ul>
<h2 id="4-入门"><a href="#4-入门" class="headerlink" title="4.入门"></a>4.入门</h2><p>需求:导入Logback日志技术到项目中,用于纪录系统的日志信息<br>分析:</p>
<ol>
<li><p>在项目下新建文件夹lib,导入Logback的相关jar包到该文件夹下，并添加到项目依赖库中去。</p>
</li>
<li><p>将Logback的核心配置文件logback.xml直接拷贝到src目录下(必须是src下)。</p>
</li>
<li><p>在代码中获取日志的对象</p>
<p><code>public static final Logger LOGGER = LoggerFactory. getLogge(&quot;类对象&quot;);</code></p>
</li>
</ol>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="1-概述-7"><a href="#1-概述-7" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>File类在包java.io.File下、代表操作系统的文件对象(文件、文件夹)。</li>
<li>File类提供了诸如:定位文件,获取文件本身的信息、删除文件、创建文件(文件夹)等功能。</li>
</ul>
<p>创建对象</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public File(String pathname )</td>
<td>根据文件路径创建文件对象</td>
</tr>
<tr>
<td>public File(String parent, String child)</td>
<td>从父路径名字符串和子路径名字符串创建文件对象</td>
</tr>
<tr>
<td>public File(File parent, String child)</td>
<td>根据父路径对应文件对象和子路径名字符串创建文件对象</td>
</tr>
</tbody></table>
<ul>
<li>File对象可以定位文件和文件夹</li>
<li>File封装的对象仅仅是一个路径名，这个路径可以是存在的，也可以是不存在的。</li>
</ul>
<p>绝对路径和相对路径</p>
<ul>
<li><p>绝对路径:从盘符开始</p>
<p><code>File file1 = new File(&quot;D: \\itheima\la.txt&quot;);</code></p>
</li>
<li><p>相对路径:不带盘符，默认直接到src下的目录寻找文件。</p>
<p><code>File file3 = new File(&quot;src\a.txt&quot;);</code></p>
</li>
</ul>
<p>​    </p>
<h2 id="2-常用API-1"><a href="#2-常用API-1" class="headerlink" title="2.常用API"></a>2.常用API</h2><h3 id="2-1判断文件类型、获取文件信息"><a href="#2-1判断文件类型、获取文件信息" class="headerlink" title="2.1判断文件类型、获取文件信息"></a>2.1<strong>判断文件类型、获取文件信息</strong></h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean isDirectory() t</td>
<td>测试此抽象路径名表示的File是否为文件夹</td>
</tr>
<tr>
<td>public boolean isFile()</td>
<td>测试此抽象路径名表示的File是否为文件</td>
</tr>
<tr>
<td>public boolean exists()</td>
<td>测试此抽象路径名表示的F ile是否存在</td>
</tr>
<tr>
<td>public String getAbsolutePath()</td>
<td>返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>将此抽象路径名转换为路径名字符串</td>
</tr>
<tr>
<td>public String getName()</td>
<td>返回由此抽象路径名表示的文件或文件夹的名称</td>
</tr>
<tr>
<td>public long lastModified()</td>
<td>返回文件最后修改的时间毫秒值</td>
</tr>
</tbody></table>
<h3 id="2-2创建文件、删除文件"><a href="#2-2创建文件、删除文件" class="headerlink" title="2.2创建文件、删除文件"></a>2.2创建文件、删除文件</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean createNewFile( )</td>
<td>创建-一个新的空的文件</td>
</tr>
<tr>
<td>public boolean mkdir()</td>
<td>只能创建一级文件夹</td>
</tr>
<tr>
<td>public boolean mkdirs( )</td>
<td>可以创建多级文件夹</td>
</tr>
<tr>
<td>public boolean delete()</td>
<td>删除由此抽象路径名表示的文件或空文件夹</td>
</tr>
</tbody></table>
<ul>
<li>delete方法直接删除不走回收站;如果删除的是-一个文件，且文件没有被占用则直接删除。</li>
<li>delete方法默认只能删除空文件夹。</li>
</ul>
<h3 id="2-3遍历文件夹"><a href="#2-3遍历文件夹" class="headerlink" title="2.3遍历文件夹"></a>2.3遍历文件夹</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String[] list()</td>
<td>获取当前目录下所有的”一-级文件名称”到一个字符串数组中去返回。</td>
</tr>
<tr>
<td>public File[] listFiles()(常用)</td>
<td>获取当前目录 下所有的”- -级文件对象”<br>到一个文件对象数组中去返回(重点)</td>
</tr>
</tbody></table>
<p>listFiles方法注意事项:</p>
<ul>
<li>当调用者不存在时，返回null</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>什么是方法递归?</p>
<ul>
<li>方法直接调用自己或者间接调用自己的形式称为方法递归( recursion)。</li>
<li>递归做为一种算法在程序设计语言中广泛应用。</li>
</ul>
<p>递归的形式</p>
<ul>
<li>直接递归:方法自己调用自己。</li>
<li>间接递归:方法调用其他方法，其他方法又回调方法自己。</li>
</ul>
<p>方法递归存在的问题?</p>
<ul>
<li>递归如果没有控制好终止，会出现递归死循环，导致栈内存溢出现象。</li>
</ul>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><h2 id="1-常见字符集"><a href="#1-常见字符集" class="headerlink" title="1.常见字符集"></a>1.常见字符集</h2><p>基础知识</p>
<ul>
<li>计算机底层不可以直接存储字符的。计算机中底层只能存储二进制(0、1)</li>
<li>二进制是可以转换成十进制的</li>
<li>结论:计算机底层可以表示十进制编号。计算机可以给人类字符进行编号存储，这套编号规则就是字符集。</li>
</ul>
<p>ASCII字符集:</p>
<ul>
<li>ASCII(American Standard Code for Information Interchange,美国信息交换标准代码):包括了数字、英文、符号。</li>
<li>ASCII使用1个字节存储一个字符， 一个字节是8位， 总共可以表示128个字符信息， 对于英文,数字来说是够用的。</li>
</ul>
<p>GBK:</p>
<ul>
<li>window系统默认的码表。兼容ASCII码表， 也包含了几万个汉字,并支持繁体汉字以及部分日韩文字。</li>
<li>注意: GBK是中国的码表，-个中文以两个字节的形式存储。但不包含世界上所有国家的文字。</li>
</ul>
<p>Unicode码表:</p>
<ul>
<li>unicode (又称统- -码、 万国码、单-码)是计算机科学领域里的一项业界字符编码标准。</li>
<li>容纳世界上大多数国家的所有常见文字和符号。</li>
<li>由于Unicode会先通过UTF-8，UTF-16, 以及UTF-32的编码成二进制后再存储到计算机，其中最为常见的就是UTF-8。</li>
<li>注意<ul>
<li>Unicode是万国码， 以UTF-8编码后- 一个中文- 般以三个字节的形式存储。</li>
<li>UTF-8也要兼容ASCII编码表。</li>
<li>技术人员都应该使用UTF-8的字符集编码。</li>
<li>编码前和编码后的字符集需要一致,否则会出现中文乱码。</li>
</ul>
</li>
</ul>
<h2 id="2-编码、解码"><a href="#2-编码、解码" class="headerlink" title="2.编码、解码"></a>2.编码、解码</h2><p>String编码</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>byte[] getBytes()</td>
<td>使用平台的默认字符集将该String编码为一系列字节， 将结果存储到新的字节数</td>
</tr>
<tr>
<td>byte[] getBytes(String charsetName)</td>
<td>使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中</td>
</tr>
</tbody></table>
<p>String解码</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String(byte[] bytes )</td>
<td>通过使用平台的默认字符集解码指定的字节数组来构造新的</td>
</tr>
<tr>
<td>String(byte[] bytes, <br>String charsetName)</td>
<td>通过指定的字符集解码指定的字节数组来构造新的String</td>
</tr>
</tbody></table>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="1-概述-8"><a href="#1-概述-8" class="headerlink" title="1.概述"></a>1.概述</h2><p>I0流也称为输入、输出流,就是用来读写数据的。</p>
<ul>
<li>I表示intput, 是数据从硬盘文件读入到内存的过程,称之输入,负责读。</li>
<li>0表示output, 是内存程序的数据从内存到写出到硬盘文件的过程,称之输出，负责写。</li>
</ul>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h2><ul>
<li>按流的方向<ol>
<li>输入流</li>
<li>输出流</li>
</ol>
</li>
<li>按流中的数据最小单位分为<ol>
<li>字节流</li>
<li>字符流</li>
</ol>
</li>
</ul>
<p>总结流的四大类:</p>
<ul>
<li>字节输入流: 以内存为基准,来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流称为字节输大流。</li>
<li>字节输出流:以内存为基准,把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流。</li>
<li>字符输入流:以内存为基准,来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流称为字符输入流。</li>
<li>字符输出流:以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。</li>
</ul>
<pre><code class="mermaid">graph TB
A(IO流体系)==&gt;B(字节流)
A==&gt;C(字符流)
B==&gt;D(InputStream)
B==&gt;E(OutStream)
C==&gt;F(Reader)
C==&gt;G(Writer)
D==&gt;H&#123;FileInputStream&#125;
E==&gt;I&#123;FileOutputStream&#125;
F==&gt;J&#123;FileReader&#125;
G==&gt;K&#123;FileWriter&#125;
L(抽象类)
</code></pre>
<h3 id="2-1字节流"><a href="#2-1字节流" class="headerlink" title="2.1字节流"></a>2.1字节流</h3><h4 id="文件字节输入流-FileInputStream"><a href="#文件字节输入流-FileInputStream" class="headerlink" title="文件字节输入流: FileInputStream"></a>文件字节输入流: FileInputStream</h4><ul>
<li>作用:以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FileInputStream(File file)</td>
<td>创建字节输入流管道与源文件对象接通</td>
</tr>
<tr>
<td>public FilelnputStream(String pathname)</td>
<td>创建字节输入流管道与源文件路径接通</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int read()</td>
<td>每次读取一个字节返回，如果字节已经没有可读的返回-1</td>
</tr>
<tr>
<td>public int read(byte[] buffer)</td>
<td>每次读取一个字节数组返回，如果字节已经没有可读的返回-1</td>
</tr>
<tr>
<td>public byte[] readAllBytes()</td>
<td>直 接将当前字节输入流对应的文件对象的字节数据装到一一个字节数组返回</td>
</tr>
</tbody></table>
<h4 id="文件字节输出流-FileOutputStream"><a href="#文件字节输出流-FileOutputStream" class="headerlink" title="文件字节输出流: FileOutputStream"></a>文件字节输出流: FileOutputStream</h4><p>作用:以内存为基准，把内存中的数据以字节的形式写出到磁盘文件中去的流。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public File0utputStream(File file)</td>
<td>创建字节输出流管道与源文件对象接通</td>
</tr>
<tr>
<td>public File0utputStream(File file, boolean append)</td>
<td>创建字节输出流管道与源文件对象接通，可追加数据</td>
</tr>
<tr>
<td>public File0utputStream(String filepath)</td>
<td>创建字节输出流管道与源文件路径接通</td>
</tr>
<tr>
<td>public File0utputStream(String filepath, boolean append )</td>
<td>创建字节输出流管道与源文件路径接通，可追加数据</td>
</tr>
</tbody></table>
<p>常用API</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void write(int a)</td>
<td>写一个字节出去</td>
</tr>
<tr>
<td>public void write(byte[] buffer)</td>
<td>写一个字节数组出去</td>
</tr>
<tr>
<td>public void write(byte[] buffer ，int pos ，int len)</td>
<td>写一个字节数组的一部分出去。</td>
</tr>
</tbody></table>
<p>流的关闭与刷新</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flush()</td>
<td>刷新流，还可以继续写数据</td>
</tr>
<tr>
<td>close()</td>
<td>关闭流，释放资源，但是在关闭之前会先刷新流。- -旦关闭，就不能再写数据</td>
</tr>
</tbody></table>
<h3 id="2-2-字符流"><a href="#2-2-字符流" class="headerlink" title="2.2 字符流"></a>2.2 字符流</h3><h4 id="文件字符输入流-Reader"><a href="#文件字符输入流-Reader" class="headerlink" title="文件字符输入流: Reader"></a>文件字符输入流: Reader</h4><p>作用:以内存为基准,把磁盘文件中的数据以字符的形式读取到内存中去。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FileReader(File file)</td>
<td>创建字符输入流管道与源文件对象接通</td>
</tr>
<tr>
<td>public FileReader(String pathname)</td>
<td>创建字符输入流管道与源文件路径接通</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int rexd()</td>
<td>每次读取一个字符返回，如果字符已经没有可读的返回-1</td>
</tr>
<tr>
<td>public int read(char] buffer)</td>
<td>每次读取一个字符数组，返回读取的字符个数，如果字符已经没有可读的返回-1</td>
</tr>
</tbody></table>
<h4 id="文件字符输出流-Writer"><a href="#文件字符输出流-Writer" class="headerlink" title="文件字符输出流 Writer"></a>文件字符输出流 Writer</h4><p>作用:以内存为基准，把内存中的数据以字符的形式写出到磁盘文件中去的流。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FileWriter(File file)</td>
<td>创建字符输出流管道与源文件对象接通</td>
</tr>
<tr>
<td>public FileWriter(File file, boolean append)</td>
<td>创建字符输出流管道与源文件对象接通，可追加数据</td>
</tr>
<tr>
<td>public FileWriter(String filepath)</td>
<td>创建字符输出流管道与源文件路径接通</td>
</tr>
<tr>
<td>public FileWriter(String filepath, boolean append)</td>
<td>创建字符输出流管道与源文件路径接通，可追加数据</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int c)</td>
<td>写一个字符</td>
</tr>
<tr>
<td>void write(char[ cbuf)</td>
<td>写一个字符数组</td>
</tr>
<tr>
<td>void write(char[] cbuf, int off,int len)</td>
<td>写一个字符数组的一部分</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>写一个字符串</td>
</tr>
<tr>
<td>void write(String str,int off,int len)</td>
<td>写一个字符串的一部分</td>
</tr>
<tr>
<td>void write(int c)</td>
<td>写一个字符</td>
</tr>
</tbody></table>
<h2 id="3-缓冲流"><a href="#3-缓冲流" class="headerlink" title="3.缓冲流"></a>3.缓冲流</h2><h3 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h3><ul>
<li>缓冲流也称为高效流、或者高级流。之前学习的字节流可以称为原始流。</li>
<li>作用:缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能</li>
<li>分类<ol>
<li>字节缓冲输入流: BufferedInputStream</li>
<li>字节缓冲输出流: BufferedoutputStream</li>
<li>字符缓冲输入流: BufferedReader</li>
<li>字符缓冲输出流: BufferedWriter</li>
</ol>
</li>
</ul>
<h3 id="3-1字节缓冲流"><a href="#3-1字节缓冲流" class="headerlink" title="3.1字节缓冲流"></a>3.1字节缓冲流</h3><p>字节缓冲流性能优化原理:</p>
<ul>
<li>字节缓冲输入流自带了8KB缓冲池，以后我们直接从缓冲池读取数据，所以性能较好。</li>
<li>字节缓冲输出流自带了8KB缓冲池,数据就直接写入到缓冲池中去，写数据性能极高了。</li>
</ul>
<p>特点</p>
<ul>
<li>字节缓冲输入流: BufferedInputStream, 提高字节输入流读取数据的性能，读写功能上并无变化。</li>
<li>字节缓冲输出流: BufferedOutputStream, 提高字节输出流读取数据的性能,读写功能上并无变化。</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BufferedInputStream(InputStream is)”</td>
<td>可以把低级的字节输入流包装成一一个高级的缓冲字节输入流管道， 从而提高字节输入流读数据的性能</td>
</tr>
<tr>
<td>public BufferedOutputStream(OutputStream os)</td>
<td>public BufferedOutputStream(OutputStream os)写数据的性能</td>
</tr>
</tbody></table>
<h3 id="3-2字符缓冲流"><a href="#3-2字符缓冲流" class="headerlink" title="3.2字符缓冲流"></a>3.2字符缓冲流</h3><p>字符缓冲输入流</p>
<ul>
<li>字符缓冲输入流: BufferedReader。</li>
<li>作用:提高字符输入流读取数据的性能，除此之外多了按照行读取数据的功能。</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BufferedReader(Reader r)</td>
<td>可以把低级的字符输入流包装成一个高级的缓冲字符输入流管道，<br> 从而提高字符输入流读数据的性能</td>
</tr>
</tbody></table>
<p>字符缓冲输入流新增功能</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String readLine()</td>
<td>读取一行数据返回，如果读取没有完毕，无行可读返回null</td>
</tr>
</tbody></table>
<p>字符缓冲输出流</p>
<ul>
<li>字符缓冲输 出流: BufferedWriter。</li>
<li>作用: 提高字符输出流写取数据的性能，除此之外多了换行功能</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BufferedWriter(Writer w)</td>
<td>可以把低级的字符输出流包装成一个高级的<br>缓冲字符输出流管道,从而提高字符输出流写数据的性能</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void newLine()</td>
<td>换行操作</td>
</tr>
</tbody></table>
<h2 id="4-转换流"><a href="#4-转换流" class="headerlink" title="4.转换流"></a>4.转换流</h2><h3 id="4-1字符输入转换流"><a href="#4-1字符输入转换流" class="headerlink" title="4.1字符输入转换流"></a>4.1字符输入转换流</h3><ul>
<li>可以提取文件(GBK)的原始字节流，原始字节不会存在问题。</li>
<li>然后把字节流以指定编码转换成字符输入流，这样字符输入流中的字符就不乱码了</li>
<li>字符输入转换流: InputStreamReader, 可以把原始的字节流按照指定编码转换成字符输入流。</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public InputStreamReader(InputStream is)</td>
<td>可以把原始的字节流按照代码默认编码<br>转换成字符输入流。几乎不用，与默认的FileReader一样。</td>
</tr>
<tr>
<td>public InputStreamReader(InputStream is，String charset)</td>
<td>可以把原始的字节流按照指定编码转<br>换成字符输入流，这样字符流中的字符就不乱码了(重点)</td>
</tr>
</tbody></table>
<h3 id="4-2字符输出转换流"><a href="#4-2字符输出转换流" class="headerlink" title="4.2字符输出转换流"></a>4.2字符输出转换流</h3><table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public OutputStreamWriter(OutputStream os)</td>
<td>可以把原始的字节输出流按照代码默认编码转换成字符输出流。几乎不用。</td>
</tr>
<tr>
<td>public OutputStreamWriter(OutputStream oS, String charset)</td>
<td>可以把原始的字 节输出流按照指定编码转换成字符输出流(重点)</td>
</tr>
</tbody></table>
<h2 id="5-对象序列化"><a href="#5-对象序列化" class="headerlink" title="5.对象序列化"></a>5.对象序列化</h2><h3 id="5-1对象序列化"><a href="#5-1对象序列化" class="headerlink" title="5.1对象序列化"></a>5.1对象序列化</h3><ul>
<li>作用:以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化。</li>
<li>使用到的流是对象字节输出流: ObjectOutputStream</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ObjectOutputStream(OutputStream out)</td>
<td>把低级字节输出流包装成高级的对象字节输出流</td>
</tr>
</tbody></table>
<h3 id="5-2-对象反序列化"><a href="#5-2-对象反序列化" class="headerlink" title="5.2 对象反序列化"></a>5.2 对象反序列化</h3><ul>
<li>使用到的流是对象字节输入流: ObjectInputStream</li>
<li>作用:<ul>
<li>以内存为基准，把存储到磁盘文件中去的对象数据恢复成内存中的对象，称为对象反序列化。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ObjectInputStream( InputStream out)</td>
<td>把低级字节输如流包装成高级的对象字节输入流</td>
</tr>
</tbody></table>
<h2 id="6-打印流"><a href="#6-打印流" class="headerlink" title="6.打印流"></a>6.打印流</h2><ul>
<li>作用:打印流可以实现方便、高效的打印数据到文件中去。打印流-般是指: PrintStream, PrintWriter两个类。</li>
<li>可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97,打印boolean的true, 写出去就是true。</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public PrintStream(OutputStream os)</td>
<td>打印流直接通向字节输出流管道</td>
</tr>
<tr>
<td>public PrintStream(File f)</td>
<td>打印流直接通向文件对象</td>
</tr>
<tr>
<td>public PrintStream(String filepath)</td>
<td>打印流直接通向文件路径</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void print(Xxx xx)</td>
<td>打印任意类型的数据出去</td>
</tr>
</tbody></table>
<p>PrintWriter</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public PrintWriter(OutputStxeam os )</td>
<td>打印流直接通向字节输出流管道</td>
</tr>
<tr>
<td>public PrintWriter (Writer w)</td>
<td>打印流直接通向字符输出流管道</td>
</tr>
<tr>
<td>public PrintWriter (File f)</td>
<td>打印流直接通向文件对象</td>
</tr>
<tr>
<td>public PrintWriter (String filepath)</td>
<td>打印流直接通向文件路径</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void print(Xxx xx)</td>
<td>打印任意类型的数据出去</td>
</tr>
</tbody></table>
<p>PrintStream和PrintWriter的区别</p>
<ul>
<li>打印数据功能上是一模一样的，都是使用方便,性能高效(核心优势)</li>
<li>PrintStream继承自字节输出流OutputStream, 支持写字节数据的方法。</li>
<li>PrintWriter继承自字符输出流Writer, 支持写字符数据出去。</li>
</ul>
<h2 id="7-Properties"><a href="#7-Properties" class="headerlink" title="7.Properties"></a>7.Properties</h2><p>Properties属性集对象</p>
<ul>
<li>其实就是一个Map集合,但是我们- -般不会当集合使用，因为HashMap更好用。</li>
</ul>
<p>Properties核心作用:</p>
<ul>
<li>Properties代表的是 -一个属性文件,可以把自己对象中的键值对信息存入到-一个属性文件中去。</li>
<li>属性文件:后缀是.properties结尾的文件,里面的内容都是key=value,后续做系统配置信息的。</li>
</ul>
<p>Properties的APlI:<br>Properties和IO流结合的方法:</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void load(InputStream inStream)</td>
<td>从输入字节流读取属性列表(键和元素对)</td>
</tr>
<tr>
<td>void load(Reader reader )</td>
<td>从输入字符流读取属性列表(键和元素对)</td>
</tr>
<tr>
<td>void store(OutputStream out, String comments )</td>
<td>将此属性列表(键和元素对)写入此Properties表中，以适合于使用load(InputStream)方法的格式写入输出字节流</td>
</tr>
<tr>
<td>void store(Writer writer, String comments )</td>
<td>将此属性列表(键和元素对)写入此Properties表中，以适合于使用用load(Reader)方法的格式写入输出字符流</td>
</tr>
<tr>
<td>public 0bject setProperty(String key, String value)</td>
<td>保存键值对(put)</td>
</tr>
<tr>
<td>public String getProperty(String key)</td>
<td>使用此属性列表中指定的键搜索属性值(get)</td>
</tr>
<tr>
<td>public Set<String> stringPropertyNames()</String></td>
<td>所有键的名称的集合(keySet())</td>
</tr>
</tbody></table>
<h2 id="8-IO框架"><a href="#8-IO框架" class="headerlink" title="8.IO框架"></a>8.IO框架</h2><p>commons-io概述</p>
<ul>
<li>commons-io是 apache开源基金组织提供的- -组有关I0操作的类库，可以提高I0功能开发的效率。</li>
<li>commons-io工具包提供了很多有关io操作的类。有两个主要的类FileUtils, l0Utils</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String readFileToString(File file, String encoding)</td>
<td>读取文件中的数据，返回字符串</td>
</tr>
<tr>
<td>void copyFile(File srcFile, File destFile)</td>
<td>复制文件。</td>
</tr>
<tr>
<td>void copyDirectoryToDirectory(File srcDir, File destDir)</td>
<td>复制文件夹。</td>
</tr>
</tbody></table>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>什么是线程?</p>
<ul>
<li>线程(thread)是 一个程序内部的一条执行路径。</li>
<li>我们之前启动程序执行后，main方法的执行其实就是一条单独的执行路径。</li>
<li>程序中如果只有一条执行路径，那么这个程序就是单线程的程序。</li>
</ul>
<p>多线程</p>
<ul>
<li>多线程是指从软硬件.上实现多条执行流程的技术。</li>
</ul>
<h2 id="1-创建多线程"><a href="#1-创建多线程" class="headerlink" title="1.创建多线程"></a>1.创建多线程</h2><h3 id="1-1继承Thread类"><a href="#1-1继承Thread类" class="headerlink" title="1.1继承Thread类"></a>1.1继承Thread类</h3><ul>
<li>Java是通过java.lang.Thread 类来代表线程的。</li>
<li>按照面向对象的思想，Thread类应该提供了实现多线程的方式。</li>
</ul>
<p>多线程的实现方案一:继承Thread类</p>
<ol>
<li>定义一个子类MyThread继承线程类java.lang.Thread,重写run()方法</li>
<li>创建MyThread类的对象</li>
<li>调用线程对象的start()方法启动线程(启动后还是执行run方法的)</li>
</ol>
<p>方式一优缺点:</p>
<ul>
<li>优点:编码简单</li>
<li>缺点:线程类已经继承Thread,无法继承其他类，不利于扩展。</li>
</ul>
<h3 id="1-2实现Runnable接口"><a href="#1-2实现Runnable接口" class="headerlink" title="1.2实现Runnable接口"></a>1.2实现Runnable接口</h3><ol>
<li>定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法</li>
<li>创建MyRunnable任务对象</li>
<li>把MyRunnable任务 对象交给Thread处理。</li>
<li>调用线程对象的start()方 法启动线程</li>
</ol>
<p>Thread的构造器</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Thread(String name)</td>
<td>可以为当前线程指定名称</td>
</tr>
<tr>
<td>public Thread(Runnable target}</td>
<td>封装Runnable对象成为线程对象</td>
</tr>
<tr>
<td>public Thread(Runnable target,String name )</td>
<td>封装Runnable对象成为线程对象，并指定线程名称</td>
</tr>
</tbody></table>
<p>优缺点</p>
<ul>
<li>优点:线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</li>
<li>缺点:编程多一层对象包装，如果线程有执行结果是不可以直接返回的。</li>
</ul>
<p>多线程的实现方案二:实现Runnable接口(匿名内部类形式)</p>
<ol>
<li>可以创建Runnable的匿名 内部类对象。</li>
<li>交给Thread处理 。</li>
<li>调用线程对象的start()启动线程。</li>
</ol>
<h3 id="1-3利用Callable、FutureTask接口实现。"><a href="#1-3利用Callable、FutureTask接口实现。" class="headerlink" title="1.3利用Callable、FutureTask接口实现。"></a>1.3利用Callable、FutureTask接口实现。</h3><ol>
<li>得到任务对象<ol>
<li>定义类实现Callable接口，重写call方法,封装要做的事情。</li>
<li>用FutureTask把Callable对 象封装成线程任务对象。</li>
</ol>
</li>
<li>把线程任务对象交给Thread处理。</li>
<li>调用Thread的start方法启动线程，执行任务</li>
<li>线程执行完毕后、通过FutureTask的get方法去获取任务执行的结果。</li>
</ol>
<p>API</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FutureTask&lt;&gt;(Callable call)</td>
<td>把Callable对象封装成FutureTask对象。</td>
</tr>
<tr>
<td>public V get() throws Exception</td>
<td>获取线程执行call方法返回的结果。</td>
</tr>
</tbody></table>
<p>优缺点</p>
<ul>
<li>优点:<ul>
<li>线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</li>
<li>可以在线程执行完毕后去获取线程执行的结果。</li>
</ul>
</li>
<li>缺点:编码复杂一点。</li>
</ul>
<pre><code class="java">import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.IntStream;
public class test &#123;
    public static void main(String[] args)  &#123;
        Callable&lt;String&gt; c = new My(100);
        FutureTask&lt;String&gt; f = new FutureTask&lt;&gt;(c);
        Thread t = new Thread(f);
        t.start();
        String s = null;
        try &#123;
            s = f.get();
        &#125; catch (Exception  e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(s);
        IntStream.rangeClosed(1,500).forEach(i-&gt; System.out.println(&quot;主线程&quot;+i));
    &#125;
&#125;
class My implements Callable&lt;String&gt; &#123;
    private final int n;

    public My(int n) &#123;
        this.n = n;
    &#125;
    @Override
    public String call() throws Exception &#123;
        AtomicInteger sum = new AtomicInteger();
        IntStream.rangeClosed(1,n).forEach(sum::addAndGet);
        return &quot;子线程执行结果是&quot;+sum;
    &#125;
&#125;
</code></pre>
<h2 id="2-Thread常用方法"><a href="#2-Thread常用方法" class="headerlink" title="2.Thread常用方法"></a>2.Thread常用方法</h2><p>Thread常用API说明</p>
<ul>
<li>Thread常 用方法:获取线程名称getName()、设置名称setName()、获取当前线程对象currentThread()。</li>
</ul>
<p>Thread获取和设置线程名称</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String getName()</td>
<td>获取当前线程的名称，默认线程名称是Thread-索引</td>
</tr>
<tr>
<td>void setName(String name)</td>
<td>将此线程的名称更改为指定的名称，通过构造器也可以设置线程名称</td>
</tr>
<tr>
<td>public static Thread currentThread():</td>
<td>返回对当前正在执行的线程对象的引用</td>
</tr>
</tbody></table>
<h2 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3.线程安全"></a>3.线程安全</h2><p>多个线程同时操作同一个共享资源的时候可能会出现业务安全问题,称为线程安全问题。</p>
<h2 id="4-线程同步"><a href="#4-线程同步" class="headerlink" title="4.线程同步"></a>4.线程同步</h2><h3 id="4-1目的："><a href="#4-1目的：" class="headerlink" title="4.1目的："></a>4.1目的：</h3><ul>
<li>为了解决线程安全问题。    </li>
</ul>
<p>线程同步的核心思想</p>
<ul>
<li>加锁, 把共享资源进行上锁,每次只能一个线程进 入访问完毕以后解锁,然后其他线程才能进来。</li>
</ul>
<h3 id="4-2同步代码块"><a href="#4-2同步代码块" class="headerlink" title="4.2同步代码块"></a>4.2同步代码块</h3><ul>
<li>作用:把出现线程安全问题的核心代码给上锁。</li>
<li>原理:每次只能-一个线程进入,执行完毕后自动解锁,其他线程才可以进来执行。</li>
</ul>
<pre><code class="java">synchronized(同步锁对象) &#123;
操作共享资源的代码(核心代码)
&#125;
</code></pre>
<p>锁对象要求</p>
<ul>
<li>理论上:锁对象只要对于当前同时执行的线程来说是同一个对象即可。</li>
<li>锁对象用任意唯一的对象不好,会影响其他无关线程的执行。</li>
<li>规范上:建议使用共享资源作为锁对象。</li>
<li>对于实例方法建议使用this作为锁对象。</li>
<li>对于静态方法建议使用字节码(类名.class) 对象作为锁对象。</li>
</ul>
<h3 id="4-3同步方法"><a href="#4-3同步方法" class="headerlink" title="4.3同步方法"></a>4.3同步方法</h3><ul>
<li>作用:把出现线程安全问题的核心方法给.上锁。</li>
<li>原理:每次只能一一个线程进入，执行完毕以后自动解锁,其他线程才可以进来执行。</li>
</ul>
<pre><code class="java">修饰符synchronized返回值类型方法名称(形参列表) &#123;
操作共享资源的代码
&#125;
</code></pre>
<p>同步方法底层原理</p>
<ul>
<li>同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。</li>
<li>如果方法是实例方法:同步方法默认用this作为的锁对象。但是代码要高度面向对象!</li>
<li>如果方法是静态方法:同步方法默认用类名.class作为的锁对象。</li>
</ul>
<h3 id="4-4Lock锁"><a href="#4-4Lock锁" class="headerlink" title="4.4Lock锁"></a>4.4Lock锁</h3><ul>
<li>为了更清晰的表达如何加锁和释放锁，JDK5以后提供了-个新的锁对象Lock,更加灵活、方便。</li>
<li>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。</li>
<li>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ReentrantLock()</td>
<td>获得Lock锁的实现类对象</td>
</tr>
<tr>
<td>void lock()</td>
<td>获得锁</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
</tbody></table>
<h2 id="5-线程通信"><a href="#5-线程通信" class="headerlink" title="5.线程通信"></a>5.线程通信</h2><p>什么是线程通信、如何实现?</p>
<ul>
<li>所谓线程通信就是线程间相互发送数据。</li>
</ul>
<p>线程通信常见形式</p>
<ul>
<li>通过共享一个数据的方式实现。</li>
<li>根据共享数据的情况决定自己该怎么做，以及通知其他线程怎么做。</li>
</ul>
<p>线程通信实际应用模型</p>
<ul>
<li>生产者与消费者模型:生产者线程负责生产数据，消费者线程负责消费生产者产生的数据。</li>
<li> 般要求:生产者线程生产完数据后唤醒消费者，然后等待自己，消费者消费完该数据后唤醒生产者,然后等待自己。</li>
</ul>
<p>线程通信的前提:线程通信通常是在多个线程操作同一-个共享资源的时候需要进行通信，且要保证线程安全。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或notifyAll()方法</td>
</tr>
<tr>
<td>void notify()</td>
<td>唤醒正在等待的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>唤醒正在等待的所有线程</td>
</tr>
</tbody></table>
<h2 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6.线程池"></a>6.线程池</h2><h3 id="6-1概述"><a href="#6-1概述" class="headerlink" title="6.1概述"></a>6.1概述</h3><p>线程池就是一一个可以复用线程的技术。</p>
<p>不使用线程池的问题</p>
<ul>
<li>如果用户每发起一一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。</li>
</ul>
<h3 id="6-2实现线程池"><a href="#6-2实现线程池" class="headerlink" title="6.2实现线程池"></a>6.2实现线程池</h3><p>JDK 5.0起提供了代表线程池的接口: ExecutorService</p>
<p>实现线程池对象</p>
<ol>
<li><p>使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象</p>
<ul>
<li><p>参数说明</p>
<pre><code class="java">public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime ,
                          TimeUnit unit,
                          BlockingQueue &lt;Runnable&gt; workQueue,
                          ThreadFactory threadF actory,
                          RejectedExecut: ionHandler handler)
参数一:指定线程池的线程数量(核心线程):corePoolSize    不能小于0
参数二:指定线程池可支持的最大线程数:maximumPoolSize    最大数量&gt;=核心线程数量
参数三:指定临时线程的最大存活时间: keepAliveTime     不能小于0
参数四:指定存活时间的单位(秒、分、时、天): unit       时间单位
参数五:指定任务队列: workQueue                      不能为null
参数六:指定用哪个线程工厂创建线程: threadFactory    不能为null
参数七:指定线程忙，任务满的时候，新任务来了怎么办:handler    不能为null
</code></pre>
</li>
</ul>
</li>
<li><p>使用Executors (线程池的工具类)调用方法返回不同特点的线程池对象</p>
</li>
</ol>
<h3 id="6-3线程池处理任务"><a href="#6-3线程池处理任务" class="headerlink" title="6.3线程池处理任务"></a>6.3线程池处理任务</h3><h4 id="6-3-1-ThreadPoolExecutor"><a href="#6-3-1-ThreadPoolExecutor" class="headerlink" title="6.3.1 ThreadPoolExecutor"></a>6.3.1 ThreadPoolExecutor</h4><p>ExecutorService的常用方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void execute( Runnable command)</td>
<td>执行任务/命令，没有返回值，一般用来执行Runnable 任务</td>
</tr>
<tr>
<td>Future<T> submit(Callable<T> task)</T></T></td>
<td>执行任务，返回未来任务对象获取线程结果，一般拿来执行Callable 任务</td>
</tr>
<tr>
<td>void shutdown()</td>
<td>等任务执行完毕后关闭线程池</td>
</tr>
<tr>
<td>List&lt; Runnable&gt; shutdownNow( )</td>
<td>立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</td>
</tr>
</tbody></table>
<p>新任务拒绝策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>详解</th>
</tr>
</thead>
<tbody><tr>
<td>ThreadPoolExecutor . AbortPolicy</td>
<td>丢弃任务并抛出RejectedExecutionException异常。是默认的策略</td>
</tr>
<tr>
<td>ThreadPoolExecutor .DiscardPolicy:</td>
<td>丢弃任务，但是不抛出异常这是不推荐的做法</td>
</tr>
<tr>
<td>ThreadPoolExecutor .Discard0ldestPolicy</td>
<td>抛弃队列中等待最久的任务然后把当前任务加入队列中</td>
</tr>
<tr>
<td>ThreadPoolExecutor . CallerRunsPolicy</td>
<td>由主线程负责调用任务的run(方法从而绕过线程池直接执行</td>
</tr>
</tbody></table>
<p><strong>任务占满了主线程和等待队列才会开启临时线程</strong></p>
<p>线程池处理Runnable 任务</p>
<pre><code class="java">import java.util.concurrent.*;

public class test &#123;
    public static void main(String[] args) &#123;
        ExecutorService pool = new ThreadPoolExecutor(3,5,
                6, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(5),
                Executors.defaultThreadFactory(),new ThreadPoolExecutor.CallerRunsPolicy());
        my m = new my();
        pool.execute(m);
        pool.execute(m);
        pool.execute(m);
        pool.execute(m);
        pool.execute(m);
        pool.execute(m);
        pool.execute(m);
        pool.execute(m);
        pool.execute(m);
        pool.execute(m);
        pool.execute(m);
        pool.execute(m);
    &#125;
&#125;
class my implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            for (int i=0;i&lt;5;i++)&#123;
                System.out.println(Thread.currentThread().getName()+&quot;输出了&quot;+i);
                Thread.sleep(100000000);
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>Callable 任务</p>
<pre><code class="java">import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.IntStream;

public class test &#123;
    public static void main(String[] args) &#123;
        ExecutorService pool = new ThreadPoolExecutor(3,5,
                6, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(5),
                Executors.defaultThreadFactory(),new ThreadPoolExecutor.CallerRunsPolicy());
        My m = new My(100);
        Future&lt;String&gt; s1 = pool.submit(m);
        Future&lt;String&gt; s2 = pool.submit(m);
        Future&lt;String&gt; s3 = pool.submit(m);
        Future&lt;String&gt; s4 = pool.submit(m);
        Future&lt;String&gt; s5 = pool.submit(m);
        Future&lt;String&gt; s6 = pool.submit(m);
        Future&lt;String&gt; s7 = pool.submit(m);
        Future&lt;String&gt; s8 = pool.submit(m);
        Future&lt;String&gt; s9 = pool.submit(m);
        Future&lt;String&gt; s0 = pool.submit(m);
        try &#123;
            System.out.println(s1.get());
            System.out.println(s2.get());
            System.out.println(s3.get());
            System.out.println(s4.get());
            System.out.println(s5.get());
            System.out.println(s6.get());
            System.out.println(s7.get());
            System.out.println(s8.get());
            System.out.println(s9.get());
            System.out.println(s0.get());
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
class My implements Callable&lt;String&gt; &#123;
    private final int n;

    public My(int n) &#123;
        this.n = n;
    &#125;
    @Override
    public String call() throws Exception &#123;
        AtomicInteger sum = new AtomicInteger();
        IntStream.rangeClosed(1,n).forEach(sum::addAndGet);
        Thread.sleep(1000);
        return Thread.currentThread().getName()+&quot;执行结果是&quot;+sum;
    &#125;
&#125;
</code></pre>
<h4 id="6-3-2-Executors"><a href="#6-3-2-Executors" class="headerlink" title="6.3.2 Executors"></a>6.3.2 Executors</h4><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static ExecutorService newCachedThreadPool()</td>
<td>线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。</td>
</tr>
<tr>
<td>public static ExecutorService newFixedThreadPool(int nThreads)</td>
<td>创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充个新线程替代它。</td>
</tr>
<tr>
<td>public static ExecutorService newsingleThreadExecutor ()</td>
<td>创建只有一个线程的线程池对象， 如果该线程出现异常而结束，那么线程池会补充个新线程。</td>
</tr>
<tr>
<td>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td>
<td>创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</td>
</tr>
</tbody></table>
<p><strong>主意: Executors的底层其实也是基于线程池的实现类ThreadPoolExecutor创建线程池对象的。</strong></p>
<p>Executors使用可能存在的陷阱</p>
<ul>
<li>大型并发系统环境中使用Executors如果不注意 可能会出现系统风险。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>存在问题</th>
</tr>
</thead>
<tbody><tr>
<td>public static ExecutorService newFixedThreadPool(int nThreads )</td>
<td>允许请求的任务队列长度是Integer.MAX _VALUE,可能出现OOM错误( java.lang.OutOfMemoryError )</td>
</tr>
<tr>
<td>public static ExecutorService newSingleThreadExecutor()</td>
<td>允许请求的任务队列长度是Integer.MAX _VALUE,可能出现OOM错误( java.lang.OutOfMemoryError )</td>
</tr>
<tr>
<td>public static ExecutorService newCachedThreadPool()</td>
<td>创建的线程数量最大上限是Integer.MAX _VALUE,线程数可能会随着任务1:1增长，也可能出现OOM错误</td>
</tr>
<tr>
<td>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td>
<td>创建的线程数量最大上限是Integer.MAX _VALUE,线程数可能会随着任务1:1增长，也可能出现OOM错误</td>
</tr>
</tbody></table>
<h2 id="7-定时器"><a href="#7-定时器" class="headerlink" title="7.定时器"></a>7.定时器</h2><p>定时器</p>
<ul>
<li>定时器是一种控制任务延时调用，或者周期调用的技术。</li>
<li>作用:闹钟、定时邮件发送。</li>
</ul>
<p>定时器的实现方式</p>
<ul>
<li>方式一:Timer</li>
<li>方式二: ScheduledExecutorService</li>
</ul>
<h3 id="7-1-Timer定时器"><a href="#7-1-Timer定时器" class="headerlink" title="7.1 Timer定时器"></a>7.1 Timer定时器</h3><table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Timer( )</td>
<td>创建Timer定时器对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void schedule(TimerTask task, 1ong delay, long period)</td>
<td>开启一个定时器，<br>按照计划处理T imerTask任务</td>
</tr>
</tbody></table>
<p>Timer定时器的特点和存在的问题</p>
<ol>
<li>Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入。</li>
<li>可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行。</li>
</ol>
<h3 id="7-2ScheduledExecutorService定时器"><a href="#7-2ScheduledExecutorService定时器" class="headerlink" title="7.2ScheduledExecutorService定时器"></a>7.2ScheduledExecutorService定时器</h3><p>ScheduledExecutorService是jdk1 .5中引入了并发包，目的是为了弥补Timer的缺陷, ScheduledExecutorService内部为线程池。</p>
<table>
<thead>
<tr>
<th>Executors的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td>
<td>得到线程池对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>ScheduledExecutorService的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate( Runnable command, long initialDelay, long period,TimeUnit unit)</td>
<td>周期调度方法</td>
</tr>
</tbody></table>
<p>ScheduledExecutorService的优点</p>
<ol>
<li>基于线程池，某个任务的执行情况不会影响其他定时任务的执行。</li>
</ol>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络通信基本模式</p>
<ul>
<li>常见的通信模式有如下2种形式: Client-Server(CS)、Browser/Server(BS)</li>
</ul>
<h2 id="1-三要素"><a href="#1-三要素" class="headerlink" title="1.三要素"></a>1.三要素</h2><p>IP地址</p>
<ul>
<li>:设备在网络中的地址，是唯一的标识。<ul>
<li>ipconfig:查看本机IP地址</li>
<li>ping IP地址:检查网络是否连通</li>
</ul>
</li>
<li>特殊IP地址<ul>
<li>本机IP: 127.0.0.1或者localhost:称为回送地址也可称本地回环地址，只会寻找当前所在本机。</li>
</ul>
</li>
</ul>
<p>端口:</p>
<ul>
<li>应用程序在设备中唯一的标识。</li>
</ul>
<p>协议:</p>
<ul>
<li>数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。</li>
</ul>
<h3 id="1-1IP地址"><a href="#1-1IP地址" class="headerlink" title="1.1IP地址"></a>1.1IP地址</h3><ul>
<li>全称”互联网协议地址”，是分配给.上网设备的唯一标志。</li>
<li>常见的IP分类为: IPv4和IPv6</li>
<li>IPv6: 128位(16个字节) ,号称可以为地球每一粒沙子编号。</li>
<li>IPv6分成8个整数，每个整数用四个十六进制位表示，数之间用冒号(: )分开。</li>
<li>形式<ul>
<li>公网地址</li>
<li>私有地址(局域网使用)。<ul>
<li>192.168.开头的就是常见的局域网地址,范围即为192.168.0.0–192.168.255.255, 专门为组织机构内部使用。</li>
</ul>
</li>
</ul>
</li>
<li>命令</li>
</ul>
<p>此类表示Internet协议(IP) 地址。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static InetAddress getLocalHost( )</td>
<td>返回本主机的地址对象</td>
</tr>
<tr>
<td>public static InetAddress getByName(String host)</td>
<td>得到指定主机的IP地址对象，参数是域名或者IP地址</td>
</tr>
<tr>
<td>public String getHostName( )</td>
<td>获取此IP地址的主机名</td>
</tr>
<tr>
<td>public String getHostAddress()</td>
<td>返回IP地址</td>
</tr>
<tr>
<td>public boolean isReachable(int timeout )</td>
<td>在指定毫秒内连通该IP地址对应的主机，连通返回true</td>
</tr>
</tbody></table>
<h3 id="1-2端口号"><a href="#1-2端口号" class="headerlink" title="1.2端口号"></a>1.2端口号</h3><p>端口号</p>
<ul>
<li>端口号:标识正在计算机设备上运行的进程(程序) ,被规定为一个16位的二进制，范围是0~65535。</li>
</ul>
<p>端口类型</p>
<ul>
<li>周知端口: 0~1023,被预先定义的知名应用占用(如: HTTP占用80，FTP占用21)</li>
<li>注册端口: 1024~49151, 分配给用户进程或某些应用程序。( 如: Tomcat占用8080, MySQL占用3306)</li>
<li>动态端口: 49152到65535,之所以称为动态端口，是因为它- -般不固定分配某种进程，而是动态分配。</li>
<li><strong>注意:我们自己开发的程序选择注册端口，且-一个设备中不能出现两个程序的端口号-样，否则出错。</strong></li>
</ul>
<h3 id="1-3协议"><a href="#1-3协议" class="headerlink" title="1.3协议"></a>1.3协议</h3><p>通信协议</p>
<ul>
<li>连接和通信数据的规则被称为网络通信协议</li>
</ul>
<p>网络通信协议有两套参考模型</p>
<ul>
<li>OSI参考模型: 世界互联协议标准，全球通信规范，由于此模型过于理想化，未能在因特网上进行广泛推广。</li>
<li>TCP/IP参考模型(或TCP/IP协议): 事实上的国际标准。</li>
</ul>
<table>
<thead>
<tr>
<th>OSI参考模型</th>
<th>TCP/IP参考模型</th>
<th>各层对应</th>
<th>面向操作</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用层</td>
<td>HTTP、FTP、 DNS、SMT…</td>
<td>应用程序需要关注的:<br>浏览器，邮箱。<br>程序员一般在这一层开发</td>
</tr>
<tr>
<td>表示层</td>
<td>应用层</td>
<td>HTTP、FTP、 DNS、SMT…</td>
<td>应用程序需要关注的:<br>浏览器，邮箱。<br>程序员一般在这一层开发</td>
</tr>
<tr>
<td>会话层</td>
<td>应用层</td>
<td>HTTP、FTP、 DNS、SMT…</td>
<td>应用程序需要关注的:<br>浏览器，邮箱。<br>程序员一般在这一层开发</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>TCP、UDP..</td>
<td>选择使用的TCP , UDP协议</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
<td>IP、ICMP..</td>
<td>封装源和目标IP，<br>进行路径选择</td>
</tr>
<tr>
<td>数据链路层</td>
<td>数据链路层+物理</td>
<td>物理寻址、比特流…</td>
<td>物理设备中传输</td>
</tr>
<tr>
<td>物理层</td>
<td>数据链路层+物理</td>
<td>物理寻址、比特流…</td>
<td>物理设备中传输</td>
</tr>
</tbody></table>
<p>传输层的2个常见协议</p>
<ul>
<li>TCP(Transmission Control Protocol) : 传输控制协议</li>
<li>UDP(User Datagram Protocol): 用户数据报协议</li>
</ul>
<p>TCP协议特点</p>
<ul>
<li>使用TCP协议,必须双方先建立连接,它是一种面向连接的可靠通信协议。</li>
<li>传输前，采用“三次握手”方式建立连接，所以是可靠的。</li>
<li>在连接中可进行大数据量的传输。</li>
<li>连接、发送数据都需要确认，且传输完毕后,还需释放已建立的连接,通信效率较低。</li>
</ul>
<p>TCP协议通信场景</p>
<ul>
<li>对信息安全要求较高的场景，例如:文件下载、金融等数据通信。</li>
</ul>
<p>UDP协议:</p>
<ul>
<li>UDP是一种无连接、不可靠传输的协议。</li>
<li>将数据源IP、目的地IP和端口封装成数据包，不需要建立连接</li>
<li>每个数据包的大小限制在64KB内</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
<li>可以广 播发送,发送数据结束时无需释放资源，开销小，速度快。</li>
</ul>
<p>UDP协议通信场景</p>
<ul>
<li>语音通话,视频会话等。</li>
</ul>
<h2 id="2-UDP通信"><a href="#2-UDP通信" class="headerlink" title="2.UDP通信"></a>2.UDP通信</h2><h3 id="2-1入门"><a href="#2-1入门" class="headerlink" title="2.1入门"></a>2.1入门</h3><p>UDP协议的特点</p>
<ul>
<li>UDP是一种无连接、不可靠传输的协议。</li>
<li>将数据源IP、目的地IP和端口以及数据封装成数据包，大小限制在64KB内，直接发送出去即可。</li>
</ul>
<p>DatagramPacket:数据包对象</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public DatagramPacket(byte[] buf, int length, InetAddress address, int port)</td>
<td>创建发送端数据包对象<br>buf:要发送的内容，字节数组<br>length:要发送内容的字节长度<br>address:接收端的IP地址对象<br>port:接收端的端口号</td>
</tr>
<tr>
<td>oublic DatagramPacket(byte[] buf, int length)</td>
<td>创建接收端的数据包对象<br>buf:用来存储接收的内容<br>length:能够接收内容的长度</td>
</tr>
</tbody></table>
<p>DatagramPacket常用方法.</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int getLength()</td>
<td>获得实际接收到的字节个数</td>
</tr>
</tbody></table>
<p>DatagramSocket:发送端和接收端对象</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public DatagramSocket( )</td>
<td>创建发送端的Socket对象，系统会随机分配个端口号。</td>
</tr>
<tr>
<td>public DatagramSocket(int port)</td>
<td>创建接收端的Socket对象并指定端口号</td>
</tr>
</tbody></table>
<p>DatagramSocket类成员方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void send(DatagramPacket dp)</td>
<td>发送数据包</td>
</tr>
<tr>
<td>public void receive(DatagramPacket p)</td>
<td>接收数据包</td>
</tr>
</tbody></table>
<h3 id="2-2多发多收"><a href="#2-2多发多收" class="headerlink" title="2.2多发多收"></a>2.2多发多收</h3><p>用while写死循环</p>
<h4 id="2-2-1-UDP的三种通信方式"><a href="#2-2-1-UDP的三种通信方式" class="headerlink" title="2.2.1 UDP的三种通信方式"></a>2.2.1 UDP的三种通信方式</h4><ul>
<li>单播: 单台主机与单台主机之间的通信。</li>
<li>广播:当前主机与所在网络中的所有主机通信。</li>
<li>组播:当前主机与选定的一-组主机的通信。</li>
</ul>
<p>实现广播</p>
<ul>
<li>使用广播地址: 255.255.255.255 </li>
<li>具体操作:<ol>
<li>发送端发送的数据包的目的地写的是广播地址、且指定端口。<br>(255.255.255.255，9999)</li>
<li>本机所在网段的其他主机的程序只要匹配端口成功即就可以收到消息了。(9999)</li>
</ol>
</li>
</ul>
<p>实现组播</p>
<ul>
<li>使用组播地址: 224.0.0.0 ~ 239.255.255.255</li>
<li>具体操作:<ol>
<li>发送端的数据包的目的地是组播IP (例如: 224.0.1.1, 端口: 9999)</li>
<li>接收端必须绑定该组播IP(224.0.1.1),端口还要对应发送端的目的端口9999，这样即可接收该组播消息。</li>
<li>DatagramSocket的子类MulticastSocket可以在接收端绑定组播IP。</li>
</ol>
</li>
</ul>
<h2 id="3-TCP通信"><a href="#3-TCP通信" class="headerlink" title="3.TCP通信"></a>3.TCP通信</h2><p>TCP协议回顾:</p>
<ul>
<li>TCP是一 种面向连接，安全、可靠的传输数据的协议</li>
<li>传输前，采用“三次握手”方式，点对点通信，是可靠的</li>
<li>在连接中可进行大数据量的传输</li>
</ul>
<p>Socket</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Socket(String host，int port)</td>
<td>创建发送端的Socket对象与服务端连接，参数为服务端程序的ip和端口。</td>
</tr>
</tbody></table>
<ol>
<li>创建客户端的Socket对象，请求与服务端的连接。</li>
<li>使用socket对 象调用getOutputStream()方法得到字节输出流。</li>
<li>使用字节输出流完成数据的发送。</li>
</ol>
<ul>
<li>OutputStream getOutputStream():获得字节输出流对象(发)</li>
<li>InputStream getInputStream():获得字节输入流对象(收)</li>
</ul>
<p>ServerSocket(服务端)</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ServerSocket(int port)</td>
<td>注册服务端端口</td>
</tr>
</tbody></table>
<p>ServerSocket类成员方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Socket accept()</td>
<td>等待接收客户端的Socket通信连接<br>连接成功返回Socket对象与客户端建立端到端通信</td>
</tr>
</tbody></table>
<ol>
<li>创建ServerSocket对象， 注册服务端端口。</li>
<li>调用ServerSocket对象的accept()方法， 等待客户端的连接，并得到Socket管道对象</li>
<li>通过Socket对象调用getInputStream()方法得到字节输入流、 完成数据的接收。</li>
<li>释放资源:关闭socket管道</li>
</ol>
<p>多发多收</p>
<ol>
<li>可以使用死循环控制服务端收完消息继续等待接收下一个消息。</li>
<li>客户端也可以使用死循环等待用户不断输入消息。</li>
<li>客户端一旦输入了exit, 则关闭客户端程序,并释放资源。</li>
</ol>
<h2 id="4-BS架构"><a href="#4-BS架构" class="headerlink" title="4.BS架构"></a>4.BS架构</h2><pre><code class="java">import java.io.IOException;
import java.io.PrintStream;
import java.net.ServerSocket;
import java.net.Socket;

public class test &#123;
    public static void main(String[] args) throws Exception &#123;
        ServerSocket ss = new ServerSocket(8080);
        while (true)&#123;
            Socket s = ss.accept();
            new my(s).start();
        &#125;


    &#125;
&#125;
class my extends Thread&#123;
    private Socket socket;
    public my(Socket socket) &#123;
        this.socket = socket;
    &#125;

    @Override
    public void run() &#123;
        PrintStream ps = null;
        try &#123;
            ps = new PrintStream(socket.getOutputStream());
            ps.println(&quot;http/1.1 200 OK&quot;);
            ps.println(&quot;Content-Type:text/html;charset=UTF-8&quot;);
            ps.println();
            ps.println(&quot;&lt;span style=&#39;color : red;font-size:90px &#39;&gt;《你好啊》&lt;/span&gt;&quot;);
            ps.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><ul>
<li>单元测试就是针对最小的功能单元编写测试代码, Java程序最小的功能单元是方法，因此，单元测试就是针对Java</li>
<li>方法的测试，进而检查方法的正确性。</li>
</ul>
<p>目前测试方法是怎么进行的，存在什么问题</p>
<ul>
<li>只有一个main方法,如果-一个方法的测试失败了,其他方法测试会受到影响。</li>
<li>无法得到测试的结果报告，需要程序员自己去观察测试是否成功。<ul>
<li>无法实现自动化测试。</li>
</ul>
</li>
</ul>
<h2 id="1-Junit单元测试框架"><a href="#1-Junit单元测试框架" class="headerlink" title="1.Junit单元测试框架"></a>1.Junit单元测试框架</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><ul>
<li>jUnit是使 用Java语言实现的单元测试框架，它是开源的，Java开 发者都应当学习并使用JUnit编写单元测试。</li>
<li>此外，几乎所有的IDE工具都集成了JUnit,这样我们就可以直接在IDE中编写并运行JUnit测试, jUnit目 前最新版本是5。</li>
</ul>
<p>优点</p>
<ul>
<li>jUnit可以灵活的选择执行哪些测试方法，可以一键执行全 部测试方法。</li>
<li>Junit可以生成全部方法的测试报告。</li>
<li>单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。</li>
</ul>
<h3 id="1-2-入门"><a href="#1-2-入门" class="headerlink" title="1.2 入门"></a>1.2 入门</h3><ol>
<li>将JUnit的jar包导入到项目中<ul>
<li>IDEA通常整合好了Junit框架，一般不需要导入。</li>
<li>如果IDEA没有整合好，需要自己手工导入如下2个jUnit的jar包到模块</li>
</ul>
</li>
<li>编写测试方法:该测试方法必须是公共的无参数无返回值的非静态方法。</li>
<li>在测试方法_上使用@Test注解:标注该方法是一-个测试方法</li>
<li>在测试方法中完成被测试方法的预期正确性测试。</li>
<li>选中测试方法,选择”JUnit运行”，如果测试良好则是绿色;如果测试失败，则是红色</li>
</ol>
<h3 id="1-3注解"><a href="#1-3注解" class="headerlink" title="1.3注解"></a>1.3注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>测试方法</td>
</tr>
<tr>
<td>@Before</td>
<td>用来修饰实例方法，该方法会在每一一个测试方法执行之前执行一-次。</td>
</tr>
<tr>
<td>@After</td>
<td>用来修饰实例方法，该方法会在每一个测试方法执行之 后执行一次。</td>
</tr>
<tr>
<td>@BeforeClass</td>
<td>用来静态修饰方法，该方法会在所有测试方法之前只执行一-次。</td>
</tr>
<tr>
<td>@AfterClass</td>
<td>用来静态修饰方法，该方法会在所有测试方法之后只执行一-次。</td>
</tr>
</tbody></table>
<ul>
<li>开始执行的方法:初始化资源。</li>
<li>执行完之后的方法:释放资源。</li>
</ul>
<h2 id="2-反射"><a href="#2-反射" class="headerlink" title="2.反射"></a>2.反射</h2><h3 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h3><ul>
<li>反射是指对于任何-个Class类，在”运行的时候”都可以直接得到这个类全部成分。</li>
<li>在运行时,可以直接得到这个类的构造器对象: Constructor</li>
<li>在运行时,可以直接得到这个类的成员变量对象: Field</li>
<li>在运行时,可以直接得到这个类的成员方法对象: Method</li>
<li>这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。</li>
</ul>
<p>反射的关键:</p>
<ul>
<li><p>反射的第一步都是先得到编译后的Class类对象,然后就可以得到Class的全部成分。</p>
<pre><code class="java">HelloWorld.java -&gt; javac -&gt; HelloWorld.class
Class c= HelloWorld.class; 
</code></pre>
</li>
</ul>
<h3 id="2-2-获取class类的对象"><a href="#2-2-获取class类的对象" class="headerlink" title="2.2 获取class类的对象"></a>2.2 获取class类的对象</h3><p>class类中的静态方法</p>
<ol>
<li>forName(String className)</li>
<li>类名.crass</li>
<li>对象.getClass()</li>
</ol>
<h3 id="2-3获取构造器对象"><a href="#2-3获取构造器对象" class="headerlink" title="2.3获取构造器对象"></a>2.3获取构造器对象</h3><p>使用反射技术获取构造器对象并使用</p>
<ol>
<li>获得class对象</li>
<li>获得Constructor对象</li>
<li>创建对象</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor&lt;?&gt;[] getConstructors()</td>
<td>返回所有构造器对象的数组(只能拿public的)</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[] getDeclaredConstructors()</td>
<td>返回所有构造器对象的数组，存在就能拿到</td>
</tr>
<tr>
<td>Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)</T></td>
<td>返回单个构造器对象(只能拿public的)</td>
</tr>
<tr>
<td>Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</T></td>
<td>返回单个构造器对象，存在就能拿到</td>
</tr>
</tbody></table>
<p>获取构造器的作用依然是初始化一个对象返回。</p>
<p>Constructor类中用于创建对象的方法</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>T newlnstance(Object.. initargs)</td>
<td>根据指定的构造器创建对象</td>
</tr>
<tr>
<td>public void setAccessible(boolean flag)</td>
<td>设置为true,表示取消访问检查，进行暴力反射</td>
</tr>
</tbody></table>
<h3 id="2-4获取成员变量对象"><a href="#2-4获取成员变量对象" class="headerlink" title="2.4获取成员变量对象"></a>2.4获取成员变量对象</h3><ol>
<li>获得class对象</li>
<li>获得Field对象</li>
<li>赋值或者获取值</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Field[] getFields()</td>
<td>返回所有成员变量对象的数组(只能拿public的)</td>
</tr>
<tr>
<td>Field[] getDeclaredFields()</td>
<td>返回所有成员变量对象的数组，存在就能拿到</td>
</tr>
<tr>
<td>Field getField(String name)</td>
<td>返回单个成员变量对象(只能拿public的)</td>
</tr>
<tr>
<td>Field getDeclaredField(String name)</td>
<td>返回单个成员变量对象，存在就能拿到</td>
</tr>
</tbody></table>
<p>Field类中用于取值、赋值的方法</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void set(Object obj, Object value):</td>
<td>赋值</td>
</tr>
<tr>
<td>Object get(Object obj)</td>
<td>获取值。</td>
</tr>
</tbody></table>
<h3 id="2-5获取方法对象"><a href="#2-5获取方法对象" class="headerlink" title="2.5获取方法对象"></a>2.5获取方法对象</h3><ol>
<li>获得class对象</li>
<li>获得Method对象</li>
<li>运行方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Method[] getMethods()</td>
<td>返回所有成员方法对象的数组(只能拿public的)</td>
</tr>
<tr>
<td>Method[] getDeclaredMethods()</td>
<td>返回所有成员方法对象的数组，存在就能拿到</td>
</tr>
<tr>
<td>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回单个成员方法对象(只能拿public的)</td>
</tr>
<tr>
<td>Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回单个成员方法对象， 存在就能拿到</td>
</tr>
</tbody></table>
<p>使用反射技术获取方法对象并使用</p>
<ul>
<li>获取成员方法的作用依然是在某个对象中进行执行此方法</li>
</ul>
<p>Method类中用于触发执行的方法</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>object invoke(0bject obj, object… args)</td>
<td>运行方法<br>参数一:用obj对象调用该方法<br>参数二:调用方法的传递的参数(如果没有就不写)<br>返回值:方法的返回值(如果没有就不写)</td>
</tr>
</tbody></table>
<h3 id="2-6-作用"><a href="#2-6-作用" class="headerlink" title="2.6 作用"></a>2.6 作用</h3><p>反射的作用-绕过编译阶段为集合添加数据</p>
<ul>
<li>反射是作用在运行时的技术, 此时集合的泛型将不能产生约束了,此时是可以为集合存入其他任意类型的元素的。</li>
<li>泛型只是在编译阶段可以约束集合只能操作某种数据类型,在编译成Class文件进入运行阶段的时候，其真实类型都是ArrayList了，泛型相当于被擦除了。</li>
</ul>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>概述</p>
<ul>
<li>Java注解(Annotation) 又称Java标注，是JDK5.0引入的一-种注释机制。</li>
<li>Java语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。</li>
</ul>
<p>作用</p>
<ul>
<li>对Java中类、方法、成员变量做标记，然后进行特殊处理，至于到底做何种处理由业务需求来决定。</li>
<li>例如: JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。</li>
</ul>
<h1 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1.自定义注解"></a>1.自定义注解</h1><p>自定义注解就是自己做一-个注解来使用。</p>
<pre><code class="java">public @interface注解名称&#123;
public属性类型属性名() default 默认值;
&#125;
</code></pre>
<p>特殊属性</p>
<ul>
<li>value属性， 如果只有一-个value属性的情况下，使用value属性的时候可以省略value名称不写!!</li>
<li>但是如果有多个属性,且多个属性没有默认值，那么value名称是不能省略的。</li>
</ul>
<h1 id="2-元注解"><a href="#2-元注解" class="headerlink" title="2.元注解"></a>2.元注解</h1><p>元注解:就是注解注解的注解。</p>
<p>元注解有两个:</p>
<ul>
<li>@Target: 约束自定义注解只能在哪些地方使用,</li>
<li>@Retention: 申明注解的生命周期</li>
</ul>
<p>@Target中可使用的值定义在ElementType枚举类中，常用值如下</p>
<ul>
<li>TYPE, 类,接口</li>
<li>FIELD, 成员变量</li>
<li>METHOD, 成员方法</li>
<li>PARAMETER, 方法参数</li>
<li>CONSTRUCTOR, 构造器</li>
<li>LOCAL_ _VARIABLE,局部变量</li>
</ul>
<p>@Retention中可使用的值定义在RetentionPolicy枚举类中，常用值如下</p>
<ul>
<li>SOURCE:注解只作用在源码阶段，生成的字节码文件中不存在</li>
<li>CLASS:注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值</li>
<li>RUNTIME:注解作用在源码阶段，字节码文件阶段，运行阶段 (开发常用）</li>
</ul>
<h2 id="3-注解解析"><a href="#3-注解解析" class="headerlink" title="3.注解解析"></a>3.注解解析</h2><p>注解的解析</p>
<ul>
<li>注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容</li>
</ul>
<p>与注解解析相关的接口</p>
<ul>
<li>Annotation:注解的顶级接口，注解都是Annotation类型的对象</li>
<li>AnnotatedElement:该接口定义了与注解解析相关的解析方法</li>
</ul>
<table>
<thead>
<tr>
<th>说明</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>Annotation[] getDeclaredAnnotations()</td>
<td>获得当前对象上使用的所有注解，返回注解数组</td>
</tr>
<tr>
<td>T getDeclaredAnnotation(Class<T> annotationClass)</T></td>
<td>根据注解类型获得对应注解对象</td>
</tr>
<tr>
<td>boolean isAnnotationPresent(Class<Annotation> annotationClass</Annotation></td>
<td>判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false</td>
</tr>
</tbody></table>
<ul>
<li>所有的类成分Class, Method ,Field ，Constructor，都实现了AnnotatedElement接口他们都拥有解析注解的能力:</li>
</ul>
<p>解析注解的技巧</p>
<ul>
<li>注解在哪个成分上，我们就先拿哪个成分对象</li>
<li>比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解</li>
<li>比如注解作用在类上，则要该类的Class对象，再来拿上面的注解</li>
<li>比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解</li>
</ul>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理</p>
<ul>
<li>代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事，动态代理就是用来对业务功能（方法）进行代理的。</li>
<li>关键步骤<ol>
<li>必须有接口，实现类要实现接口（代理通常是基于接口实现的）</li>
<li>创建一个实现类的对象，该对象为业务对象，紧接着为业务对象做一个代理对象。</li>
</ol>
</li>
</ul>
<pre><code class="java">import java.lang.reflect.Proxy;
public class Demo &#123;
    public static void main(String[] args) &#123;
        My s = (My) ProxyUtil.getProxy(new Student());
        s.login(&quot;pc1608&quot;,&quot;123456&quot;);
        System.out.println(s);
    &#125;
&#125;
/*
 public static object newProxyInstance(ClassLoader Loader，CLass&lt;？&gt;[] interfaces，
 InvocationHandler h）
 参数一：类加载器，负责加载代理类到内存中使用。
 参数二：获取被代理对象实现的全部接口。代理要为全部接口的全部方法进行代理
 参数三：代理的核心处理逻辑
 */

class ProxyUtil&#123;
    public static Object getProxy(Student student) &#123;
        return  Proxy.newProxyInstance(student.getClass().getClassLoader(),
                student.getClass().getInterfaces(),
                (proxy, method, args) -&gt; &#123;
                    /*
                参数一：代理对象本身。一般不管
                参数二：正在被代理的方法
                参数三：被代理方法，应诊传入的参数
                 */
                    long startTime = System.currentTimeMillis();
                    Object result = method.invoke(student, args);
                    long endTime  = System.currentTimeMillis();
                    System.out.println(method.getName()+&quot;方法耗时&quot;+(endTime-startTime)/1000+&quot;s&quot;);
                    return result;
                &#125;);
    &#125;
&#125;
</code></pre>
<p>优点</p>
<ul>
<li>非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理。</li>
<li>可以为被代理对象的所有方法做代理。</li>
<li>可以在不改变方法源码的情况下，实现对方法功能的增强。</li>
<li>不仅简化了编程工作、提高了软件系统的可扩展性，同时也提高了开发效率</li>
</ul>
<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="1-概述-9"><a href="#1-概述-9" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>XML是可扩展标记语言（extensibleMarkupLanguage）的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</li>
</ul>
<p>XML的几个特点和使用场景</p>
<ul>
<li>一是纯文本，默认使用UTF-8编码；二是可嵌套；</li>
<li>如果把XML内容存为文件，那么它就是一个XML文件。</li>
<li>XML的使用场景：XML内容经常被当成消息进行网络传输，或者作为配置文件用于存储系统的信息。</li>
</ul>
<h2 id="2-创建"><a href="#2-创建" class="headerlink" title="2.创建"></a>2.创建</h2><ul>
<li>就是创建一个XML类型的文件，要求文件的后缓必须使用xml，如hello_world.xml</li>
</ul>
<p>语法规则</p>
<p>XML文件的后缀名为：xm<br>文档声明必须是第一行</p>
<pre><code class="xml">&lt;?xml version=1.0” encoding=&quot;UTF-8&quot;?&gt; 
version：XML默认的版本号码、该属性是必须存在的
encoding：本XML文件的编码
</code></pre>
<p>XML的标签（元素）规则</p>
<ul>
<li>标签由一对尖括号和合法标识符组成：<name></name>，必须存在一个根标签，有且只能有一</li>
<li>标签必须成对出现，有开始，有结束：<name></name></li>
<li>特殊的标签可以不成对，但是必须有结束标记，如：<br></li>
<li>标签中可以定义属性，属性和标签名空格隔开，属性值必须用引号引起来&lt;studentid=<br>“1”&gt;</li>
<li>标签需要正确的嵌套</li>
</ul>
<p>其他组成</p>
<ul>
<li><p>XML文件中可以定义注释信息：&lt;！–注释内容–&gt;</p>
</li>
<li><p>XML文件中可以存在以下特殊字符</p>
<pre><code class="text">81t；&lt;    小于
&amp;gt; &gt;`    大于
&amp;amp；&amp; 和
&amp;apos；&#39; 单引号
&amp;quot；“ 引号
</code></pre>
</li>
<li><p>XML文件中可以存在CDATA区：<!--[CDATA[内容]]--> </p>
</li>
</ul>
<h2 id="3-文档约束"><a href="#3-文档约束" class="headerlink" title="3.文档约束"></a>3.文档约束</h2><ul>
<li>文档约束：是用来限定xml文件中的标签以及属性应该怎么写。</li>
</ul>
<p>文档约束的分类</p>
<ul>
<li>DTD</li>
<li>schema</li>
</ul>
<p>schemal约束</p>
<ol>
<li>编写schema约束文档，后缀必须是.xsd，具体的形式到代码中观看。</li>
<li>在需要编写的XML文件中导入该schema约束文档</li>
<li>按照约束内容编写XML文件的标签。</li>
</ol>
<h2 id="4-XML解析"><a href="#4-XML解析" class="headerlink" title="4.XML解析"></a>4.XML解析</h2><p>概述</p>
<ul>
<li>使用程序读取XML中的数据</li>
</ul>
<p>解析方式</p>
<ol>
<li>SAX解析</li>
<li>DOM解析</li>
</ol>
<p>Dom常见的解析工具</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>JAXP</td>
<td>SUN公司提供的一套XML的解析的API</td>
</tr>
<tr>
<td>JDOM</td>
<td>JDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。</td>
</tr>
<tr>
<td>dom4j</td>
<td>是JDOM的升级品，用来读写XML文件的。具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom技术，同时它也是一个开放源代码的软件，Hibernate也用它来读写配置文件。</td>
</tr>
<tr>
<td>jsoup</td>
<td>功能强大DOM方式的XML解析开发包，尤其对HTML解析更加方便</td>
</tr>
</tbody></table>
<p>Document对象：整个xml文档<br>Element对象：标签<br>Attribute对象：属性<br>Text对象：文本内容</p>
<h3 id="Dom4j-解析出XML文件"><a href="#Dom4j-解析出XML文件" class="headerlink" title="Dom4j 解析出XML文件"></a>Dom4j 解析出XML文件</h3><p>Dom4j解析XML-得到Pocument对象</p>
<p>SAXReader类</p>
<table>
<thead>
<tr>
<th>构造器/方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public SAxReader（）</td>
<td>创建Dom4J的解析器对象</td>
</tr>
<tr>
<td>Document read(String ur）</td>
<td>加载XML文件成为Document对象</td>
</tr>
</tbody></table>
<p>Document类</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Element getRootElemento</td>
<td>获得根元素对象</td>
</tr>
</tbody></table>
<h3 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h3><p>概述</p>
<ul>
<li>XPath在解析XML文档方面提供了一独树一帜的路径思想，更加优雅，高效</li>
<li>XPath使用路径表达式来定位XML文档中的元素节点或属性节点。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javSe</tag>
      </tags>
  </entry>
  <entry>
    <title>javaWeb</title>
    <url>/java/javaWeb/</url>
    <content><![CDATA[<h1 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h1><h2 id="1、数值类型"><a href="#1、数值类型" class="headerlink" title="1、数值类型"></a>1、数值类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>有符号的范围</th>
<th>无符号的范围</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>tinyint</td>
<td>1 byte</td>
<td>(-2^7^,2^7^-1)</td>
<td>(0,2^8^-1)</td>
<td>小整数值</td>
</tr>
<tr>
<td>smallint</td>
<td>2 bytes</td>
<td>(-2^15^,2^15^-1)</td>
<td>(0,2^16^-1)</td>
<td>大整数值</td>
</tr>
<tr>
<td>mediumint</td>
<td>3 bytes</td>
<td>(-2^23^,2^23^-1)</td>
<td>(0,2^24^-1)</td>
<td>大整数值</td>
</tr>
<tr>
<td>int或integer</td>
<td>4 bytes</td>
<td>(-2^31^,2^31^-1)</td>
<td>(0,2^32^-1)</td>
<td>大整数值</td>
</tr>
<tr>
<td>bigint</td>
<td>8 bytes</td>
<td>(-2^63^,2^63^-1)</td>
<td>(0,2^64^-1)</td>
<td>极大整数值</td>
</tr>
<tr>
<td>float</td>
<td>4 bytes</td>
<td></td>
<td></td>
<td>单精度浮点数值</td>
</tr>
<tr>
<td>double</td>
<td>8 bytes</td>
<td></td>
<td></td>
<td>双精度浮点数值</td>
</tr>
<tr>
<td>dectmal</td>
<td></td>
<td>依赖M(精度)和D(标度)的值</td>
<td>依赖M(精度)和D(标度)的值</td>
<td>小数值(精确定点数)</td>
</tr>
</tbody></table>
<h2 id="1、字符串类型"><a href="#1、字符串类型" class="headerlink" title="1、字符串类型"></a>1、字符串类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>0-255 bytes</td>
<td>定长字符串</td>
</tr>
<tr>
<td>varchar</td>
<td>0-65535 bytes</td>
<td>变长字符串</td>
</tr>
<tr>
<td>tinyblob</td>
<td>0-255 bytes</td>
<td>不超过255个字符的二进制数据</td>
</tr>
<tr>
<td>tinytext</td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>blob</td>
<td>0-65535 bytes</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>text</td>
<td>0-65535 bytes</td>
<td>长文本数据</td>
</tr>
<tr>
<td>mediumblob</td>
<td>0-16777215 bytes</td>
<td>二进制形式的中等长文本数据</td>
</tr>
<tr>
<td>mediumtext</td>
<td>0-16777215 bytes</td>
<td>中等长文本数据</td>
</tr>
<tr>
<td>longblob</td>
<td>0-4294967295 bytes</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>longtext</td>
<td>0-4294967295 bytes</td>
<td>极大文本数据</td>
</tr>
</tbody></table>
<hr>
<h1 id="二、增删改数据库"><a href="#二、增删改数据库" class="headerlink" title="二、增删改数据库"></a>二、增删改数据库</h1><h2 id="1、数据库操作"><a href="#1、数据库操作" class="headerlink" title="1、数据库操作"></a>1、数据库操作</h2><table>
<thead>
<tr>
<th align="center">创建数据库</th>
<th align="left">create database 数据库名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">删除数据库</td>
<td align="left">drop database 数据库名</td>
</tr>
<tr>
<td align="center">展示数据库</td>
<td align="left">show databases 数据库名</td>
</tr>
<tr>
<td align="center">使用数据库</td>
<td align="left">use 数据库名</td>
</tr>
<tr>
<td align="center">展示使用的哪个数据库</td>
<td align="left">select database()；</td>
</tr>
</tbody></table>
<h2 id="2、表操作"><a href="#2、表操作" class="headerlink" title="2、表操作"></a>2、表操作</h2><table>
<thead>
<tr>
<th>展示所有表</th>
<th>show tables;</th>
</tr>
</thead>
<tbody><tr>
<td>创建表</td>
<td>create 表名(字段 字段类型，字段 字段类型)</td>
</tr>
<tr>
<td>查看表</td>
<td>desc 表名</td>
</tr>
<tr>
<td>查看表具体信息</td>
<td>show create table 表名</td>
</tr>
<tr>
<td>修改表</td>
<td>alter table  表名 add</td>
</tr>
<tr>
<td>删除表</td>
<td>drop table 表名</td>
</tr>
</tbody></table>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><pre><code class="mysql">create table emp
(id int comment &#39;编号&#39;,workno varchar(10) comment &#39;工号&#39;,
name varchar(10) comment &#39;姓名&#39;,
gender char(1) comment &#39;性别&#39;,
age tinyint unsigned comment &#39;年龄&#39;,
 idcard char(18) comment &#39;身份证号&#39;,
)comment &#39;员工表&#39;;
</code></pre>
<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><table>
<thead>
<tr>
<th align="left">add</th>
<th>modffy</th>
<th>change</th>
<th>drop</th>
<th>rename</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字段名 字段类型</td>
<td>字段名 新数据类型</td>
<td>旧字段名 新字段名 类型 comment 注释</td>
<td>字段名</td>
<td>rename to 新表名</td>
</tr>
<tr>
<td align="left">增加数据</td>
<td>只修改字段类型</td>
<td>修改数据名和数据类型</td>
<td>删除字段名</td>
<td>重命名新表名</td>
</tr>
</tbody></table>
<hr>
<h1 id="三、数据"><a href="#三、数据" class="headerlink" title="三、数据"></a>三、数据</h1><h2 id="1、增删改"><a href="#1、增删改" class="headerlink" title="1、增删改"></a>1、增删改</h2><table>
<thead>
<tr>
<th>给指定字段添加数据</th>
<th>insert into 表名（字段名1，字段名2…) values(值1，值2，…);</th>
</tr>
</thead>
<tbody><tr>
<td>给全部字段添加数据</td>
<td>insert into  表名 values(值1，值2，…);</td>
</tr>
<tr>
<td>批量添加数据</td>
<td>insert into  表名[（字段名1，字段名2,…) ] values(值1，值2，…),(值1，值2，…);</td>
</tr>
<tr>
<td>修改数据</td>
<td>update  表名 set 字段1=值1，字段2=值2 [where 条件]</td>
</tr>
<tr>
<td>删除数据</td>
<td>delete from 表名 [where 条件]</td>
</tr>
</tbody></table>
<hr>
<h2 id="2、查询"><a href="#2、查询" class="headerlink" title="2、查询"></a>2、查询</h2><h3 id="查询表1"><a href="#查询表1" class="headerlink" title="查询表1"></a>查询表1</h3><table>
<thead>
<tr>
<th>查询多个字段</th>
<th>select 字段1，字段2，字段3… from 表名;</th>
</tr>
</thead>
<tbody><tr>
<td>查询所有字段</td>
<td>select *from 表名;</td>
</tr>
<tr>
<td>设置别名</td>
<td>select 字段1[as 别名1],字段2[as 别名2]…from 表名;</td>
</tr>
<tr>
<td>去除重复记录</td>
<td>select distinct 字段列表 from 表名；</td>
</tr>
<tr>
<td>条件查询</td>
<td>select 字段列表 from 表名 where  条件;</td>
</tr>
</tbody></table>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><table>
<thead>
<tr>
<th>&gt;  &gt;=  &lt;   &lt;=   =   &lt;&gt;或!=</th>
<th>比较运算符</th>
</tr>
</thead>
<tbody><tr>
<td>beyween…and…</td>
<td>在某个范围内 含最大最小值</td>
</tr>
<tr>
<td>in(…)</td>
<td>在in之后的列表中的值，多选一</td>
</tr>
<tr>
<td>like 占位符</td>
<td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td>
</tr>
<tr>
<td>is null</td>
<td>是null</td>
</tr>
</tbody></table>
<p>###逻辑运算符</p>
<table>
<thead>
<tr>
<th>and 或 &amp;&amp;</th>
<th>与</th>
</tr>
</thead>
<tbody><tr>
<td>or 或  ||</td>
<td>或</td>
</tr>
<tr>
<td>not 或 ！</td>
<td>非</td>
</tr>
</tbody></table>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><table>
<thead>
<tr>
<th>count</th>
<th>统计数量</th>
</tr>
</thead>
<tbody><tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sun</td>
<td>求和</td>
</tr>
</tbody></table>
<p>语法:select 聚合函数 from 表名</p>
<h3 id="查询表2"><a href="#查询表2" class="headerlink" title="查询表2"></a>查询表2</h3><table>
<thead>
<tr>
<th>分组查询</th>
<th>select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组过滤条件]</th>
</tr>
</thead>
<tbody><tr>
<td>排序查询</td>
<td>select 字段列表 from 表名 order by 字段1 排序方式1，字段2，排序方式2；</td>
</tr>
<tr>
<td>排序方式</td>
<td>ASC:升序（默认值）     desc:降序</td>
</tr>
<tr>
<td>分页查询</td>
<td>selete 字段列表 from 表名 limit 起始索引,查询记录数；[^起始索引]</td>
</tr>
</tbody></table>
<p>[^起始索引]:<strong><em>起始索引从0开始，起始索引=（查询页码-1）</em>每页显示记录数,如果查询的是第一页数据，起始索引可以省略，直接简写limit 10</strong></p>
<h3 id="编写顺序"><a href="#编写顺序" class="headerlink" title="编写顺序"></a>编写顺序</h3><p><code>***select from where group by having order by limit***</code></p>
<hr>
<h1 id="四、权限"><a href="#四、权限" class="headerlink" title="四、权限"></a>四、权限</h1><h2 id="1、用户操作"><a href="#1、用户操作" class="headerlink" title="1、用户操作"></a>1、用户操作</h2><p>需要移到mysql数据库</p>
<table>
<thead>
<tr>
<th>查询用户</th>
<th>select* from user;</th>
</tr>
</thead>
<tbody><tr>
<td>创建用户</td>
<td>create user ‘用户名‘@’主机名’ identified by ‘密码’;</td>
</tr>
<tr>
<td>修改用户密码</td>
<td>alter user ‘用户名‘@’主机名’ identified mysql_native_password by ‘新密码’;</td>
</tr>
<tr>
<td>删除用户</td>
<td>drop user ‘用户名‘@’主机名’;</td>
</tr>
</tbody></table>
<h2 id="2、权限操作"><a href="#2、权限操作" class="headerlink" title="2、权限操作"></a>2、权限操作</h2><table>
<thead>
<tr>
<th>查询权限</th>
<th>show grants for ‘用户名‘@’密码’;</th>
</tr>
</thead>
<tbody><tr>
<td>授予权限</td>
<td>grants 权限列表 on 数据库名.表名 to ‘用户名‘@’主机名；</td>
</tr>
<tr>
<td>撤销权限</td>
<td>remove 权限列表 on 数据库名.表名 form ‘用户名‘@’主机名’;</td>
</tr>
</tbody></table>
<hr>
<h1 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h1><h2 id="1、数值函数"><a href="#1、数值函数" class="headerlink" title="1、数值函数"></a>1、数值函数</h2><table>
<thead>
<tr>
<th>ceil(x)</th>
<th>向上取整</th>
</tr>
</thead>
<tbody><tr>
<td>floor(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>mod(x,y)</td>
<td>返回x/y的模 余数</td>
</tr>
<tr>
<td>rand()</td>
<td>返回0~1的随机数</td>
</tr>
<tr>
<td>round(x,y)</td>
<td>求参数四舍五入，保留y位小数</td>
</tr>
</tbody></table>
<h2 id="2、字符串函数"><a href="#2、字符串函数" class="headerlink" title="2、字符串函数"></a>2、字符串函数</h2><table>
<thead>
<tr>
<th>concat(s1,s2,s3…sn)</th>
<th>字符串拼接，将s1,s2…拼成一个字符串</th>
</tr>
</thead>
<tbody><tr>
<td>lower(str)</td>
<td>全部转小写</td>
</tr>
<tr>
<td>upper(str)</td>
<td>全部转大写</td>
</tr>
<tr>
<td>lpad(str,n,pad)</td>
<td>用字符串pad对str左边进行填充，直到到达n个字符串长度</td>
</tr>
<tr>
<td>rpad(str,n,pad)</td>
<td>用字符串pad对str右边进行填充，直到到达n个字符串长度</td>
</tr>
<tr>
<td>trim(str)</td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td>substring(str,start,len)</td>
<td>返回字符串str从start开始len个长度的字符串</td>
</tr>
</tbody></table>
<h2 id="3、日期函数"><a href="#3、日期函数" class="headerlink" title="3、日期函数"></a>3、日期函数</h2><table>
<thead>
<tr>
<th>curdate()</th>
<th>返回当前日期</th>
</tr>
</thead>
<tbody><tr>
<td>certime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>year(date)</td>
<td>获取指定date的年份</td>
</tr>
<tr>
<td>month(date)</td>
<td>获取指定date的月份</td>
</tr>
<tr>
<td>day(date)</td>
<td>获取指定date的日期</td>
</tr>
<tr>
<td>date_add(date,interval expr type)</td>
<td>返回一个(日期/时间值)加上一个时间间隔expr之后的时间值[^注释date_add]</td>
</tr>
<tr>
<td>datediff(date1,date2)</td>
<td>返回起始时间date1和结束时间date2之间的天数[^datediff]</td>
</tr>
</tbody></table>
<p>[^注释date_add]: <em><strong>select date_add(now(),interval 70 day )  指当前时间往后推70天</strong></em><br>[^datediff]: <em><strong>差值是 date1 - date2</strong></em></p>
<h2 id="4、流程控制"><a href="#4、流程控制" class="headerlink" title="4、流程控制"></a>4、流程控制</h2><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">if(value,t,f)</td>
<td>如果value为true,则返回f,否则返回t</td>
</tr>
<tr>
<td align="left">ifnull(value1,value2)</td>
<td>如果value1不为空,返回value1,否则返回value2</td>
</tr>
<tr>
<td align="left">case when [val1] then [res1]…else [default] end</td>
<td>如果val1为true，返回res1,…否则返回default默认值</td>
</tr>
<tr>
<td align="left">case [expr] when [val1] then [res1] …else [default] end</td>
<td>如果expr的值等于val1,返回res1,…否则返回default默认值</td>
</tr>
</tbody></table>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><ul>
<li>统计各个班各个学员的成绩，展示规则如下：</li>
<li><ul>
<li><code>&gt;=85</code>展示优秀</li>
<li><code>&gt;=65</code>展示及格</li>
<li>否则展示不及格</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>math</th>
<th>english</th>
<th>chinese</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TOM</td>
<td>67</td>
<td>88</td>
<td>95</td>
</tr>
<tr>
<td>2</td>
<td>ROSE</td>
<td>23</td>
<td>66</td>
<td>90</td>
</tr>
<tr>
<td>3</td>
<td>JACK</td>
<td>56</td>
<td>98</td>
<td>76</td>
</tr>
</tbody></table>
<pre><code class="MYSQL">SELECT id,name,
(case when math &lt; 65 then &#39;不及格&#39; when math between 65 and 84 then &#39;及格&#39; else &#39;优秀&#39; end) as &#39;数学&#39;,
(case when english &lt; 65 then &#39;不及格&#39; when english between 65 and 84 then &#39;及格&#39; else &#39;优秀&#39; end) as &#39;英语&#39;,
(case when chinese &lt; 65 then &#39;不及格&#39; when chinese between 65 and 84 then &#39;及格&#39; else &#39;优秀&#39; end) as &#39;语文&#39;
from score
</code></pre>
<hr>
<h1 id="六、约束"><a href="#六、约束" class="headerlink" title="六、约束"></a>六、约束</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><ol>
<li><p>概念：约束是作用在表中字段上的规则，用于限制存储在表中的数据</p>
</li>
<li><p>目的：保证数据库中数据的正确、有效和完整性</p>
</li>
<li><p>分类：</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>非空约束</td>
<td>限制该字段的数据不能为null</td>
<td>not null</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一的、不重复的</td>
<td>unique</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>primary key</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段的值，则为默认值</td>
<td>default</td>
</tr>
<tr>
<td>检查约束</td>
<td>保证字段值满足某一个条件</td>
<td>check</td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张数据之间建立连接，保证数据的一致性和完整性</td>
<td>foreign key</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="2、约束演示"><a href="#2、约束演示" class="headerlink" title="2、约束演示"></a>2、约束演示</h2><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p>根据需求，完成表结构的创建</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段含义</th>
<th>字段类型</th>
<th>约束条件</th>
<th>约束关键字</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>ID唯一标志</td>
<td>int</td>
<td>主键，并且自动增长</td>
<td>primary key,auto_increment</td>
</tr>
<tr>
<td>name</td>
<td>姓名</td>
<td>varchar(10)</td>
<td>不为空且唯一</td>
<td>not null,unique</td>
</tr>
<tr>
<td>age</td>
<td>年龄</td>
<td>int</td>
<td>大于0，并且小于等于120</td>
<td>check</td>
</tr>
<tr>
<td>status</td>
<td>状态</td>
<td>char(1)</td>
<td>如果没有该值，默认为1</td>
<td>default</td>
</tr>
<tr>
<td>gender</td>
<td>性别</td>
<td>char(1)</td>
<td>无</td>
<td></td>
</tr>
</tbody></table>
<p><em><strong>创建表</strong></em></p>
<pre><code class="mysql">create table user(
id int primary key auto_increment comment &#39;主键&#39;,
name varchar(10) not null unique comment &#39;姓名&#39;,
age int unsigned check ( age between 0 and 120) comment &#39;年龄&#39;,
status char(1) default &#39;1&#39; comment &#39;状态&#39;,
gender char(1) comment &#39;性别&#39;
)comment &#39;用户表&#39;
</code></pre>
<hr>
<p><em><strong>插入数据</strong></em></p>
<pre><code class="mysql">insert into user(name,age,status,gender) values
(&#39;TOM1&#39;,25,1,&#39;男&#39;),
(&#39;TOM2&#39;,26,0,&#39;男&#39;)
 insert into user(name,age,gender) values(&#39;TOM3&#39;,19,&#39;男&#39;)
</code></pre>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>status</th>
<th>gender</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TOM1</td>
<td>25</td>
<td>1</td>
<td>男</td>
</tr>
<tr>
<td>2</td>
<td>TOM2</td>
<td>26</td>
<td>0</td>
<td>男</td>
</tr>
<tr>
<td>3</td>
<td>TOM3</td>
<td>19</td>
<td>1</td>
<td>男</td>
</tr>
</tbody></table>
<h2 id="3、外键约束"><a href="#3、外键约束" class="headerlink" title="3、外键约束"></a>3、外键约束</h2><ul>
<li>概念</li>
<li><ul>
<li>用来让两张表之间建立数据连接，从而保证数据的一致性和完整性</li>
</ul>
</li>
<li>语法</li>
<li><ul>
<li>添加外键</li>
</ul>
</li>
</ul>
<pre><code class="mysql">create table 表名(
        字段名 数据类型,
        ...
        [constraint][外键名称] foreign key(外键字段名) references 主表(主表列名)
)
</code></pre>
<pre><code class="mysql">alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名) 

alter table emp_ add constraint fk_emp_dept_id foreign key (dept_id) references dept(id)
</code></pre>
<ul>
<li><ul>
<li>删除外键</li>
</ul>
</li>
</ul>
<pre><code class="mysql">alter table 表名 drop foreign key 外键名称;

alter table emp_ drop foreign key fk_emp_dept_id;
</code></pre>
<h3 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除/更新行为"></a>删除/更新行为</h3><table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no action</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新(与restrict一致)</td>
</tr>
<tr>
<td>restrict</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新(与no action一致)</td>
</tr>
<tr>
<td>cascade</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录</td>
</tr>
<tr>
<td>set null</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键的值为null(这就要求该外键允许取null)</td>
</tr>
<tr>
<td>set default</td>
<td>父表有变更时，子健将外键列设置成一个默认的值(lnnodb不支持)</td>
</tr>
</tbody></table>
<p><em><strong>set null/set null</strong></em></p>
<pre><code class="mysql">alter table 表名 add constraint 外键名称 foreign key(外键字段) references 主表名(主表字段名)
on update (cascade) on delete (cascade);
</code></pre>
<h1 id="七、多表查询"><a href="#七、多表查询" class="headerlink" title="七、多表查询"></a>七、多表查询</h1><h2 id="1、多表关系"><a href="#1、多表关系" class="headerlink" title="1、多表关系"></a>1、多表关系</h2><pre><code class="text">概述

项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构
之间也存在着某种练习，基本上分为三种

&gt;--一对多(多对一)
&gt;--多对多
&gt;--一对一
</code></pre>
<h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><pre><code class="text">部门与员工的关系
关系：一个部门对应多个员工，一个员工对应一个部门
实现：再多的一方设立外键指向单一的一方
</code></pre>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><pre><code class="text">案例：学生与课程之间的关系
关系：一个学生可以选择多门课程，一门课程也可以供多个学生选择
实现：建立第三张中间表，中间至少包含两个外键，分别关联两方主键
</code></pre>
<h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><pre><code class="text">案例：用户与用户详情的关系
关系：一对一关系，多用于单表拆分，将一张基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率
实现：任意一方加入外键，关联另一方的主键，并设置外键是唯一的(unique)
</code></pre>
<h3 id="2、多表查询概述"><a href="#2、多表查询概述" class="headerlink" title="2、多表查询概述"></a>2、多表查询概述</h3><pre><code>概述：指从多张表中查询数据
笛卡尔积：笛卡尔积是指在数学中，两个集合A集合和B集合的所有组合情况。(在多表查询时，需要消除无效的笛卡尔积)
</code></pre>
<pre><code class="mysql">select * from emp , dept where emp.dept_id = dept.id;(让他们之间的联系的两个键相等)
</code></pre>
<h4 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h4><ul>
<li>多表查询分类<ul>
<li>连接查询<ul>
<li>内连接：相当于查询A、B交集部分</li>
<li>外连接：<ul>
<li>左外连接：查询左表所有数据，以及两张表交集部分数据</li>
<li>右外连接：查询右表所有数据，以及两张表交集部分数据</li>
</ul>
</li>
<li>自连接：当前表与自身的连接查询，自连接必须使用别名</li>
</ul>
</li>
<li>子查询</li>
</ul>
</li>
</ul>
<h1 id="八、JDBC"><a href="#八、JDBC" class="headerlink" title="八、JDBC"></a>八、JDBC</h1><p>==JDBC就是使用Java语言操作关系型数据库的一套API==</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>概述</p>
<ul>
<li>JDBC就是使用Java语言操作关系型数据库的一套APl</li>
<li>全称：（JavaDataBaseConnectivity）Java数据库连接</li>
</ul>
<p>JDBC本质：</p>
<ul>
<li>官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口</li>
<li>各个数据库厂商去实现这套接口，提供数据库驱动ar包</li>
<li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包<br>中的实现类</li>
</ul>
<p>JDBC好处：</p>
<ul>
<li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发</li>
<li>可随时替换底层数据库，访问数据库的Java代码基本不变</li>
</ul>
<h2 id="2-入门"><a href="#2-入门" class="headerlink" title="2.入门"></a>2.入门</h2><p>步骤</p>
<ol>
<li>创建工程，导入jar包</li>
<li>注册驱动</li>
<li>获取链接</li>
<li>定义SQL语句</li>
<li>获取SQL对象</li>
<li>执行SQL</li>
<li>处理返回结果</li>
<li>释放资源</li>
</ol>
<pre><code class="java">import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;
public class Demo &#123;
    public static void main(String[] args) throws Exception &#123;
        //1.注册驱动
        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);//现在可以不写
        //2.获取连接
        String url = &quot;jdbc:mysql://127.0.0.1:3306/try&quot;;
        String user= &quot;root&quot;;
        String psd = &quot;123456&quot;;
        Connection conn = DriverManager.getConnection(url,user,psd);
        //3.定义sql语句
        String sql = &quot;update emp set age = 20 where id = 000001&quot;;
        //4.获取执行sql的对象
        Statement sta = conn.createStatement();
        //5.执行sql
        int row = sta.executeUpdate(sql);
        System.out.println(row);
        //6.释放资源
        sta.close();
        conn.close();
    &#125;
&#125;
</code></pre>
<h2 id="3-API"><a href="#3-API" class="headerlink" title="3.API"></a>3.API</h2><h3 id="3-1-DriverManager"><a href="#3-1-DriverManager" class="headerlink" title="3.1 DriverManager"></a>3.1 DriverManager</h3><p>作用</p>
<ol>
<li><p>注册驱动</p>
<p><code>Class.forName（com.mysqljdbc.Driver”</code></p>
</li>
<li><p>获取数据库连接</p>
<pre><code class="java">static Connection  getconnection(string uxl，string user,stringpassword）；

url：连接路径；
语法：jdbc:mysql://p地址（域名）：端口号/数据库名称？参数键值对1&amp;参数键值对2.
示例：jdbc:mysql//127.0.0.1：3306/db1
细节：
    如果连接的是本机mysql服务器，并目mysq服务默认端口是3306，则ur可以简写为：jdbcmysql//数据库名称？参数键值对
    配置useSsL=false参数，禁用安全连接方式，解决警告提示
                                 
user：用户名
password：密码
</code></pre>
</li>
</ol>
<h3 id="3-2-Connection"><a href="#3-2-Connection" class="headerlink" title="3.2 Connection"></a>3.2 Connection</h3><p>作用</p>
<ul>
<li><p>获取执行SOL的对象</p>
<ol>
<li><p>普通执行SQL对象</p>
<p><code>StatementO createStatement()</code></p>
</li>
<li><p>预编译SQL的执行SQL对象：防止SQL注入</p>
<p><code>PreparedStatement prepareStatement (sql）</code></p>
</li>
<li><p>执行存储过程的对缘</p>
<p><code>CallableStatement prepareCall(sql）</code></p>
</li>
</ol>
</li>
<li><p>管理事务</p>
<ol>
<li><p>MySQL事务管理</p>
<pre><code class="java">开启事务：BEGIN:/STARTTRANSACTION
提交事务：COMMIT
回滚事务：ROLLBACK
    
MYSQL默认自动提交事务
</code></pre>
</li>
<li><p>JDBC事务管理：Connection接口中定义了3个对应的方法</p>
<pre><code class="java">开启事务：setAutoCommitbooleanautoCommit：true为自动提交事务；false为手动提交事务，即为开启事务
提交事务：commit（）
回滚事务：rollback（）
</code></pre>
</li>
</ol>
<h3 id="3-3-Statement"><a href="#3-3-Statement" class="headerlink" title="3.3 Statement"></a>3.3 Statement</h3><p>作用</p>
<ul>
<li>执行SQL语句</li>
</ul>
<pre><code class="java’">int executeUpdate（sql）：执行DML、DDL语句
返回值：（1）DML语句影响的行数（2）DDL渴句执行后，执行成功也可能返回0

ResultSet executeQueny（sql）：执行DQL语句
返回值：ResultSet结果集对象
</code></pre>
<h3 id="3-4-ResultSet"><a href="#3-4-ResultSet" class="headerlink" title="3.4 ResultSet"></a>3.4 ResultSet</h3><p>作用</p>
<ol>
<li><p>封装了DQL查询语句的结果</p>
<p><code>ResultSetstmt.executeQueny（sql）：执行DQL语句，返回ResultSet对象</code></p>
</li>
<li><p>获取查询结果</p>
<pre><code class="java">boolean next()：（1）将光标从当前位置向前移动一行（2）判断当前行是否为有效行
返回值：
    true：有效行，当前行有数据
    false：无效行，当前行没有数据
</code></pre>
<pre><code class="java">XXX getXxx（参数）：获取数据
Xxx：数据类型；如：intgetint参数）：StinggetString（参数）
参数：
    int：列的编号，从1开始
    String：列的名称
</code></pre>
</li>
</ol>
<p>使用步骤</p>
<ol>
<li><p>游标向下移动一行，并判断该行否有数据：next()</p>
</li>
<li><p>获取数据：getXxx（参数）</p>
<pre><code class="java">循环判断游标是否是最后一行未尾
wnile(rs.next()&#123;
//获取数据
rs.getXxx（参数）；
&#125;
</code></pre>
</li>
</ol>
</li>
</ul>
<pre><code class="java">import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class Demo &#123;
    public static void main(String[] args) throws Exception &#123;

        String url = &quot;jdbc:mysql://127.0.0.1:3306/try&quot;;
        String user= &quot;root&quot;;
        String psd = &quot;123456&quot;;
        String sql = &quot;select id,name,age from emp&quot;;
        try(Connection conn = DriverManager.getConnection(url,user,psd);
            Statement sta = conn.createStatement();) &#123;
            ResultSet rs = sta.executeQuery(sql);
            List&lt;Account&gt; list = new ArrayList&lt;&gt;();
            while (rs.next())&#123;
                int id = rs.getInt(&quot;id&quot;);
                String name = rs.getString(&quot;name&quot;);
                int age = rs.getInt(&quot;age&quot;);
                list.add(new Account(id,name,age));
            &#125;
            System.out.println(list);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="3-3Preparedstatement"><a href="#3-3Preparedstatement" class="headerlink" title="3.3Preparedstatement"></a>3.3Preparedstatement</h3><p>作用</p>
<ul>
<li>预编译SQL语句并执行：预防SQL注入问题</li>
</ul>
<p>SQL注入</p>
<ul>
<li>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法</li>
</ul>
<h3 id="3-4-PreparedStatement"><a href="#3-4-PreparedStatement" class="headerlink" title="3.4 PreparedStatement"></a>3.4 PreparedStatement</h3><p>作用</p>
<ul>
<li>预编译SQL并执行SQL语句</li>
</ul>
<p>步骤</p>
<ol>
<li><p>获取PreparedStatement对象</p>
<pre><code class="java">//SQL语句中的参数值，使用？占位符替代
String sql = “select * from user where username = ? and password = ?；
//通过Connection对象获取，并传入对应的sql语句
PreparedStatement pstmt = conn.prepareStatement
</code></pre>
</li>
<li><p>设置参数值</p>
<pre><code class="java">PreparedStatement对象：setxxx（参数1，参数2）：给？赋值
&gt;Xxx：数据类型；如setlnt（参数1，参数2）
参数：
口 参数1：？的位置编号，从1开始
口 参数2：？的值
</code></pre>
</li>
<li><p>执行SQL</p>
<p><code>executeupdate0:/executeQuery0；：不需要再传递sq</code></p>
</li>
</ol>
<p>好处</p>
<ol>
<li>预编译SQL，性能更高</li>
<li>防止SQL注入：将敏感字符进行转义</li>
</ol>
<p>步骤</p>
<ol>
<li><p>Preparedstatement预编译功能开启：useServerPrepStmts = true</p>
</li>
<li><p>配置MySQL执行日志（重启mysql服务后生效）</p>
<pre><code class="java">log-output=FILE
general-log=1
general_log_file=&quot;D:\mysql.log&quot;
slow-query-log-1
slow_query_log_file=&quot;D\mysql_slow.log&quot;
long_query_time=2
</code></pre>
</li>
</ol>
<p>原理</p>
<ol>
<li>在获取Preparedstatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）</li>
<li>执行时就不用再进行这些步骤了，速度更快</li>
<li>如果sqi模板一样，则只需要进行一次检查、编译</li>
</ol>
<h2 id="4-数据连接池"><a href="#4-数据连接池" class="headerlink" title="4.数据连接池"></a>4.数据连接池</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><ul>
<li>数据库连接池是个容器，负责分配、管理数据库连接（Connection）</li>
<li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；</li>
<li>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</li>
</ul>
<p>好处</p>
<ul>
<li>资源重用</li>
<li>提升系统响应速度</li>
<li>避免数据库连接遗漏</li>
</ul>
<p>实现</p>
<ul>
<li><p>标准接口：DataSource</p>
<ul>
<li><p>官方（SUN）提供的数据库连接池标准接口，由第三方组织实现此接口。</p>
</li>
<li><p>功能：获取连接</p>
<p>`标准接口：DataSource</p>
<ul>
<li><p>官方（SUN）提供的数据库连接池标准接口，由第三方组织实现此接口。</p>
</li>
<li><p>功能：获取连接</p>
<p><code>Connection getConnection</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>常见的数据库连接池</p>
<ul>
<li>DBCP</li>
<li>C3P0</li>
<li>DRUID</li>
</ul>
<p>DRUID(德鲁伊)</p>
<ul>
<li>Druid连接池是阿里巴巴开源的数据库连接池项目</li>
<li>功能强大，性能优秀，是Java语言最好的数据库连接池之一</li>
</ul>
<h3 id="4-2-案例"><a href="#4-2-案例" class="headerlink" title="4.2 案例"></a>4.2 案例</h3><pre><code class="java">import com.alibaba.druid.pool.DruidDataSourceFactory;
import com.it.Demo;
import lombok.SneakyThrows;
import org.junit.Test;

import javax.sql.DataSource;
import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

public class BrandTest &#123;
    /*
    查询所有
    1.SQL:select * from tb_brand
    2.参数：不需要
    3.结果：List&lt;Brand&gt;
     */
    @SneakyThrows
    @Test
    public void testSelectAll()&#123;
        Properties pro = new Properties();
        pro.load(new FileInputStream(&quot;src\\com\\it\\druid.properties&quot;));
        DataSource dataSource = DruidDataSourceFactory.createDataSource(pro);
        try (Connection conn = dataSource.getConnection())&#123;
            String sql = &quot;select * from tb_brand&quot;;
            try (PreparedStatement pre = conn.prepareStatement(sql);
                 ResultSet res = pre.executeQuery()) &#123;
                List&lt;Demo&gt; demo = new ArrayList&lt;&gt;();
                Demo d = new Demo();
                while (res.next()) &#123;
                    int id = res.getInt(&quot;id&quot;);
                    String brandName = res.getString(&quot;brand_name&quot;);
                    String companyName = res.getString(&quot;company_name&quot;);
                    int ordered = res.getInt(&quot;ordered&quot;);
                    String description = res.getString(&quot;description&quot;);
                    int status = res.getInt(&quot;STATUS&quot;);
                    d.setId(id);
                    d.setBrandName(brandName);
                    d.setCompanyName(companyName);
                    d.setOrdered(ordered);
                    d.setDescription(description);
                    d.setStatus(status);
                    demo.add(d);
                &#125;
                System.out.println(demo);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="MAVEN"><a href="#MAVEN" class="headerlink" title="MAVEN"></a>MAVEN</h1><p>Maven是专门用于管理和构建」ava项目的工具，它的主要功能有：</p>
<ul>
<li>提供了一套标准化目结构</li>
<li>提供了一套标准化的构建流程（编译，测试，打包，发布…）</li>
<li>提供了一套依赖管理机制</li>
</ul>
<p>依赖管理</p>
<ul>
<li>依赖管理其实就是管理亻尔项目所依赖的第三方资源r包、插件….）</li>
</ul>
<h2 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h2><p>ApacheMaven是一个项目管理和构建T具，它基于项目对象模型<br>(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档<br>官网：<a href="http://maven.apache.org/">Maven官网</a></p>
<p>仓库分类：</p>
<ul>
<li><p>本地仓库．自己计算机上的一个目录</p>
</li>
<li><p>中央仓库．由团队维护的全球唯一的仓库地址：<a href="https://rep01.maven.org/maven2/">仓库地址</a></p>
<p>(远程仓库服）：一般由公司团队搭建的私有仓库</p>
</li>
</ul>
<p>当项目中使用坐标引入对应依引包后，首先会查找本地仓库中是否有对应的jar包：</p>
<ul>
<li>如果有，则项目直接引用；</li>
<li>如果没有，则去中央仓库中下载对应的jar包到本地仓库。</li>
<li>还可以搭建远程仓库，将来ja泡的查找顺序<br>本地仓库-&gt;远程仓库-&gt;中央仓库</li>
</ul>
<h2 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h2><p>Maven常用命令</p>
<ol>
<li>compile·编译</li>
<li>clean:清理</li>
<li>test：测试</li>
<li>package:打包</li>
<li>install:安装</li>
</ol>
<p>Maven生命周期</p>
<ul>
<li>Maven构建项目生命周期描述的是一次构建过程经历经历了多少个事件</li>
<li>Maven对项目构建的生命周期划分为3套<ol>
<li>clean:清理工作</li>
<li>default:核心工作，例如编译，测试，打包，安装等</li>
<li>site:产生报告，发布站点等</li>
<li>同一生命周期内，执行后边的命令，前边的所有命令会自动执行</li>
</ol>
</li>
</ul>
<h2 id="3-Maven坐标"><a href="#3-Maven坐标" class="headerlink" title="3.Maven坐标"></a>3.Maven坐标</h2><p>什么是坐标？</p>
<ul>
<li>Maven中的坐标是资源的唯一标识</li>
<li>使用坐标来定义项目或引入项目中需要的依赖</li>
</ul>
<p>Maven坐标主要组成</p>
<ul>
<li>groupld:定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima)</li>
<li>artifactld，定义当前Maven项目名称（通常是模块名称，例如order-service、goods-service)</li>
<li>version:定义当前项目版本量</li>
</ul>
<p>创建Maven项目</p>
<ol>
<li>创建模块选择Maven,点击Next</li>
<li>填写模块名称，坐标信息，点击finish,创建完成</li>
<li>编写HelloWorId,并运行</li>
</ol>
<p>导入Maven项目</p>
<ol>
<li>选择右侧Maven面板，点击+号</li>
<li>选中对应项目的四m，×m丨文件，双击即可</li>
<li>如果没有Maven面板，选择    ViewAppearanceToolWindowBars</li>
</ol>
<h2 id="4-Maven依赖"><a href="#4-Maven依赖" class="headerlink" title="4.Maven依赖"></a>4.Maven依赖</h2><p>以来范围</p>
<ul>
<li>通过设置坐标的依赖范围(scope),可以设置对应jar包的作用范围：编译境、测试环境、运行环境</li>
</ul>
<table>
<thead>
<tr>
<th>依赖范围</th>
<th align="center">编译classpath</th>
<th align="center">测试classpath</th>
<th align="center">运行classpath</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td>logback</td>
</tr>
<tr>
<td>test</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">-</td>
<td>Junit</td>
</tr>
<tr>
<td>provided</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">-</td>
<td>servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td>jdbc驱动</td>
</tr>
<tr>
<td>system</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">-</td>
<td>存储在本地的jar包</td>
</tr>
</tbody></table>
<p>==import: 引入DependencyManagement==</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>什么EMyBatis?</p>
<ul>
<li>MyBatis是一款优秀的持久层框架，用于简化JDBC开发</li>
<li>MyBatis本是Apache的一个开源项目iBatis,2010年这个项目由apachesoftware</li>
<li>foundation迁移到了goog|ecode,并且改名为MyBatis。2013年11月迁移到Github</li>
<li><a href="https://mybatis.org/mybatis-3/zh/index.html">官网</a></li>
</ul>
<p>持久层</p>
<ul>
<li>负责将数据到保存到数据库的那一层代码</li>
<li>JavaEE三层架构：表现层、业务层、持久层</li>
</ul>
<p>框架</p>
<ul>
<li>框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型</li>
<li>在框架的基础之上构是簌件编写更加高效、规范、通用、可扩展</li>
</ul>
<p>JDBC缺点</p>
<ol>
<li>硬编码</li>
<li>操作繁琐</li>
</ol>
<h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h2><pre><code class="java">import com.it.pojo.User;
import lombok.SneakyThrows;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

/**
 * @author Administrator
 */
public class MyBatisDemo &#123;
    @SneakyThrows
    public static void main(String[] args) &#123;
        //1.加载mybatis的核心配置文件，获取sqlSessionFactory
        String resource = &quot;mybatis-config.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new                                 SqlSessionFactoryBuilder().build(inputStream);

        //2.获取sqlSession，执行sql
        SqlSession session = sqlSessionFactory.openSession();
        //3.执行sql
        List&lt;User&gt; user = session.selectList(&quot;test.selectAll&quot;);
        System.out.println(user);
    &#125;
&#125;
</code></pre>
<h2 id="2-Mapper代理"><a href="#2-Mapper代理" class="headerlink" title="2.Mapper代理"></a>2.Mapper代理</h2><p>目的</p>
<ul>
<li>解决原生方式中的硬编码</li>
<li>简化后期执行SQL</li>
</ul>
<p>步骤</p>
<ol>
<li>定义SQL映射文件同名的Mapper借口，并将Mapper接口和SQL映射文件放置在同一目录下</li>
<li>设置SQL映射文件的namespace属性为Mapper接口权限定名</li>
<li>在Mapper接口中定义方法，方法名就是SQL映射文件中sq晤句的id，并保持参数类型和返回值类型一致</li>
<li>编码<ul>
<li>通过SqlSession的getMapper方氵去获取Mapper接口的代理对象</li>
<li>调用对应方法完成sq]的执行</li>
</ul>
</li>
</ol>
<p>==细节：如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载==</p>
<pre><code class="java">//3.执行UserMapper接口的代理对象
UserMapper mapper = session.getMapper(UserMapper.class);
List&lt;User&gt; users = mapper.selectAll();
System.out.println(users);
</code></pre>
<h2 id="3核心配置文件"><a href="#3核心配置文件" class="headerlink" title="3核心配置文件"></a>3核心配置文件</h2><table>
<thead>
<tr>
<th>代码</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>enenvironments</td>
<td>配置数据库连接环境信息。可以配置多个environment,通过default属性切换不同的environment</td>
</tr>
<tr>
<td>typeAliases</td>
<td>设置别名</td>
</tr>
<tr>
<td>mappers</td>
<td>加载SQL映射文件</td>
</tr>
</tbody></table>
<p>结构</p>
<ul>
<li><p>configuration（配首）</p>
<ul>
<li>properties（属性）</li>
<li>settings（设置〕</li>
<li>typeAliases（类型别名）</li>
<li>typeHandlers（类型处理器〕</li>
<li>objectFactory〔对象工厂）</li>
<li>plugins插件</li>
<li>environments（环境变量）<ul>
<li>environment（环境变量）</li>
<li>transactionManager（事务管理器）</li>
<li>dataSource〔数啹源〕</li>
</ul>
</li>
<li>databaseldProvider（数据库厂商标识）</li>
<li>mappers（映射器）</li>
</ul>
</li>
<li><p>类型别名</p>
<pre><code class="xml">&lt;typeAIiases&gt;
    &lt;packagename=&quot;com/itheima.pojo&quot;/&gt;
&lt;/typeAIiases&gt;
</code></pre>
<p>==配置各个标签时，需要遵守前后顺序==</p>
</li>
</ul>
<h2 id="4-配置文件完成增删改查"><a href="#4-配置文件完成增删改查" class="headerlink" title="4.配置文件完成增删改查"></a>4.配置文件完成增删改查</h2><h3 id="4-1查询"><a href="#4-1查询" class="headerlink" title="4.1查询"></a>4.1查询</h3><p>数据库表的字段名称和实体类的属性名称不一样，则不能自动封装数据</p>
<ul>
<li>起别名：对不一样的列名起别名，让别名和实体类的属性名一样<ul>
<li>缺点：每次查询都要定义一次别名</li>
</ul>
</li>
<li>sql片段<ul>
<li>缺点：不灵活</li>
</ul>
</li>
<li>resu1-tMap：<ol>
<li>定义<resultMap>标签</resultMap></li>
<li>在<select>标签中，使用resultMap属性替换resultType属性</select></li>
</ol>
</li>
</ul>
<pre><code class="xml">&lt;mapper namespace=&quot;com.it.mapper.BrandMapper&quot;&gt;
    &lt;resultMap id=&quot;brandResultMap&quot; type=&quot;Brand&quot;&gt;
        &lt;!--        id:唯一标识
                    type：映射的类型，支持别名
        --&gt;
        &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt;
        &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot;/&gt;
        &lt;!--id：完成主键字段的映射 result：完成一般字段的映射
            colum:列名 property：实体类的属性名
            --&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt;
            select * from tb_brand;
    &lt;/select&gt;
    &lt;/select&gt;
        &lt;!--
        参数占位符
           1. #&#123;&#125;：会将其替换为？为了防止sql注入
           2. $&#123;&#125;:拼sql，会存在sql注入问题
           3.使用时机：
                参数传递时用#&#123;&#125;
                表名或者列名不固定的情况下用$&#123;&#125;
        参数类型：parameterType:可以省略
        特殊字符处理：
            1.转义字符
            2.CDATA区：
        --&gt;
    &lt;select id=&quot;selectById&quot; resultMap=&quot;brandResultMap&quot;&gt;
            select * from tb_brand where id= #&#123;id&#125;;
    &lt;/select&gt;
    &lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;
        select * from tb_brand where status = #&#123;status&#125; 
        and company_name     like #&#123;companyName&#125;
        and brand_name like #&#123;brandName&#125;;
    &lt;/select&gt;
    &lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;
        /*
        动态条件查询
        *if：条件判断
            *test：逻辑表达式
        *问题：第一个条件为空会报错
            *恒等式，在where后面加上恒等式
            **&lt;![CDATA[
            &lt;where
            ]]&gt;替换where关键字

        */

        select * from tb_brand
        &lt;where&gt;
              &lt;if test=&quot;status != null&quot;&gt;status = #&#123;status&#125;&lt;/if&gt;
              &lt;if test=&quot;companyName !=null and companyName != &#39;&#39;&quot;&gt;and         company_name like #&#123;companyName&#125;&lt;/if&gt;
              &lt;if test=&quot;brandName !=null and brandName != &#39;&#39;&quot;&gt;and             brand_name like #&#123;brandName&#125;&lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
    &lt;select id=&quot;selectConditionSingle&quot; resultMap=&quot;brandResultMap&quot;&gt;
        select * from tb_brand
        where
        &lt;choose&gt;
            &lt;when test=&quot;status != null&quot;&gt;status = #&#123;status&#125;&lt;/when&gt;
            &lt;when test=&quot;companyName!=null&quot;&gt;company_name like #&#123;companyName&#125;&lt;/when&gt;
            &lt;when test=&quot;brandName!=null&quot;&gt;brand_name like #&#123;brandName&#125;&lt;/when&gt;
            &lt;otherwise&gt;1=1&lt;/otherwise&gt;
        &lt;/choose&gt;
    &lt;/select&gt;
    &lt;insert id=&quot;add&quot;&gt;
        insert into tb_brand (brand_name, company_name, ordered, description, status)
        values (#&#123;brandName&#125;,#&#123;companyName&#125;,#&#123;ordered&#125;,#&#123;description&#125;,#&#123;status&#125;);
    &lt;/insert&gt;
    &lt;update id=&quot;update&quot;&gt;
        update tb_brand
        &lt;set&gt;
            &lt;if test=&quot;brandName != null and brandName != &#39;&#39;&quot;&gt;brand_name = #&#123;brandName&#125;,&lt;/if&gt;
            &lt;if test=&quot;companyName != null and companyName != &#39;&#39;&quot;&gt;company_name = #&#123;companyName&#125;,&lt;/if&gt;
            &lt;if test=&quot;ordered != null and ordered != &#39;&#39;&quot;&gt;ordered = #&#123;ordered&#125;,&lt;/if&gt;
            &lt;if test=&quot;description != null and description != &#39;&#39;&quot;&gt;description = #&#123;description&#125;,&lt;/if&gt;
            &lt;if test=&quot;status != null and status != &#39;&#39;&quot;&gt;status = #&#123;status&#125;&lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;;
    &lt;/update&gt;
    &lt;delete id=&quot;deleteById&quot;&gt;
        delete from tb_brand where id = #&#123;id&#125;;
    &lt;/delete&gt;
    &lt;/delete&gt;
    &lt;delete id=&quot;deleteByIds&quot;&gt;
        /*
         mybatis会将数组参数封装成一个map集合
            *默认 :array=数组
            *使用@paran注解改变map集合默认key的名称
         */
        delete from tb_brand where id
        in
            &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
                #&#123;id&#125;
            &lt;/foreach&gt;
    &lt;/delete&gt;

&lt;/mapper&gt;
</code></pre>
<pre><code class="java">import com.it.pojo.Brand;
import org.apache.ibatis.annotations.Param;

import java.util.List;

/**
 * @author Brand接口
 */
public interface BrandMapper &#123;
    /**
     * 查询所有
     * @return
     * 返回一个Brand类列表
     */
    List&lt;Brand&gt; selectAll();
    /**
     * 查看详情，根据ID查询
     * @return
     * 返回一个Brand类
     * @param id 要查询的id
     */
    Brand selectById(int id);
    /**
     * 条件查询
     * *参数接收
     *      1.散装参数：如果有多个参数需要使用@param(&quot;SQL参数占位符名称&quot;)
     *      2.对象参数
     *      3.map集合参数
     * @param status 根据状态查询
     * @param companyName 根据公司名字查询
     * @param brandName 根据产品名字查询
     * @return 返回Brand列表
     */
    List&lt;Brand&gt; selectByCondition(@Param(&quot;status&quot;) int status, @Param(&quot;companyName&quot;) String companyName, @Param(&quot;brandName&quot;) String brandName);
&#125;
    List&lt;Brand&gt; selectByCondition(Brand brand);
    List&lt;Brand&gt; selectByCondition(Map&lt;Object,Object&gt; map);
    /**
     * 增加数据
     * @param brand 需要添加的数据
     */
    void add(Brand brand);
    /**
     * 修改数据
     * @param brand 需要修改的数据
     */
    void update(Brand brand);
    /**
     * 删除数据
     * @param id 选择删除行的id
     */
    void deleteById(int id);
    /**
     * 批量删除
     * @param ids 要删除的id组成的数组
     */
    void deleteByIds(int[] ids);    
</code></pre>
<p>动态查询</p>
<ul>
<li><p>SQL语句会随着用户的输入或夕卜部条件的变化而变化，我们称为动态SQL</p>
</li>
<li><p>MyBatis对动态SQL有很强大的支撑：</p>
<ul>
<li><p>if</p>
<ul>
<li>用于判断参数是否有值，使用test属性进行条件判断<ul>
<li>存在的问题：第一个条亻牛不需要逻辑运算符</li>
<li>解决方案<ol>
<li>使用恒等式让所有条件格式都一</li>
<li>标签替换where关键字</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>choose(when,otherwise)</p>
<ul>
<li>choose：相当于switch</li>
<li>when：相当于case</li>
<li>otherwise：相当于default</li>
</ul>
</li>
<li><p>trim(where，set)</p>
</li>
<li><p>foreach</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-2添加"><a href="#4-2添加" class="headerlink" title="4.2添加"></a>4.2添加</h3><ol>
<li><p>编写接口方法：Mapper接口</p>
<ul>
<li>参数：除了id之外的所有数据</li>
<li>结果：void</li>
</ul>
</li>
<li><p>编写SQL语句：SQL映射文件</p>
</li>
<li><p>执行方法，测试</p>
<pre><code class="java">MyBatis事务：
openSession()：默认开启事务，进行一增删改操榨后需要使用sqlSession.commit();手动提交事务
openSession(true):可以设置为自动提交事务（关闭事务）
</code></pre>
</li>
</ol>
<p>在数据添加成功后，需要获取插入数据库数据的主键的值</p>
<ul>
<li><p>比如：添加订单和订单项</p>
<ol>
<li><p>添加订单</p>
</li>
<li><p>添加订单项，订单项中需要所属订单的id</p>
<pre><code class="xml">&lt;insertid=&quot;addOrdet&#39;useGeneratedKeys=&quot;true&quot;keyProperty=&quot;id&quot;&gt;
    insert intO tb_order(payment,payment_type,status)
    values(#&#123;payment&#125;,#&#123;paymentType&#125;,#&#123;status&#125;)；
&lt;/insert&gt;
</code></pre>
</li>
</ol>
</li>
</ul>
<h3 id="4-3修改"><a href="#4-3修改" class="headerlink" title="4.3修改"></a>4.3修改</h3><ol>
<li>编写接口方法：Mapper接口<ul>
<li>参数：所有数据</li>
<li>结果，void</li>
</ul>
</li>
<li>编写SQL语句：SQL映射文件</li>
<li>执行方法，测试</li>
</ol>
<h3 id="4-4删除"><a href="#4-4删除" class="headerlink" title="4.4删除"></a>4.4删除</h3><ol>
<li>编写接口方法：Mapper接口<ul>
<li>参数：id</li>
<li>结果：void</li>
</ul>
</li>
<li>编写SQL语句：SQL映射文件</li>
<li>执行方法，测试</li>
</ol>
<p>批量删除</p>
<ol>
<li>编写接口方法：Mapper接口<ul>
<li>参数：id数组</li>
<li>结果：void</li>
</ul>
</li>
<li>编写SQL语句：SQL映射文件</li>
<li>执行方法，测试</li>
</ol>
<h2 id="5-参数传递"><a href="#5-参数传递" class="headerlink" title="5.参数传递"></a>5.参数传递</h2><ul>
<li>单个参数：<ol>
<li>POJO类型：直接使用，属性名和参数占位符一致</li>
<li>Map集合：键名和参数占位符一致</li>
<li>ColIection:封装为Map集合,可以使用@param注解，    替换map集合中默认的arg键名<ol>
<li>map.put(“arg0”,ColIection集合)</li>
<li>map.put(“colIection”,colIection集合)</li>
</ol>
</li>
<li>List：封装为Map集合,可以使用@param注解，    替换map集合中默认的arg键名<ol>
<li>map.put(“arg0”,list集合)</li>
<li>map.put(“colIection”,llist集合)</li>
<li>map.put(“llist”,llist集合)</li>
</ol>
</li>
<li>Array：封装为Map集合,可以使用@param注解，    替换map集合中默认的arg键名<ol>
<li>map.put(“arg0”,数组)</li>
<li>map.put(“array”,数组)</li>
</ol>
</li>
<li>其他类型：直接使用</li>
</ol>
</li>
<li>多个参数：,可以使用@param注解，    替换map集合中默认的arg键名<ol>
<li>封装为map集合</li>
<li>map put〔”arg0”，参数值1〕<br>map put〔”arg1”，参数值1）<br>map put〔”param1”，参数值1）<br>map put〔”param2”，参数值2)</li>
</ol>
</li>
</ul>
<p>==MyBatis提供了ParamNameResolver类来进行参数封装==</p>
<p>==建议：将来都使用@Param注解来修改Map集合中默认的键名，并使用修改后的名称来获取值，这样可读性更高！==</p>
<h2 id="6-注解完成增删改查"><a href="#6-注解完成增删改查" class="headerlink" title="6.注解完成增删改查"></a>6.注解完成增删改查</h2><p>使用注解开发会比配置文件开发更加方便</p>
<ul>
<li>注解完成简单功能</li>
<li>配置文件完成复杂功能</li>
</ul>
<pre><code class="java">    /**
     * 按id查询
     * @param id 所需要查询的id
     * @return 返回Brand对象
     */
    @Select(&quot;select * from tb_brand where id = #&#123;id&#125;&quot;)
    Brand selectById(int id);
</code></pre>
<h1 id="HTML文档"><a href="#HTML文档" class="headerlink" title="HTML文档"></a>HTML文档</h1><p><a href="https://www.w3school.com.cn/tags/index.asp">文档</a></p>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>HTML是一门语言，所有的网页都是用HTML这门语言编写出来的</li>
<li>HTML(HyperTextMarkupLanguage):超文本标记语言<ul>
<li>超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容</li>
<li>标记语言，由标签构成的语言</li>
</ul>
</li>
<li>HTML运行在浏览器上，HTML标签由浏览器来解析</li>
<li>HTML标签都是预定义好的。例如：使用<img>展示图片</li>
<li>W3C标准：网页主要由三部分组成<ul>
<li>结构：HTML</li>
<li>表现：CSS</li>
<li>行为：JavaScript</li>
</ul>
</li>
</ul>
<h2 id="2-入门-1"><a href="#2-入门-1" class="headerlink" title="2.入门"></a>2.入门</h2><ol>
<li><p>新建文本文件，后缀名改为.html</p>
</li>
<li><p>编写TML结构标</p>
</li>
<li><p>在<body>中定义文字</body></p>
<pre><code class="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
<h2 id="3-基础标签"><a href="#3-基础标签" class="headerlink" title="3.基础标签"></a>3.基础标签</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><h1>~<h6></h6></h1></td>
<td>定义标题，h1最大，h6最小</td>
</tr>
<tr>
<td><font></font></td>
<td>定义字体、字体尺寸、字体颜色</td>
</tr>
<tr>
<td><b></b></td>
<td>定义粗体文本</td>
</tr>
<tr>
<td><i></i></td>
<td>定义斜体文本</td>
</tr>
<tr>
<td><u></u></td>
<td>定义文本下划线</td>
</tr>
<tr>
<td><center></center></td>
<td>定义文本居中</td>
</tr>
<tr>
<td><p></p></td>
<td>定义段落</td>
</tr>
<tr>
<td><br></td>
<td>定义换行</td>
</tr>
<tr>
<td><hr></td>
<td>定义水平线</td>
</tr>
</tbody></table>
<p><img src="/.com//%E6%A0%87%E7%AD%BE-164903510278441.png"></p>
<pre><code class="html">&lt;!-- html5 标识 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;!-- 字符集 --&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;html入门&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;我是标题h1&lt;/h1&gt;
    &lt;h2&gt;我是标题h2&lt;/h2&gt;
    &lt;h3&gt;我是标题h3&lt;/h3&gt;
    &lt;h4&gt;我是标题h4&lt;/h4&gt;
    &lt;h5&gt;我是标题h5&lt;/h5&gt;
    &lt;h6&gt;我是标题h6&lt;/h6&gt;
    &lt;hr&gt;
    &lt;!-- 
        html 表示颜色：
            1.英文单词:red,blue
            2.rgb:(值1，值2，值3)，取值范围0~255
            3.#值1值2值3：值得范围是00~FF
     --&gt;
    &lt;font color = #ff0000 face = &quot;楷体&quot; size = &quot;18&quot;&gt;你好吗&lt;/font&gt;
    &lt;hr&gt;
    &lt;p&gt;
        MySQL.com 使用 Oracle SSO 进行身份验证。如果您已有 Oracle Web 帐户，请单击登录链接。
    &lt;/p&gt;
    &lt;p&gt;否则，您可以通过单击“注册”链接并按照说明注册一个免费帐户。&lt;/p&gt;
    &lt;hr&gt;
    &lt;b&gt;离离原上草&lt;/b&gt;&lt;br&gt;&lt;b&gt;一岁一枯荣&lt;/b&gt;
    &lt;i&gt;斜体&lt;/i&gt;&lt;u&gt;下划线&lt;/u&gt;
    &lt;hr&gt;
    &lt;center&gt;居中显示&lt;/center&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="4-图片、音频、视频标签"><a href="#4-图片、音频、视频标签" class="headerlink" title="4.图片、音频、视频标签"></a>4.图片、音频、视频标签</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><img></td>
<td>定义图片</td>
</tr>
<tr>
<td><dudio></dudio></td>
<td>定义音频</td>
</tr>
<tr>
<td><video></video></td>
<td>定义视频</td>
</tr>
</tbody></table>
<ul>
<li>img:定义图片<ol>
<li>src:规定显示图像的URL（统一资源定位符）</li>
<li>height：定义图像的高度</li>
<li>width：定义图像的宽度</li>
</ol>
</li>
<li>audio:定义音频。支持的音频格式：MP3、WAV、OGG<ul>
<li>src:规走音频的URL</li>
<li>controls:显示播放控件</li>
</ul>
</li>
<li>video：定义视频。支持的音频格式：MP4,WebM、OGG<ul>
<li>src:规定视频的URL</li>
<li>controls:．显示播放控件</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;!-- html5 标识 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;!-- 字符集 --&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;html入门&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 
        资源路径：
            1.绝对路径：完整路径
            2.相对路径：相对位置关系
                当前目录可以直接写图片名字
                ../ 上一级目录
                /   根目录
        尺寸单位
            1.px：像素
            2.百分比
     --&gt;
    &lt;img src=&quot;乌鸦.jpg&quot; alt=&quot;加载中...&quot; width=&quot;400&quot;&gt;
    &lt;audio src=&quot;音频16 读信.mp3&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt;
    &lt;video src=&quot;1080p云使结尾视频.mp4&quot; controls=&quot;controls&quot; height=&quot;300&quot;&gt;&lt;/video&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="5-超链接标签"><a href="#5-超链接标签" class="headerlink" title="5.超链接标签"></a>5.超链接标签</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a></a></td>
<td>定义超链接，用于链接另一个资源</td>
</tr>
</tbody></table>
<ul>
<li>href：指定访问资源的URL</li>
<li>target:指定打开资源方式<ul>
<li>_self:默认值，在当前页面打开</li>
<li>_blank：在空白页面打开</li>
</ul>
</li>
</ul>
<h2 id="6-列表标签"><a href="#6-列表标签" class="headerlink" title="6.列表标签"></a>6.列表标签</h2><ul>
<li>有序列表</li>
<li>无序列表</li>
<li></li><li>设置列表项</li>
<li>type 设置标识符</li>
</ul>
<pre><code class="html">&lt;!-- html5 标识 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;!-- 字符集 --&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;html入门&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 有序列表 --&gt;
    &lt;ol type=&quot;A&quot;&gt;
        &lt;li&gt;咖啡&lt;/li&gt;
        &lt;li&gt;茶&lt;/li&gt;
        &lt;li&gt;牛奶&lt;/li&gt;
    &lt;/ol&gt;
    &lt;!-- 无序列表 --&gt;
    &lt;ul&gt;
        &lt;li&gt;咖啡&lt;/li&gt;
        &lt;li&gt;茶&lt;/li&gt;
        &lt;li&gt;牛奶&lt;/li&gt;       
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="7-表格标签"><a href="#7-表格标签" class="headerlink" title="7.表格标签"></a>7.表格标签</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><table></table></td>
<td>定义表格</td>
</tr>
<tr>
<td></td></tr><tr>
<td>定义行</td>
</tr>
<tr>
<td></td><td></td>
<td>定义单元格</td>
</tr>
<tr>
<td><th></th></td>
<td>定义表头单元格</td>
</tr>
</tbody></table>
<p>table:定义表格</p>
<ul>
<li>border:规定表格边框的宽度</li>
<li>width：规定表格的宽度</li>
<li>cellspacing：规定单元格之间的空白</li>
</ul>
<p>tr:定义行</p>
<ul>
<li>align：定义表格行的内容对齐方式</li>
</ul>
<p>td：定义单元格</p>
<ul>
<li>rowspan．规定单元格可横跨的行数</li>
<li>colspan．规定单元格可横跨的列数</li>
</ul>
<pre><code class="html">&lt;!-- html5 标识 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;!-- 字符集 --&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;html入门&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500&quot;&gt;
        &lt;tr&gt;
            &lt;th&gt;序号&lt;/th&gt;
            &lt;th&gt;品牌Logo&lt;/th&gt;
            &lt;th&gt;品牌名称&lt;/th&gt;
            &lt;th&gt;企业名称&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr align=&quot;center&quot;&gt;
            &lt;td&gt;010&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;三只松鼠&lt;/td&gt;
            &lt;td&gt;三只松鼠&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr align=&quot;center&quot;&gt;
            &lt;td&gt;008&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;优衣库&lt;/td&gt;
            &lt;td&gt;优衣库&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr align=&quot;center&quot;&gt;
            &lt;td&gt;008&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;小米&lt;/td&gt;
            &lt;td&gt;小米&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
    &lt;hr&gt;
    &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500&quot;&gt;
        &lt;tr&gt;
            &lt;th colspan=&quot;2&quot;&gt;品牌Logo&lt;/th&gt;
            &lt;th&gt;品牌名称&lt;/th&gt;
            &lt;th&gt;企业名称&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr align=&quot;center&quot;&gt;
            &lt;td&gt;010&lt;/td&gt;
            &lt;td&gt;11111111111&lt;/td&gt;
            &lt;td&gt;三只松鼠&lt;/td&gt;
            &lt;td&gt;三只松鼠&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr align=&quot;center&quot;&gt;
            &lt;td rowspan=&quot;2&quot;&gt;008&lt;/td&gt;
            &lt;td&gt;11111111111&lt;/td&gt;
            &lt;td&gt;优衣库&lt;/td&gt;
            &lt;td&gt;优衣库&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr align=&quot;center&quot;&gt;
            &lt;td&gt;11111111111&lt;/td&gt;
            &lt;td&gt;小米&lt;/td&gt;
            &lt;td&gt;小米&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="8-布局标签"><a href="#8-布局标签" class="headerlink" title="8.布局标签"></a>8.布局标签</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><div></div></td>
<td>定义HTML文档中的一个区域部分，经常与CSS一起使用，用来布局页面</td>
</tr>
<tr>
<td><span></span></td>
<td>用于组合行内元素</td>
</tr>
</tbody></table>
<h2 id="9-表单标签"><a href="#9-表单标签" class="headerlink" title="9.表单标签"></a>9.表单标签</h2><ul>
<li><p>表单：在网页中主要负责数据采集功能，使用<form>标签定义表单</form></p>
</li>
<li><p>表单项（元素）：不同类型的input元素、下拉列表、文本域等</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><form></form></td>
<td>定义表单</td>
</tr>
<tr>
<td><input></td>
<td>定义表单项，通过tepe属性控制输入形式</td>
</tr>
<tr>
<td><label></label></td>
<td>为表单定义标注</td>
</tr>
<tr>
<td><select></select></td>
<td>定义下拉列表</td>
</tr>
<tr>
<td><option></option></td>
<td>定义下拉列表自的列表项</td>
</tr>
<tr>
<td><textarea></textarea></td>
<td>定义文本域</td>
</tr>
</tbody></table>
</li>
<li><p>form：定义表单</p>
<ul>
<li>action:规定当提交表单时向何处发送表单数据，URL</li>
<li>method：规定用于发送表单数据的方式<ul>
<li>get:浏览器会将数据直接附在表单的actionURL之后。大小有限制</li>
<li>post:浏览器会将数据放到http请求消息体中。大小无限制</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>type取值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>默认值，定义单行输入的字段</td>
</tr>
<tr>
<td>password</td>
<td>定义密码输入字段</td>
</tr>
<tr>
<td>redio</td>
<td>定义单选按钮</td>
</tr>
<tr>
<td>checkbox</td>
<td>定义复选框</td>
</tr>
<tr>
<td>file</td>
<td>定义文件上传按钮</td>
</tr>
<tr>
<td>hidden</td>
<td>定义隐藏的输入手段</td>
</tr>
<tr>
<td>submit</td>
<td>定义提交按钮，提交按钮会把表单数据发送到服务器</td>
</tr>
<tr>
<td>reset</td>
<td>定义重置按钮，重置按钮会清楚表单中的所有数据</td>
</tr>
<tr>
<td>button</td>
<td>定义可点击按钮</td>
</tr>
</tbody></table>
</li>
</ul>
<p><img src="/.com//%E8%A1%A8%E5%8D%95-164903495742140.png"></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;练习页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 
        form:
            action:指定表单提交的URL
                *表单项数据要想被提交，则必须指定其name属性
            method：指定表单提交的方式
                1.get：默认值
                    *请求参数会拼接在URL后边
                    *url长度有限制  4KB
                2.post：
                    *请求参数会拼接在http请求协议的请求体中
                    *请求参数无限制
     --&gt;
    &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;123&quot;&gt;
        &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt;
        &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;&lt;br&gt; 
        &lt;label for=&quot;psd&quot;&gt;密码：&lt;/label&gt;
        &lt;input type=&quot;password&quot; name=&quot;psd&quot; id=&quot;psd&quot;&gt;&lt;br&gt;
        &lt;br&gt;
        性别：
        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; id=&quot;man&quot;&gt;&lt;label for=&quot;man&quot;&gt;男&lt;/label&gt;
        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; id=&quot;woman&quot;&gt;&lt;label for=&quot;woman&quot;&gt;女&lt;/label&gt;&lt;br&gt;
        爱好：
        &lt;input type=&quot;checkbox&quot; value=&quot;1&quot; id=&quot;ly&quot;&gt;&lt;label for=&quot;ly&quot;&gt;旅游&lt;/label&gt;
        &lt;input type=&quot;checkbox&quot; value=&quot;2&quot; id=&quot;moving&quot;&gt;&lt;label for=&quot;moving&quot;&gt;电影&lt;/label&gt;
        &lt;input type=&quot;checkbox&quot; value=&quot;3&quot; id=&quot;game&quot;&gt;&lt;label for=&quot;game&quot;&gt;游戏&lt;/label&gt;
        &lt;br&gt;
        &lt;select name=&quot;city&quot; id=&quot;city&quot;&gt;
            &lt;option value=&quot;BeiJing&quot;&gt;北京&lt;/option&gt;
            &lt;option value=&quot;ShangHai&quot;&gt;上海&lt;/option&gt;
            &lt;option value=&quot;GuangZhou&quot;&gt;广州&lt;/option&gt;
        &lt;/select&gt;
        &lt;br&gt;
        个&lt;label for=&quot;desc&quot;&gt;人描述&lt;/label&gt;
        &lt;textarea name=&quot;desc&quot; id=&quot;desc&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;
        &lt;br&gt;
        头像：
        &lt;input type=&quot;file&quot;&gt;
        &lt;br&gt;&lt;br&gt;
        &lt;input type=&quot;submit&quot; value=&quot;免费注册&quot;&gt;
        &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;
        &lt;input type=&quot;button&quot; value=&quot;这是一个按钮&quot;&gt;
        &lt;br&gt;

    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><ul>
<li>CSS是一门语言，用于控制网页表现<br>CSS(CascadingStyleSheet)：虐叠样式表</li>
<li>W3C标准：网页主要由三部分组成<ul>
<li>结构：HTML</li>
<li>表现：CSS</li>
<li>行为：JavaScript</li>
</ul>
</li>
</ul>
<h2 id="1-css导入方式"><a href="#1-css导入方式" class="headerlink" title="1.css导入方式"></a>1.css导入方式</h2><ul>
<li><p>CSS导入HTML有三种方式</p>
<ol>
<li><p>内联样式：在标签内部使用sty|e属性，属性值是css属性键值对</p>
<p><code>&lt;div style=&quot;color:red&quot;&gt;Hello CSS~&lt;div&gt;</code></p>
</li>
<li><p>内部样式：定义<style>标签，在标签内部定义css样式</p>
<pre><code class="css">&lt;style type=&quot;text/css&quot;&gt;
    div&#123;
        color:red;
&#125;
&lt;/style&gt;
</code></pre>
</li>
<li><p>外部样式：定义link标签，引入外部的css文件</p>
<p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;demo.css&quot;&gt;</code></p>
<p>==demo.scc==</p>
<pre><code class="css">div&#123;
    color:red;
&#125;
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="2-css选择器"><a href="#2-css选择器" class="headerlink" title="2.css选择器"></a>2.css选择器</h2><ul>
<li><p>概念：选择器是选取需设置样式的元素（标签）</p>
</li>
<li><p>分类</p>
<ol>
<li><p>元素选择器</p>
<p><code>元素名称&#123;color:red;&#125;</code></p>
</li>
<li><p>id选择器</p>
<p><code>#id属性值&#123;color:red;&#125;</code></p>
</li>
<li><p>类选择器</p>
<p><code>.class属性值&#123;color:red;&#125;</code></p>
</li>
</ol>
</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;css选择器&lt;/title&gt;
    &lt;style&gt;
        div&#123;
            color: red;
        &#125;
        #name&#123;
            color: blue;
        &#125;
        .name&#123;
            color: pink;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;name&quot;&gt;div1&lt;/div&gt;
    &lt;div id=&quot;name&quot;&gt;div2&lt;/div&gt;
    &lt;div&gt;div3&lt;/div&gt;
    &lt;span class=&quot;name&quot;&gt;span&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;    
</code></pre>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><ul>
<li>JavaScript是一门跨平台、向对象的脚本语言，来控制网页行为的，它能使网页可交互</li>
<li>W3C标准：网页主要由三部分组成<br>结构：HTML<br>表现：CSS<br>行为：JavaScript</li>
<li>JavaScript和Java是完全不同的语言，不论是概念还是设计。但是基础语法类似。</li>
<li>JavaScript（简称：(S)在1995年由BrendanEich发明，并于1997年成为一部ECMA标准。</li>
<li>ECMAScript6(ES6)是最新的JavaScript版本（发布于2015年）。</li>
</ul>
<h2 id="1-引入方式"><a href="#1-引入方式" class="headerlink" title="1.引入方式"></a>1.引入方式</h2><ol>
<li><p>内部脚本：将jS代码定义在HTML页面中</p>
<ul>
<li>在HTML中，JavaScript代码必须位与<script>标签之间</script></li>
<li>在HTML文档中可以在任意地方，放置任意数量的<script>。</li>
<li>一般把脚本置于<bodY>元素的底部，可改善显示速度，因为脚本执行会拖慢显示</li>
</ul>
</li>
<li><p>外部脚本：将jS代码定义在外部jS文件中，然后引入到HTML页面中</p>
<ul>
<li><p>外部文件：demo.js</p>
</li>
<li><p>引入外部js文件</p>
</li>
<li><p>外部脚本不能包含<script>标签</p>
</li>
<li><script>标签不能自闭合</li>
</ul>
</li>
</ol>
<h2 id="2-基础语法"><a href="#2-基础语法" class="headerlink" title="2.基础语法"></a>2.基础语法</h2><h3 id="2-1书写语法"><a href="#2-1书写语法" class="headerlink" title="2.1书写语法"></a>2.1书写语法</h3><ol>
<li>区分大小写：与」一样，变量名、函数名以及其他一切东西都是区分大小写的</li>
<li>每行结尾的分号可有可无</li>
<li>注释：<ul>
<li>单行注释：/／注释内容</li>
<li>多行注释：/<strong>注释内容</strong>/</li>
</ul>
</li>
<li>大括号表示代码块</li>
</ol>
<h3 id="2-2输出语句"><a href="#2-2输出语句" class="headerlink" title="2.2输出语句"></a>2.2输出语句</h3><ul>
<li>使用window.alert()写入警告框</li>
<li>使用document.write()写入HTML输出</li>
<li>使用console.log()写入浏览器控制台</li>
</ul>
<h3 id="2-3变量"><a href="#2-3变量" class="headerlink" title="2.3变量"></a>2.3变量</h3><ul>
<li><p>JavaScript中．用var关键字(varable的缩写）来声明变量</p>
</li>
<li><p>是一门弱类型语言，父里可以存放不同类型的值</p>
</li>
<li><p>变量名需要遵循如下规则</p>
<ul>
<li><p>组成字符可以是任何字母、数字、下划线（_）或美元符号</p>
</li>
<li><p>数字不能开头</p>
</li>
<li><p>建议使用驼峰命名</p>
</li>
</ul>
</li>
<li><p>ECMAScript6|新增了1et关键字来定义变量。它的用法类似于var但是所声<br>明的变量，只在let关键字所在的代码块内有效，且不允许重复声明</p>
</li>
<li><p>ECMAScript6新增了const关键字，用来声明一个只读的常量。一旦声明常量的值就不能改变。</p>
</li>
</ul>
<h3 id="2-4-基础类型"><a href="#2-4-基础类型" class="headerlink" title="2.4.基础类型"></a>2.4.基础类型</h3><p>JavaScript中分为：原始类型和引用类型<br>5种原始类型：</p>
<ol>
<li>number:数字（整数、小数、NaN(NotaNumber))</li>
<li>string．字符、字符串，单双引皆可</li>
<li>blloean：布尔。true,false</li>
<li>null:对象为空</li>
<li>undefined：当声明的变量未初始化时，该变量的默认值是undefined</li>
</ol>
<p>==使用typeof运算符可以获取类型==</p>
<h3 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5.运算符"></a>2.5.运算符</h3><ul>
<li>一元运算符：++ ，–</li>
<li>算术运算符：+，-，*，/，%</li>
<li>赋值运算符：=，+=，-=…</li>
<li>关系运算符：&gt;，&lt;，&gt;=，&lt;=，！=，==，<code>===</code>…</li>
<li>逻辑运算符：&amp;&amp;，||，！</li>
<li>三元运算符：条件表达式？truevalue：falsevalue</li>
</ul>
<p>==在js中运算符会先进行类型转换，<code>===</code>会先判断类型，类型不一样直接报错==</p>
<p>类型转换</p>
<ul>
<li>其他类型转number<ol>
<li>string：按照字符串的字面值，如果字面值不是数字,则转为NaN。一般使用parseInt</li>
<li>boolean:true转1，false转0</li>
</ol>
</li>
<li>其他类型转boolean<ol>
<li>number:0和NaN转false，其他转true</li>
<li>string：空字符串转为false，其他转为true</li>
<li>null：false</li>
<li>undefined：false</li>
</ol>
</li>
</ul>
<h3 id="2-6-流程控制语句"><a href="#2-6-流程控制语句" class="headerlink" title="2.6.流程控制语句"></a>2.6.流程控制语句</h3><p>if，switch，for:，while:，do…while.</p>
<h3 id="2-7-函数"><a href="#2-7-函数" class="headerlink" title="2.7.函数"></a>2.7.函数</h3><p>函数（方法）是被设计为执行特定任务的代码块<br>关键词进行定义，语法为：</p>
<ul>
<li><p>定义：JavaScript函数通过function关键词进行定义，语法为：</p>
<pre><code class="javascript">function functionName(参数1，参数2...)&#123;
    要执行的代码
&#125;
</code></pre>
<ul>
<li>形式参数不需要类型。因为Javascript是弱类型语言</li>
<li>返回值也不需要定义类型，可以在函数内部直接使用return返回即可</li>
</ul>
</li>
<li><p>调用：函数名称（实际参数列表）</p>
</li>
<li><p>定义方式二、</p>
<pre><code class="javas">var functionName = function(形参列表)&#123;
    要执行的代码
&#125;
</code></pre>
</li>
<li><p>调用：js中，调用函数可以传任意个数参数</p>
</li>
</ul>
<h2 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h2><h3 id="3-1-Arrary"><a href="#3-1-Arrary" class="headerlink" title="3.1 Arrary"></a>3.1 Arrary</h3><p>JavaScript Array对象用于定义数组</p>
<ul>
<li><p>定义</p>
<ol>
<li><code>var 变量名 = new Array(元素列表)；//方式一</code></li>
<li><code>var 变量名 = [元素列表]//方式二</code></li>
</ol>
</li>
<li><p>访问</p>
<p><code>arr[索引] = 值；</code></p>
</li>
<li><p>JavaScript类似Java中的集合，长度类型都可变</p>
</li>
</ul>
<p>方法</p>
<ol>
<li>push：添加元素</li>
<li>splice删除元素</li>
</ol>
<h3 id="3-2-History历史记录"><a href="#3-2-History历史记录" class="headerlink" title="3.2 History历史记录"></a>3.2 History历史记录</h3><p>获取：使用window.history获取，其中window.可以省略</p>
<p>方法</p>
<table>
<thead>
<tr>
<th>back()</th>
<th>加载history列表中的前一个URL</th>
</tr>
</thead>
<tbody><tr>
<td>forword()</td>
<td>加载history列表中的后一个URL</td>
</tr>
</tbody></table>
<h3 id="3-3-Location地址栏对象"><a href="#3-3-Location地址栏对象" class="headerlink" title="3.3 Location地址栏对象"></a>3.3 Location地址栏对象</h3><p>获取：使用window.location获取，其中window.可以省略</p>
<p>属性</p>
<table>
<thead>
<tr>
<th>href</th>
<th>设置或返回完整的URL</th>
</tr>
</thead>
</table>
<h2 id="4-DOM"><a href="#4-DOM" class="headerlink" title="4.DOM"></a>4.DOM</h2><p>Document Object Model文档对象模型</p>
<p>将标记语言的各个组成部分封装为对象</p>
<ul>
<li>Document:整个文档对象</li>
<li>Element:元素对象</li>
<li>Attribute:．属性对象．</li>
<li>Text：文本对象</li>
<li>omme：注释对象</li>
</ul>
<p>JavaScript通过DOM,就能够对HTML进行操作了</p>
<ul>
<li><p>改变HTML元素的内容</p>
</li>
<li><p>改变HTML元素的样式（css）</p>
</li>
<li><p>对事件作出反应</p>
</li>
<li><p>添加和删除HTML元素</p>
</li>
<li><p>DOM是W3C（万维网联盟）的标准</p>
</li>
<li><p>DOM定义了访问HTML和文档的标准：</p>
</li>
<li><p>W3cDOM标准被分为3个不同的部分：</p>
<ol>
<li>核心DOM：针对任何结构化文档的标准模型<ul>
<li>Document.整个文档对象</li>
<li>Element:元素对象</li>
<li>Attribute：属性对象</li>
<li>Text:文本对象</li>
<li>comment:注释对象</li>
</ul>
</li>
<li>XMLDOM.针对XML文档的标准模型</li>
<li>HTMLDOM:针对HTML文档的标准模型<ul>
<li>lmage：<img></li>
<li>Button：&lt;inputtype=’button’&gt;</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="4-1-获取Element"><a href="#4-1-获取Element" class="headerlink" title="4.1 获取Element"></a>4.1 获取Element</h3><p>获取：使用对象的方法来获取</p>
<ol>
<li>getElementByl·根据id属性值获取，返回一个Element对象</li>
<li>getElementsByTagName.根据标签名称获取，返回Element对象数组</li>
<li>getElementsByName:根据name属性值获取，返回Element对象数组</li>
<li>getElementsByClassName.根据class属性值获取，返回Element对象数组</li>
</ol>
<h3 id="4-2使用"><a href="#4-2使用" class="headerlink" title="4.2使用"></a>4.2使用</h3><p>常见时间</p>
<table>
<thead>
<tr>
<th>事件名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>鼠标单机事件</td>
</tr>
<tr>
<td>onblur</td>
<td>元素失去焦点</td>
</tr>
<tr>
<td>onfocus</td>
<td>元素获得焦点</td>
</tr>
<tr>
<td>onload</td>
<td>当某个页面或图像被完全加载</td>
</tr>
<tr>
<td>onsubmit</td>
<td>当表单提交时触发该事件</td>
</tr>
<tr>
<td>onkeydown</td>
<td>某个键盘的键被按下</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标被移到某元素上</td>
</tr>
<tr>
<td>ommouseout</td>
<td>鼠标从某元素离开</td>
</tr>
</tbody></table>
<p>==Event代表事件对象==</p>
<h1 id="Web核心"><a href="#Web核心" class="headerlink" title="Web核心"></a>Web核心</h1><ul>
<li>Web:全球广域网，也称为万维网（www),能够通过浏览器访问的网站</li>
<li>JavaWeb：是用」ava技术来解决相关web互联网领域的技术栈</li>
</ul>
<p>B/S架构Browser/Server,浏览器/服务器架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可</p>
<ul>
<li>静态资源：HTML、CSS、JavaScript、图片等。负责页面展现</li>
<li>动态资源：Servlet、JSP等。负责逻辑处理</li>
<li>数据库：负责存储居</li>
</ul>
<h2 id="1、HTTP"><a href="#1、HTTP" class="headerlink" title="1、HTTP"></a>1、HTTP</h2><ul>
<li>概念：HyperTextTransferProtocol,超文本传输协议，规定了浏览器和服务器之间数据传输的规则</li>
</ul>
<p>HTTP协议特点：</p>
<ol>
<li>基于TCP协议：面向连接，安全</li>
<li>基于请求一响应模型的．一次请求对应一次响应</li>
<li>HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求一响应都是独立的。<ul>
<li>缺点：多次请求间不能共享数据。Java中使用会技术(Cookie、Session)来解决这个问题</li>
<li>优点：速度快</li>
</ul>
</li>
</ol>
<h3 id="1-1-请求数据格式"><a href="#1-1-请求数据格式" class="headerlink" title="1.1 请求数据格式"></a>1.1 请求数据格式</h3><p>请求数据分为3部分：</p>
<ol>
<li>请求行：请求数据的第一行。其中GET表示请求方式，/<br>表示请求资源路径，HTTP/11表示协议版本</li>
<li>请求头：第二行开始，格式为key，value形式。</li>
<li>请求体：POST请求的最后一部分，存放请求参数</li>
</ol>
<p>常见的HTTP请求头：</p>
<ul>
<li>Host:表示请求的主机名</li>
<li>User-Agent:浏览器版本，例如Chrome浏览器的标识类似Moa/5…Chrome/79,IE浏览器的标识类似Mozilla/5.0 (windowsNT…）likeGeck0,</li>
<li>Accept：表示浏览器能接收的资源类型，如text/*，image/<em>或者</em>/*表示所有，</li>
<li>Accept-Language:表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</li>
<li>Accept-Encoding.表示浏览器可以支持的压缩类型，例如gzip,deflate等。</li>
</ul>
<p>GET请求和POST请求区别：</p>
<ol>
<li><ul>
<li>GET请求请求参数在请求行中，没有请求体。</li>
<li>POST请求请求乡数在请求体中</li>
</ul>
</li>
<li>GET请求请求参数大小有限制，POST没有</li>
</ol>
<h3 id="1-2-相应数据格式"><a href="#1-2-相应数据格式" class="headerlink" title="1.2 相应数据格式"></a>1.2 相应数据格式</h3><p>响应数据分为3部分：</p>
<ol>
<li>响应行：响应数据的第一行。其中HTTP/I.1表示协议版本，200表示响应状态码，OK表示状态码描述</li>
<li>响应头：第二行开始，格式为key，value形式</li>
<li>响应体：最后一部分。存放响应数据</li>
</ol>
<h2 id="2-Web服务器"><a href="#2-Web服务器" class="headerlink" title="2.Web服务器"></a>2.Web服务器</h2><p>web服务器是一个应该程序（软件），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让web开发更加便捷。主要功能是”提供网上信息浏览服务”</p>
<h2 id="1-Tomcat"><a href="#1-Tomcat" class="headerlink" title="1. Tomcat"></a>1. Tomcat</h2><ul>
<li>概念，Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级web服务器，支持Servlet/JSP少量JavaEE规范。</li>
<li>JavaEE.JavaEnterpriseEdition,」ava企业版。指」ava企业级开发的技术规范总和。包含13项技术规范：JDBC、JNDlsEJB、RMIJSP、Servlet、XML、JMS、」avaIDL、JTS、JTA、JavaMailsJAF</li>
<li>Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖于Tomcat才能运行</li>
<li><a href="https://tomcat.apache.org/">官网</a></li>
</ul>
<h2 id="2-Servlt"><a href="#2-Servlt" class="headerlink" title="2.Servlt"></a>2.Servlt</h2><h3 id="1-1-入门"><a href="#1-1-入门" class="headerlink" title="1.1 入门"></a>1.1 入门</h3><ol>
<li><p>创建web项目，导入Servlet坐标</p>
<pre><code class="xml">&lt;&lt;dependency&gt;
    &lt;groupld&gt;javax.servlet&lt;/groupld&gt;
    &lt;artifactld&gt;javax.servlet-api&lt;/artifactld&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>创建：定义一个类，实现Servlt接口，并重写接口中的所有方法，并在Servlt中输入一句话</p>
<pre><code class="java">public class ServltDemo1 implements Servlt&#123;
    public void service()&#123;&#125;
&#125;
</code></pre>
</li>
<li><p>配置：再类上使用@WebServelt注解，配置该Servlt的访问路径</p>
<pre><code class="java">@WebServelt(&quot;/demo1&quot;)
public class ServeltDemo1 implements Servelt&#123;&#125;
</code></pre>
</li>
<li><p>访问：启动Tomcat,浏览器输入URL访问该Servelt</p>
<p><code>http://localhost:8080/web-demo/demo1</code></p>
</li>
</ol>
<h3 id="1-2-生命周期"><a href="#1-2-生命周期" class="headerlink" title="1.2 生命周期"></a>1.2 生命周期</h3><p>servlet运行在servlet容器()eb服务器）中，其生命周期由容器来管理，分为4个阶段：</p>
<ol>
<li>加载和实例化：默认情况下，当servlet第一次被访问时，由容器创建servlet对象</li>
<li>初始化：在servlet实例化之后，容器将调用servlet的init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次</li>
<li>请求处理：每次请求servlet时，servlet容器都会调用servlet的service0方法对请求进行处理。</li>
<li>服务终止：当需要释放内存或者容器关闭时，容器就会调用serv]et实例的destroy()方法完成资源的释放。在destroy()方法调用之后，容器会释这个servlet。t实例，该实例随后会被Java的垃圾收集器所回收</li>
</ol>
<h3 id="1-3-Servlet方法介绍"><a href="#1-3-Servlet方法介绍" class="headerlink" title="1.3 Servlet方法介绍"></a>1.3 Servlet方法介绍</h3><ol>
<li>getServletInfo()<ul>
<li>获取Servlet信息</li>
</ul>
</li>
<li>getServletConfig()<ul>
<li>获取ServIetConfig对象</li>
</ul>
</li>
<li>void init(ServletConfig servletConfig)<ul>
<li>初始化方法，在Servlet被创建时，只执行一次</li>
</ul>
</li>
<li>void service(ServletRequest servletRequest, ServletResponse servletResponse)<ul>
<li>提供服务方法，每次Servlet被访问，都会调用该方法</li>
</ul>
</li>
<li>public void destroy()<ul>
<li>销毁方法，当servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁servlet</li>
</ul>
</li>
</ol>
<h3 id="1-4Servlet体系结构"><a href="#1-4Servlet体系结构" class="headerlink" title="1.4Servlet体系结构"></a>1.4Servlet体系结构</h3><ul>
<li>Servlet<ul>
<li>Servlet体系根结构</li>
</ul>
</li>
<li>GenericServlet<ul>
<li>Servlet抽象实现类</li>
</ul>
</li>
<li>HttpServlet<ul>
<li>对HTTP协议封装的Servlet实现类</li>
</ul>
</li>
</ul>
<p>==我们将来开发B/S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会继承HttpServlet==</p>
<h3 id="1-5-Servlet-urlPaern配置"><a href="#1-5-Servlet-urlPaern配置" class="headerlink" title="1.5 Servlet urlPaern配置"></a>1.5 Servlet urlPaern配置</h3><ul>
<li>Servlet要想被访问，必须配置其访问路径(urlPattern)</li>
</ul>
<ol>
<li>一个Servlet,可以配置多个urlPattern<br>@WebServlet(urlPatterns={“/demo1”,”/demo2})</li>
<li>urlPattern配置规则<ol>
<li>精确匹配<ul>
<li>配置路径和访问路径必须一样</li>
</ul>
</li>
<li>目录匹配<ul>
<li>配置路径带有通配符</li>
</ul>
</li>
<li>扩展名匹配<ul>
<li>配置路径的扩展名和访问路径的扩展名一样</li>
</ul>
</li>
<li>任意匹配<ul>
<li>配置路径写==/==     <code>或</code>     ==/*==，访问路径随便写都会访问到</li>
</ul>
</li>
<li>/和/*区别：<ol>
<li>当我们的项目中配置了“/*“，意味着匹配任意访问路径<ol>
<li>当我们的项目中的Servlet配置了“/”，会覆盖掉tomcat中的DefaultServlet,当其他的u小pattern都匹配不上时都会走这个Servlet</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="1-6-Request-请求）和Response（响应）"><a href="#1-6-Request-请求）和Response（响应）" class="headerlink" title="1.6 Request(请求）和Response（响应）"></a>1.6 Request(请求）和Response（响应）</h3><ul>
<li><strong>Request</strong>：获取请求数据</li>
<li>Response：设置响应数据</li>
</ul>
<h4 id="1-6-1-Request"><a href="#1-6-1-Request" class="headerlink" title="1.6.1 Request"></a>1.6.1 Request</h4><h5 id="Request继承体系"><a href="#Request继承体系" class="headerlink" title="Request继承体系"></a>Request继承体系</h5><ul>
<li>ServletRequest<ul>
<li>Java提供的请求对象的根接口</li>
</ul>
</li>
<li>HttpServletRequest<ul>
<li>Java提供的对Http协议封装的请求对象接口</li>
</ul>
</li>
<li>RequestFacade<ul>
<li>Tomcat定义的实现类</li>
</ul>
</li>
</ul>
<ol>
<li>Tomcat需要解析请求数据,封装为request对象,并目创建request对象传递到service方法中</li>
<li>使用request对象，查阅JavaEEAPI文档的HttpServIetRequest接口</li>
</ol>
<h5 id="Request获取请求数据"><a href="#Request获取请求数据" class="headerlink" title="Request获取请求数据"></a>Request获取请求数据</h5><ul>
<li>请求数据分为三部分<ol>
<li>请求行<ul>
<li><code>GET/request-demo/req1?username=zhangsan HTTP/1.1</code></li>
<li>String geytMethod():获取请求方式：GET</li>
<li>String getContextPath:获取虚拟目录（项目访问路径）：/request-demo</li>
<li>StringBuffer getRequestURL()：获取URL（统一资源定位符）</li>
<li>String getRequestURI():获取URL(统一资源标识符)：/request-demo/req1</li>
<li>String geyQueryString():获取请求参数(GET方式)：username=zhangsan&amp;password=123</li>
</ul>
</li>
<li>请求头<ul>
<li>String getHeader(String name):根据请求头名称，获取值</li>
</ul>
</li>
<li>请求体<ul>
<li>ServletInputStream getInputStream():获取字节输入流</li>
<li>BufferedReader getReader()：获取字符输入流</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="通用方式获取请求参数"><a href="#通用方式获取请求参数" class="headerlink" title="通用方式获取请求参数"></a>通用方式获取请求参数</h5><ul>
<li><p>请求参数获取方式</p>
<ul>
<li>GET方式</li>
</ul>
<p><code>String get    QueryString()</code></p>
<ul>
<li><p>POST方式</p>
<p><code>bufferedReader getReader()</code></p>
</li>
</ul>
</li>
<li><p>Map&lt;String,String[]&gt;getParameterMap():获取所有参数的Map集合</p>
</li>
<li><p>String getParameterValues(String name)根据名称获得参数值(数组)</p>
</li>
<li><p>String getParameter(String name):根据名称获得参数值(单个值)</p>
</li>
</ul>
<h5 id="Request请求参数中文乱码处理"><a href="#Request请求参数中文乱码处理" class="headerlink" title="Request请求参数中文乱码处理"></a>Request请求参数中文乱码处理</h5><ul>
<li><p>请求参数如果存在中文，则会乱码</p>
</li>
<li><p>解决方案</p>
<ul>
<li><p>post设置输入流的编码</p>
<p><code>req.setCharacterEncoding(&quot;UTF-8&quot;)</code></p>
</li>
<li><p>通用方式（GET/POST)：先编码在解码</p>
<p><code>new String(username.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8);</code></p>
</li>
</ul>
</li>
</ul>
<p>URL编码</p>
<ol>
<li>将每个字符按编码转为二进制</li>
<li>每个字节按两个16进制数并在前面加上%</li>
</ol>
<p><strong>Tomcat8，0之后，已将GET请求乱码问题解决，设置默认的解码方式为UTF一8</strong></p>
<h5 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h5><ul>
<li><p>请求转发：一种在服务器内部的资源跳转方式</p>
</li>
<li><p>实现方式、</p>
<p><code>req.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp)</code></p>
</li>
<li><p>请求转发资源间共享数据．使用Request对象</p>
<ul>
<li>void setAttriÄYte(Stringname，Objecto):存储数据到request域中</li>
<li>Objectget Attribute(Stringname):根据key，获取值</li>
<li>void removeAttribute(Stringname):根据key，删除该键值对</li>
</ul>
</li>
<li><p>请求转发特点：</p>
<ol>
<li>浏览器地址栏路径不发生变化</li>
<li>只能转发到当前服务器的内部资源</li>
<li>一次请求，可以在转发的资源间使用request共享数据</li>
</ol>
</li>
</ul>
<h4 id="1-6-2-Response"><a href="#1-6-2-Response" class="headerlink" title="1.6.2 Response"></a>1.6.2 Response</h4><h5 id="Response设置响应数据功能介绍"><a href="#Response设置响应数据功能介绍" class="headerlink" title="Response设置响应数据功能介绍"></a>Response设置响应数据功能介绍</h5><ul>
<li>响应数据分三部分<ol>
<li>响应行<ul>
<li>void    setStatus(int sc):设置响应状态码</li>
</ul>
</li>
<li>响应头<ul>
<li>void    setHeader(String name,String value):设置响应头键值对</li>
</ul>
</li>
<li>响应体<ul>
<li>PringWriter getWriter():获取字符输出流</li>
<li>ServletOutputStream getOutputStream():获取字节输出流</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="Response完成重定向"><a href="#Response完成重定向" class="headerlink" title="Response完成重定向"></a>Response完成重定向</h5><ul>
<li><p>重定向：一种资源跳转方式</p>
</li>
<li><p>实现方式</p>
<pre><code class="java">resp.setStatus(302);
resp.setHeader(&quot;location&quot;,&quot;资源B的路径&quot;)；
</code></pre>
</li>
<li><p>简化方式</p>
<p><code>resp.sendRedirect(&quot;资源路径&quot;)</code></p>
</li>
</ul>
<p>重定向特点：</p>
<ol>
<li>浏览器地址栏路径发生变化</li>
<li>可以重定向到任意亻立置的资源（服务器内部、外部均可）</li>
<li>两次请求，不能在多个资源使用request共享数据</li>
</ol>
<h5 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h5><p>明确路径谁使用？</p>
<ul>
<li>浏览器使用．需要加虚拟目录（项目访问路径）</li>
<li>服务端使用．不需要加虚拟目录</li>
</ul>
<h5 id="Response响应字符数据"><a href="#Response响应字符数据" class="headerlink" title="Response响应字符数据"></a>Response响应字符数据</h5><ul>
<li><p>使用</p>
<ol>
<li><p>通过Response对象获取字符输出流</p>
<p><code>PringWriter writer = resp.getWriter();</code></p>
</li>
<li><p>写数据</p>
<p><code>writer.write(&quot;aaa&quot;);</code></p>
</li>
<li><p>．注意：<br>该流不需要关闭，随着响应结束，response对象销毁，由服务器关闭<br>中文数据乱码：原因通过Response获取的字符输出流默认编码：ISO-8859-1<br><code>resp.setContentType(&quot;text/html;charset=utf-8&quot;);</code></p>
</li>
</ol>
</li>
</ul>
<h5 id="Response响应字节数据"><a href="#Response响应字节数据" class="headerlink" title="Response响应字节数据"></a>Response响应字节数据</h5><ul>
<li><p>使用</p>
<ol>
<li>通过Response对象获取字节输出流<br><code>ServletOutputStream outputStream=resp.getOutputStream();</code></li>
<li>写数据<br><code>outputStream.write(字节数据）；</code></li>
</ol>
</li>
<li><p>IOUtils工具类使用</p>
<ol>
<li><p>导入坐标</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;commons-i0&lt;/groupId&gt;
    &lt;artifactld&gt;commons-io&lt;/artifactld&gt;
    &lt;version&gt;2.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>使用</p>
<p><code>IOUtils.copy（输入流，输出流）；</code></p>
</li>
</ol>
</li>
</ul>
<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><ul>
<li>概念：Java     Server    Pages,Java服务端页面</li>
<li>一种动态的网页技术，其中既可以定义HTML、JS、CSS等静态内容，还可以定义Java代码的动态内容</li>
<li>JSP=HTML+Java</li>
<li>JSP的作用：简化开发，避免了在Servlet中直接输出HTML析筌</li>
</ul>
<h2 id="1-入门-1"><a href="#1-入门-1" class="headerlink" title="1.入门"></a>1.入门</h2><ol>
<li><p>导入JSP坐标</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupld&gt;
    &lt;artifactId&gt;jsp-api&lt;/artifactld&gt;
    &lt;version&gt;2.2&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>创建JSP文件</p>
</li>
<li><p>编写HTML标签和Java代码</p>
<pre><code class="xml">&lt;body&gt;
    &lt;h1&gt;hello jsp~&lt;/h1&gt;
    &lt;% System.out.printf(&quot;jsp hello~&quot;);%&gt;
        &lt;/%&gt;
&lt;/body&gt;
</code></pre>
</li>
</ol>
<h2 id="2-JSP脚本"><a href="#2-JSP脚本" class="headerlink" title="2.JSP脚本"></a>2.JSP脚本</h2><ul>
<li><p>JSP脚本用于在JSP页面内定义Java代码</p>
</li>
<li><p>JSP脚本分类</p>
<ol>
<li>&lt;％…％&gt;：内容会直接放到jspServie()方法之中</li>
<li>&lt;％=…％&gt;：内容会放到out.print()中，作为out.print()的参数</li>
<li>&lt;％!…％&gt;：内容会放到jspService()方法之外，被类直接包含</li>
</ol>
</li>
<li><p>由于JSP页面内，既可以定义HTML标签，又可以定义Java代码，造成了以下问题：</p>
<ol>
<li>书写麻烦：特别是复杂的页面</li>
<li>阅读麻烦</li>
<li>复杂度高：运行需要依赖于各种环境，JRE,JSP容器，JavaEE..</li>
<li>占内存和磁盘，JSP会自动生成.java和，class文件占磁盘，运行的是．class文件占内存</li>
<li>调试困难：出错后，需要找到自动生成的.java文件进行调试</li>
<li>不利于团队协作：前端人员不会Java,后端人员不精HTML</li>
</ol>
</li>
</ul>
<h2 id="3-EL表达式"><a href="#3-EL表达式" class="headerlink" title="3.EL表达式"></a>3.EL表达式</h2><ul>
<li><p>ExpressionLanguage表达式语言，用于简化JSP页面内的Java代码</p>
</li>
<li><p>主要功能：获取娄划居</p>
</li>
<li><p>语法：${expression}</p>
<p><code>$&#123;brands&#125;</code>:获取域中存储的key为brands的数据</p>
</li>
</ul>
<p>Javaweb中的四大域对象：</p>
<ol>
<li>page:当前页面有效</li>
<li>request:当前请求有效</li>
<li>session，当前会话有效</li>
<li>application:当前应用有效</li>
</ol>
<p>==el表达式获取数据，会依次从这4个域中寻找，直到找到为止==</p>
<h2 id="4-JSTL标签"><a href="#4-JSTL标签" class="headerlink" title="4.JSTL标签"></a>4.JSTL标签</h2><ul>
<li><p>JSP标准标签库（Jsp    Standarded    Tag    Library)，使用标签取代SP页面上的Java代码</p>
</li>
<li><p>入门</p>
<ol>
<li><p>导入坐标</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;l.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;l.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>在JSP页面上引入JSTL标签库</p>
<p><code>&lt;％@taglib prefix=&quot;c&quot;uri=&quot;http://java.sun.com/jsp/jstl/core&quot;％&gt;</code></p>
</li>
<li><p>使用</p>
<ul>
<li>&lt;C:IF&gt;</li>
</ul>
</li>
</ol>
</li>
<li><p>&lt;c:forEach&gt;:相当于for循环</p>
<ul>
<li>items:被遍历的容器</li>
<li>var:遍历产生的临时变量</li>
<li>varStatus:遍历状态对象<ul>
<li>index:从0开始</li>
<li>count:从1开始</li>
</ul>
</li>
<li>begin:开始数</li>
<li>end:结束数</li>
<li>step:步长</li>
</ul>
</li>
</ul>
<h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><ul>
<li>MVC是一种分层开发的模式，其中<ul>
<li>M：Model，业务模型，处理业务</li>
<li>V：View：视图，界面展示</li>
<li>C：Controller，控制器，处理请求，调用模型和视图</li>
</ul>
</li>
<li>MVC好处<ul>
<li>职责单一，互不影响</li>
<li>有利于分工协作</li>
<li>有利于组件重用</li>
</ul>
</li>
</ul>
<h1 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h1><ul>
<li>表现层<ul>
<li>接收请求，封装数据，调用业务逻辑层，响应数据</li>
</ul>
</li>
<li>业务逻辑层<ul>
<li>对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑业务</li>
</ul>
</li>
<li>数据访问层<ul>
<li>对数据库的CRUD基本操作</li>
</ul>
</li>
</ul>
<h1 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h1><ul>
<li>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中<br>可以包含多次请求和响应</li>
<li>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话<br>的多次请求间共享数据</li>
<li>HTTP协议是无状态的，每次浏览器向务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟<br>斜支术来实现会话内数据共享</li>
<li>实现方式：<ol>
<li>客尸端会话跟踪技术：Cookie</li>
<li>服务端会话跟踪技术：Session</li>
</ol>
</li>
</ul>
<h2 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1.Cookie"></a>1.Cookie</h2><h3 id="1-1基本使用"><a href="#1-1基本使用" class="headerlink" title="1.1基本使用"></a>1.1基本使用</h3><ul>
<li><p>Cookie:客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问</p>
</li>
<li><p>使用</p>
<ol>
<li><p>创建Cookie对象，设置数据</p>
<p><code>Cookie cookie  = new Cookie(&quot;key&quot;,&quot;value)</code></p>
</li>
<li><p>发送Cookie到客户端，使用response对象</p>
<p><code>response.addCookie(cookie);</code></p>
</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><p>获取Cookie</p>
<ol>
<li><p>获取客户端携带的所有Cookie，使用request对象</p>
<p><code>Cookie[] cookies = request.getCookies();</code></p>
</li>
<li><p>遍历数组，获取每一个Cookie对象</p>
</li>
<li><p>使用Cookie对象方法获取数据</p>
<p><code>cookie.getName()</code></p>
<p><code>cookie.getValues()</code></p>
</li>
</ol>
</li>
</ul>
<h3 id="1-2原理"><a href="#1-2原理" class="headerlink" title="1.2原理"></a>1.2原理</h3><ul>
<li>Cookie的实现是基于HTTP协议的<ul>
<li>响应头：set-cookie</li>
<li>请求头：cookie</li>
</ul>
</li>
</ul>
<h3 id="1-3使用细节"><a href="#1-3使用细节" class="headerlink" title="1.3使用细节"></a>1.3使用细节</h3><ul>
<li>存活时间<ul>
<li>默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁</li>
<li>setMaxAge(intteconds)：设置C00kie存活时间<ol>
<li>正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除</li>
<li>负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁</li>
<li>零：删除对应Cookie</li>
</ol>
</li>
</ul>
</li>
<li>存储中文<ul>
<li>Cookie不能直接存中文</li>
<li>如需要存储，则需要进行转码：URL编码</li>
</ul>
</li>
</ul>
<h2 id="2-Session"><a href="#2-Session" class="headerlink" title="2.Session"></a>2.Session</h2><h3 id="2-1使用"><a href="#2-1使用" class="headerlink" title="2.1使用"></a>2.1使用</h3><ul>
<li><p>服务端会话跟斜支术：将数据保存到服务端</p>
</li>
<li><p>JavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能</p>
</li>
<li><p>使用</p>
<ol>
<li><p>获取Session对象</p>
<p><code>HttpSession session = request.getSession();</code></p>
</li>
<li><p>Session对象功能：</p>
<ol>
<li>void setAttribute(String name,Object o):存储数据到Session域中 </li>
<li>Object getAttribute(String name):根据key，获取值</li>
<li>void removeAttribute(String name):根据key,删除该键值对</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="2-2原理"><a href="#2-2原理" class="headerlink" title="2.2原理"></a>2.2原理</h2><ul>
<li>Session是基于Cookie实现的</li>
</ul>
<h3 id="2-3使用细节"><a href="#2-3使用细节" class="headerlink" title="2.3使用细节"></a>2.3使用细节</h3><ul>
<li><p>Session钝化、活化：</p>
<ul>
<li>服务器重启后，Session中的数据是否还在？</li>
<li>钝化：在服器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中</li>
<li>活化：再次启动服务器后，从文件中加载数据到Session中</li>
</ul>
</li>
<li><p>Seesion销毁：</p>
<ul>
<li><p>默认情况下，无操作，30min自动销毁</p>
<pre><code class="xml">&lt;session-config&gt;
    &lt;session-timeout&gt;30&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre>
</li>
<li><p>调用Session对象的invalidate()方法</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><ul>
<li>Cookie和Session都是来完成一次会话内多次请求间数据共享的<ul>
<li>区别：<ul>
<li>存储位置：Cookie是将数据存储在客户端，Session将数据存储在服务端</li>
<li>安全性：Cookie不安全，Session安全</li>
<li>数据大小：Cookie最大3KB，Session无大小限制</li>
<li>存储时间：Cookie可以长期存储，Session默认30分钟</li>
<li>服务器性能：Cookie不占服务器资源，Sessipn占用服务器资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><ul>
<li>概念，Filter表示过滤器，是JavaWeb三大组亻牛(ServletFilter、Listener)之一</li>
<li>过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。</li>
<li>过滤器一般完成一些通用的操作，比如：权限控制、统一编码处理、敏感字符处理等等，</li>
</ul>
<h2 id="1-入门-2"><a href="#1-入门-2" class="headerlink" title="1.入门"></a>1.入门</h2><ol>
<li><p>定义类，实现Filter接口，并重写所有方法</p>
<pre><code class="java">public class FilterDemo implements Filter&#123;
    public void inti (FilterConfig FilterConfig)
    public void doFilter(ServletRequest request
    public void destory()&#123;&#125;
&#125;
</code></pre>
</li>
<li><p>配置Filter拦截资源的路径：在类上定义@WebFilter注解</p>
<pre><code class="java">@WebFilter(&quot;/*&quot;)
public class FilterDemo implements Filter&#123;
</code></pre>
</li>
<li><p>在doFilter方法中输出一句话，并放行</p>
<pre><code class="java">public void doFilter(ServletRequest request,ser
                     System.out.println(&quot;filter 被指行了...&quot;)
                     chain.doFilter(request,response);
                     &#125;
</code></pre>
</li>
</ol>
<h2 id="2-执行流程"><a href="#2-执行流程" class="headerlink" title="2.执行流程"></a>2.执行流程</h2><ul>
<li>放行后访问对应资源，资源访问元成后，还会回到Fi|ter中吗？会</li>
<li>如果回到Filter中，是重头执行还是执行放行后的逻辑呢？</li>
<li>执行放行前逻辑==》放行–&gt;访问资源–&gt;执行放行后逻辑</li>
</ul>
<h2 id="3-使用细节"><a href="#3-使用细节" class="headerlink" title="3.使用细节"></a>3.使用细节</h2><ul>
<li>Filter可以根据需求，配置不同的拦截资源路径<br>@WebFiIte1(“/<code>*</code>”)<br>pubIic class FiIterDemo<ul>
<li>拦截具体源：/index.jsp:只有访问index.jsp时才会被拦截。</li>
<li>目录拦截：/user/<code>*</code>:访问/user下的所有资源，都会被拦截</li>
<li>后缀名拦截：<code>*</code>.jsp:访问后缀名为jsp的资源，都会被拦截</li>
<li>拦截所有：/<code>*</code>：访问所有资源，都会被拦截</li>
</ul>
</li>
<li>过滤器链<ul>
<li>一个web应用，可以配置多个过滤器，这多个过滤器称为过滤器链</li>
<li>注解配置的Filter,优先级按照过些器类名（字符串）的自然排序</li>
</ul>
</li>
</ul>
<h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><ul>
<li><p>概念Listener表示监听器，是JavaWeb三大组件(Servlet、Filter、Listener)之一</p>
</li>
<li><p>监听器可以监听就是在application,session,request三个对象创建、销毁或者往其中添加修改删除<br>属性时自动执行代码的功能组件</p>
</li>
<li><p>Listener分类：JavaWeb中提供了8个监听器</p>
<table>
<thead>
<tr>
<th>监听器的分类</th>
<th>监听器的名称</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>ServletContext监听</td>
<td>ServletContextListener</td>
<td>用于对ServIetContext对象进行监听（创建、悄毁）</td>
</tr>
<tr>
<td></td>
<td>ServletContextAttributeListener</td>
<td>对ServletContext对像中属性的监听（增删改属性）</td>
</tr>
<tr>
<td>session监听</td>
<td>HttpSessionListener</td>
<td>对Session对象的整体状态的监听（创建、销毁）</td>
</tr>
<tr>
<td></td>
<td>HttpSessionAttributeListener</td>
<td>对Session对像中的属性监听（增删改属性）</td>
</tr>
<tr>
<td></td>
<td>HttpSessionBindingListener</td>
<td>监听对象于session的绑定和解除</td>
</tr>
<tr>
<td></td>
<td>HttpSessionActivationListener</td>
<td>对Session数据的钝化活化的监听</td>
</tr>
<tr>
<td>Request监听</td>
<td>rvletReuestListener</td>
<td>对Request对象进行监听（创建、销毁）</td>
</tr>
<tr>
<td></td>
<td>ServletRequestAttributeListener</td>
<td>对Request对象中属性的监听（增删改属性）</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><ul>
<li>概念：AJAX(AsynchronousJavaScriptAndXML):异步的JavaScript和XML</li>
<li>作用：<ol>
<li>与服务器进行数据交换：通过AJAx可以给服务器发送请求，并获取服务器响应的数据<ul>
<li>使用了AJAx和服务器进行通信，就可以使用HTML+AJAx来替换JSP页面了</li>
</ul>
</li>
<li>异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用<br>户名是否可用校验，等等，</li>
</ol>
</li>
</ul>
<h2 id="1-入门-3"><a href="#1-入门-3" class="headerlink" title="1.入门"></a>1.入门</h2><ol>
<li><p>编写AjaxServlet,并使用response输出字符串</p>
</li>
<li><p>创建XMLHttpRequest对象：用于和服务器交换数据</p>
<pre><code class="javascript">var xmlhttp
if(window XMLHttpRequest)&#123;
//code for IE7+,Firefox,Chorme,Opera,Safari
xmlhttp = new XMLHttpRequest();
&#125;else&#123;
//code for IE6,IE5
xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
&#125;
</code></pre>
</li>
<li><p>向服务器发送请求</p>
<pre><code class="javascript">xmlhttp.open(&quot;GET&quot;,&quot;url&quot;);
xml.send();//发送请求
</code></pre>
</li>
<li><p>获取服务器响应数据</p>
<pre><code class="javascript">xmlhttp.onreadystatechange=function()&#123;
    if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200)&#123;
        alert(xmlhttp.responseText);
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h2 id="2-Axios异步框架"><a href="#2-Axios异步框架" class="headerlink" title="2.Axios异步框架"></a>2.Axios异步框架</h2><ul>
<li>对原生的AJAX进行封装，简化书写</li>
<li><a href="http://www,axios-http.cn/">官网</a></li>
</ul>
<ol>
<li><p>引入axios的js文件</p>
<p><code>&lt;script src = &quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li><p>使用axios发送请求，并获取响应结果</p>
<pre><code class="javascript">axios(&#123;
    method:&quot;get&quot;,
    url:&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;
&#125;).then(function(resp)&#123;
    alert(resp.data);
&#125;)

axios(&#123;
    method:&quot;post&quot;,
    url:&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;
    data:&quot;uaername=zhangsan&quot;
&#125;).then(function(resp)&#123;
    alert(resp.data);
&#125;)
</code></pre>
<p>请求方式别名</p>
<ul>
<li>为了方便起见，Axios已经为所有支持的请求方法提供了别名。</li>
</ul>
<ol>
<li><table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>get(url)</td>
<td>发起GET请求</td>
</tr>
<tr>
<td>post(url,请求参数)</td>
<td>发起POST请求</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1.基础语法"></a>1.基础语法</h2><ul>
<li><p>定义</p>
<pre><code class="javascript">var 变量名 = &#123;
    &quot;key1&quot;:value1,
    &quot;key2&quot;:value2,
    ...
&#125;;
</code></pre>
</li>
<li><p>获取数据</p>
<p><code>变量名.key</code></p>
</li>
</ul>
<h2 id="2-JSON和Java对象转换"><a href="#2-JSON和Java对象转换" class="headerlink" title="2.JSON和Java对象转换"></a>2.JSON和Java对象转换</h2><ul>
<li><p>请求数据：JSON字符串转换为Java对象</p>
</li>
<li><p>响应数据：Java对象转换为JSON字符串</p>
</li>
<li><p>Fstjson是阿里巴巴提供的一个Java语言编写的高性能功能完善的」SON库，是目前Java语言中最决的JSON<br>库，可以实ava对象和JSON字符串的相互转换。</p>
</li>
<li><p>使用</p>
<ol>
<li><p>导入坐标</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactld&gt;fastjson&lt;/artifactld&gt;
    &lt;version&gt;1.2.62&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>Java对象转JSON</p>
<p><code>String jsonStr = JSON.toJSONString(obj);</code></p>
</li>
<li><p>JSON字符串转Java对象</p>
<p><code>User user = JSON.parseObject(jsonStr,Uesr.class);</code></p>
</li>
</ol>
</li>
</ul>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><ul>
<li>Vue是一套前端免除原生JavaScript中的DOM操作，简化书写</li>
<li>基于MVVM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程氵主点放在数据上</li>
<li><a href="https://cn.vuejs.org/">官网</a></li>
</ul>
<p>==MVC：只能实现模型到视图的单向展示==</p>
<p>==MVVM：可以实现数据的双向绑定==</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ol>
<li><p>新建HTML页面，引入Vue.js文件</p>
<p><code>&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li><p>在JS代码区域，创建Vue核心对象，进行数据绑定</p>
<pre><code class="javascript">new Vue(&#123;
    el:&quot;#app&quot;,
    data()&#123;
        return&#123;
            username:&quot;&quot;
        &#125;
    &#125;
&#125;);
</code></pre>
</li>
<li><p>编写视图</p>
<pre><code class="html">&lt;div id=&quot;app&quot;&gt;
    &lt;input name=&quot;username&quot; v-model=&quot;username&quot;&gt;
    &#123;&#123;u&#125;&#125;
&lt;/div&gt;
</code></pre>
<h2 id="1-Vue常用命令"><a href="#1-Vue常用命令" class="headerlink" title="1.Vue常用命令"></a>1.Vue常用命令</h2><ul>
<li><p>指令：HTML标签上带有v-前缀的特殊属性，不同指令具有不同含义。例如：v-if,v-for..</p>
</li>
<li><p>常用指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>v-bind</td>
<td>为HTML标签绑定属性值，如设置href,css样式等</td>
</tr>
<tr>
<td>v-model</td>
<td>在表单元素上创建双向数据绑定</td>
</tr>
<tr>
<td>v-on</td>
<td>为HTML标签绑定事件</td>
</tr>
<tr>
<td>v-if</td>
<td>条件性的渲染某元素，判定为true是渲染，否则不渲染</td>
</tr>
<tr>
<td>v-else</td>
<td>条件性的渲染某元素，判定为true是渲染，否则不渲染</td>
</tr>
<tr>
<td>v-else-if</td>
<td>条件性的渲染某元素，判定为true是渲染，否则不渲染</td>
</tr>
<tr>
<td>v-show</td>
<td>根据条件展示某元素，区别在于切换的事display属性的值</td>
</tr>
<tr>
<td>v-for</td>
<td>列表渲染，遍历容器的元素或者对象的属性</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2.生命周期"></a>2.生命周期</h2><ul>
<li><p>生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法（钩子）</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>阶段周期</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>创建前</td>
</tr>
<tr>
<td>created</td>
<td>创建后</td>
</tr>
<tr>
<td>beforeMount</td>
<td>载入前</td>
</tr>
<tr>
<td>Mount</td>
<td>挂载完成</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>更新前</td>
</tr>
<tr>
<td>update</td>
<td>更新后</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>销毁前</td>
</tr>
<tr>
<td>destroy</td>
<td>销毁后</td>
</tr>
</tbody></table>
</li>
<li><p>mounted：挂载完成，Vue初始化成功，HTML页面渲染成功</p>
<ul>
<li><p>发送异步请求，加载数据</p>
</li>
<li><p>示例</p>
<pre><code class="javascript">new vue(&#123;
    el:&quot;#app&quot;
    mounted()&#123;
    alert(&quot;vue挂载完成，发送异步请求&quot;)
&#125;
&#125;)
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</style></p></li></ol></li></ul>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>血染钟楼规则</title>
    <url>/%E6%A1%8C%E6%B8%B8/%E8%A1%80%E6%9F%93%E9%92%9F%E6%A5%BC/%E8%A1%80%E6%9F%93%E9%92%9F%E6%A5%BC/</url>
    <content><![CDATA[<h1 id="游戏流程"><a href="#游戏流程" class="headerlink" title="游戏流程"></a><font size="8">游戏流程</font></h1><h2 id="第一个夜晚"><a href="#第一个夜晚" class="headerlink" title="第一个夜晚"></a><font color="#00ae9d" size="6"><strong>第一个夜晚</strong></font></h2><p><font size="5" color="#102b6a">&emsp;&emsp;
1. 说书人唤醒恶魔，告知恶魔三个不在场玩家的善良身份(建议7/10/13人局三村民，其它人数配置两村民一外来)，并告知他爪牙是谁<br>&emsp;&emsp;
2. 说书人唤醒所有爪牙，并告知他们恶魔是谁(ps：<font size="4" color="#d3c6a6">线下说书人可以同时唤醒爪牙和恶魔，但不能交流)</font><br>&emsp;&emsp;
3. 说书人按照不同角色技能发动顺序唤醒在第一个晚上拥有技能的玩家并配合他们使用自己的技能
</font></p>

<hr>
<h2 id="第一个白天"><a href="#第一个白天" class="headerlink" title="第一个白天"></a><font color="#00ae9d" size="6"><strong>第一个白天</strong></font></h2><p><font size="5" color="#102b6a">&emsp;&emsp;
1. 每个白天黎明之时，说书人将宣布有关上一个夜晚的死亡信息，之后玩家自由发言并且可以随意私聊，直到说书人宣布进入<font color="#d71345"><b>提名阶段</b></font>。
<br>&emsp;&emsp;
2. <font color="#d71345"><b>提名阶段</b></font>所有玩家保持安静每个人都可以提名自己认为可疑的玩家来听听他们的辩护或者提名自己来讲两句。
<br>&emsp;&emsp;
被提名玩家在30秒的辩护后（<font size="4" color="#d3c6a6">可适当延长</font>）进入<font color="#d71345"><b>投票环节</b></font>，从被提名玩家的上一位玩家开始顺时针投票，并在计票后进行发起下一次提名，直到说书人认为当天的<font color="#d71345"><b>提名阶段</b></font>可以结束了·
<br>&emsp;&emsp;
所有玩家都可以在白天的每一个投票环节中投票，但是死去的玩家只剩下最后一票，也就是他们的遗书。不过死人可以继续参与游戏，并且正常发言。
<br>&emsp;&emsp;
如果被提名玩家得票数达到场上存活人数的一半且在所有被提名者中得票最多，他被处决,如果当天得票最多的被提名者平票，没有人被处决,死人不能提名，但是可以被提名
<br>&emsp;&emsp;
每名玩家在每个白天只能提名一次也只能被提名一次。在处决完成后，白天结束。

<p></p></font></p><p></p>
<p>

<hr>
</p><h2 id="黄昏降临"><a href="#黄昏降临" class="headerlink" title="黄昏降临"></a><font color="#00ae9d" size="6"><strong>黄昏降临</strong></font></h2><p><font size="5" color="#102b6a">&emsp;&emsp;、
有些效果会在这个阶段发动。一些状态被在这个阶段改变·说书人则在这个阶段通过调整魔典上的标记来提醒自己需要注意的事情。
</font></p>

<hr>
<h2 id="其他夜晚"><a href="#其他夜晚" class="headerlink" title="其他夜晚"></a><font color="#00ae9d" size="6"><strong>其他夜晚</strong></font></h2><p><font size="5" color="#102b6a">&emsp;&emsp;
说书人按照不同角色的技能发动顺序唤醒在其他夜晚拥有技能的玩家并配合他们使用自己的技能
</font></p>

<hr>
<h2 id="游戏进行"><a href="#游戏进行" class="headerlink" title="游戏进行"></a><font color="#00ae9d" size="6"><strong>游戏进行</strong></font></h2><p><font size="5" color="#102b6a">&emsp;&emsp;重复234阶段直到游戏结束条件达成
</font></p>

<hr>
<h2 id="游戏结束"><a href="#游戏结束" class="headerlink" title="游戏结束"></a><font color="#00ae9d" size="6"><strong>游戏结束</strong></font></h2><p><font size="5" color="#102b6a">&emsp;&emsp;当场上的恶魔死亡时，善良阵营获胜，当场上的存活玩家为2时（不计算旅行者和传奇身份),邪恶阵营获胜·如果两个阵营同时获胜，则改为善良阵营朕胜
<p><font size="5" color="#102b6a">&emsp;&emsp;
部分角色的技能可能会改变游戏的胜利条件，请按照角色技能结算特殊胜利和特殊落败。
</font></p>
<p><font size="5" color="#102b6a">&emsp;&emsp;
部分角色的效果可能与说明书冲突，冲突处以角色技能优先，
</font></p></font>
</p>]]></content>
      <categories>
        <category>桌游</category>
        <category>血染钟楼</category>
      </categories>
      <tags>
        <tag>血染钟楼</tag>
      </tags>
  </entry>
  <entry>
    <title>javaGui笔记</title>
    <url>/java/swing/</url>
    <content><![CDATA[<h1 id="AWT-编程"><a href="#AWT-编程" class="headerlink" title="AWT 编程"></a>AWT 编程</h1><h2 id="一、Container容器"><a href="#一、Container容器" class="headerlink" title="一、Container容器"></a>一、Container容器</h2><h3 id="1-1-Container继承体系"><a href="#1-1-Container继承体系" class="headerlink" title="1.1 Container继承体系"></a>1.1 Container继承体系</h3><pre><code class="mermaid">graph TB
A[Obect]==&gt;B(Component)
B==&gt;C(Container)
C==&gt;D(Window:窗口容器)
C==&gt;E(Panel:内嵌容器)
C==&gt;F(ScrollPane:含有滚动条的容器)
D==&gt;G(Frame:创建窗口)
D==&gt;H(Dialog:创建对话框)
E==&gt;I(Applet)
</code></pre>
<ul>
<li>Window是可以独立存在的顶级窗口，默认使用Borderlayout管理内部组件布局</li>
<li>Panel可以容纳其他组件，但不可以独立存在，他必须内嵌在其他容器中使用，默认使用Flowlayout管理内部组件布局</li>
<li>ScrollPane是一个带滚动的容器，他也不能独立存在，默认使用BorderLayout管理其内部布局<span id="more"></span>
<h3 id="1-2常见API"><a href="#1-2常见API" class="headerlink" title="1.2常见API"></a>1.2常见API</h3></li>
</ul>
<p><em><strong>Component作为基类，提供了如下方法来设置组件的大小、位置、可见等。</strong></em></p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>setLocation(int x,int y)</td>
<td>设置组件的位置</td>
</tr>
<tr>
<td>setSize(int width,int height)</td>
<td>设置组件的大小</td>
</tr>
<tr>
<td>setBounds(int x,int y,int width,int height)</td>
<td>同时设置组件的位置、大小</td>
</tr>
<tr>
<td>setVisable(boolean b)  (默认不可见)</td>
<td>设置组件的可见性</td>
</tr>
</tbody></table>
<p><em><strong>Container作为容器根类，提供了如下方法来访问容器内的组件</strong></em></p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>Component add(Compontnt comp)</td>
<td>向容器中添加其他组件（该组件可以是普通组件，也可以是容器）返回被添加的组件</td>
</tr>
<tr>
<td>Component getComponentAt(int x,int y)</td>
<td>返回指定点的组件</td>
</tr>
<tr>
<td>int getComponentCount()</td>
<td>返回容器内组件的数量</td>
</tr>
<tr>
<td>Component[] getComponents()</td>
<td>返回该容器内的所有组件</td>
</tr>
</tbody></table>
<h4 id="1-2-1-Window"><a href="#1-2-1-Window" class="headerlink" title="1.2.1 Window"></a>1.2.1 Window</h4><p><img src="/images/swing/window.png"></p>
<pre><code class="java">//创建窗口对象
Frame frame = new Frame(&quot;测试window窗口&quot;);
//指定窗口位置，大小
frame.setLocation(100,100);
frame.setSize(500,300);
//设置窗口可见
frame.setVisible(true);
</code></pre>
<h4 id="1-2-2-Panel"><a href="#1-2-2-Panel" class="headerlink" title="1.2.2 Panel"></a>1.2.2 Panel</h4><p><img src="/images/swing/panel.png"></p>
<pre><code class="java">//创建窗口对象
Frame frame = new Frame(&quot;测试panel&quot;);
//创建一个Panel对象
Panel panel = new Panel();
//创建一个文本框和按钮并把他们放入Panel容器中
panel.add(new TextField(&quot;这里测试文本&quot;));
panel.add(new Button(&quot;这里是一个测试按钮&quot;));
//把Panel放入window中
frame.add(panel);
//设置窗口大小
frame.setBounds(100,100,500,300);
//设置窗口可见
frame.setVisible(true);
</code></pre>
<h4 id="1-2-3-ScrollPane"><a href="#1-2-3-ScrollPane" class="headerlink" title="1.2.3 ScrollPane"></a>1.2.3 ScrollPane</h4><p><img src="/images/swing/scrollpane.png"></p>
<pre><code class="java">//创建一个scrollPane对象
ScrollPane sp = new ScrollPane(ScrollPane.SCROLLBARS_ALWAYS);
//创建一个文本框和按钮并把他们放入Panel容器中
sp.add(new TextField(&quot;演示scrollPanel&quot;));
sp.add(new Button(&quot;测试按钮&quot;));
//把scrollPane放入window中
frame.add(sp);
</code></pre>
<h2 id="二、LayoutManager布局管理器"><a href="#二、LayoutManager布局管理器" class="headerlink" title="二、LayoutManager布局管理器"></a>二、LayoutManager布局管理器</h2><pre><code class="mermaid">graph TB
A[接口:LayoutManager] ==&gt; B(GridLayout)
A==&gt;C(FlowLayout)
A ===&gt; D(接口:LayoutManager2)
D ==&gt; E(CardLayout)
D ==&gt; F(GridBagLayout)
D ==&gt; G(BorderLayout)
</code></pre>
<h3 id="2-1-FlowLayout"><a href="#2-1-FlowLayout" class="headerlink" title="2.1 FlowLayout"></a>2.1 FlowLayout</h3><p><em><strong>从左向右排列所有组件，遇到边界就会折回下一行重新开始</strong></em></p>
<table>
<thead>
<tr>
<th>构造芳芳</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>FlowLayout()</td>
<td>使用默认的对局及默认的垂直间距、水平间距创建布局管理器</td>
</tr>
<tr>
<td>FlowLayout(int align)</td>
<td>使用指定的对齐方式及默认的垂直间距、水平间距创建布局管理器</td>
</tr>
<tr>
<td>FlowLayout(int align,int hgap,int vgap)</td>
<td>使用指定的对齐方式及指定的垂直间距、水平间距创建布局管理器</td>
</tr>
</tbody></table>
<p><img src="/images/swing/flowlayout.png"></p>
<pre><code class="java">//通过setLayout方法设置容器的布局管理器
frame.setLayout(new FlowLayout(FlowLayout.CENTER,20,20));
//添加多个按钮到frame中
for(int i = 0;i&lt;100;i++)&#123;
    frame.add(new Button(&quot;&quot;+i));
&#125;
//设置最佳大小 pack方法
frame.pack();
</code></pre>
<h3 id="2-2-BorderLayout"><a href="#2-2-BorderLayout" class="headerlink" title="2.2 BorderLayout"></a>2.2 BorderLayout</h3><ul>
<li>BorderLayout将容器分为EAST、SOUTH、 WEST 、NORTH、 CENTER五个区域 ,普通组件可以被放置在这5个区域的任意一个中。BorderLayout布局 管理器的布局示意图如图所示。</li>
</ul>
<p><img src="/images/swing/borderlayout-16490340685524.png"></p>
<ul>
<li>当改变使用Borderl ayout的容器大小时，NORTH、SOUTH和CENTER区域水平调整,而EAST、WEST 和CENTER区域垂直调整。使用BorderLayout 如下两个注意点:</li>
<li><ol>
<li>当向使用Borderl ayout布局管理器的容器中添加组件时，需 要指定要添加到哪个区域中。如果没有指定添加到哪个区域中,则默认添加到中间区域中;</li>
<li>如果向同一个区域中添加多个组件时，后放入的组件会覆先放入的组件;</li>
<li>如果不往某个区域放组件，那么该区域会被中间区域占据</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>BorderLayout()</td>
<td>使用默认的水平间距，垂直间距创建BorderLayout布局管理器</td>
</tr>
<tr>
<td>BorderLayout(int hgap,int vgap)</td>
<td>使用指定的水平间距、垂直间距创建BorderLayout布局管理器</td>
</tr>
</tbody></table>
<p><img src="images/swing/border.png"></p>
<pre><code class="java">//给frame指定BorderLayout布局管理器
frame.setLayout(new BorderLayout(30,10));
//在指定区域添加组件
frame.add(new Button(&quot;&quot;+1),BorderLayout.NORTH);
frame.add(new Button(&quot;&quot;+2),BorderLayout.SOUTH);
frame.add(new Button(&quot;&quot;+3),BorderLayout.WEST);
frame.add(new Button(&quot;&quot;+4),BorderLayout.EAST);
frame.add(new Button(&quot;&quot;+5),BorderLayout.CENTER);
</code></pre>
<h3 id="2-3-GridLayout"><a href="#2-3-GridLayout" class="headerlink" title="2.3 GridLayout"></a>2.3 GridLayout</h3><p>GridLayout布局管理器将容器分割成纵横线分隔的网格，每 个网格所占的区域大小相同。当向使用GridLayout布局管理器的容器中添加组件时，默认从左向右、从上向下依次添加到每个网格中。与FlowLayout不同的是,放置在GridL ayout布局管理器中的各组件的大小由组件所处的区域决定(每个组件将自动占满整个区域)。</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>GridLayout(int rows,int cols)</td>
<td>采用指定的行数、列数，以及默认的横向间距、纵向间距将容器分割成多个网格</td>
</tr>
<tr>
<td>GridLayout(int rows,int cols,int hgap,int vgap)</td>
<td>采用指定的行数、列数，以及指定的横向间距、纵向间距将容器分割成多个网格</td>
</tr>
</tbody></table>
<p><img src="/images/swing/%E8%AE%A1%E7%AE%97%E5%99%A8.png"></p>
<pre><code class="java">//创建panel对象，里面存放一个textFiled组件
Panel p = new Panel();
p.add(new TextField(30));
//把当前这个panel添加到frame的北边区域
frame.add(p,BorderLayout.NORTH);
//创建一个panel对象，并且把他的布局管理其设置为GridLayout
Panel p2 = new Panel(new GridLayout(3,5,4,4));
//往panel中添加内容
for(int i = 0;i&lt;10;i++)&#123;
    p2.add(new Button(i+&quot;&quot;));
&#125;
p2.add(new Button(&quot;+&quot;));
p2.add(new Button(&quot;-&quot;));
p2.add(new Button(&quot;*&quot;));
p2.add(new Button(&quot;/&quot;));
p2.add(new Button(&quot;.&quot;));
//把panel添加到frame中
frame.add(p2);
</code></pre>
<h3 id="2-4-CardLayout"><a href="#2-4-CardLayout" class="headerlink" title="2.4 CardLayout"></a>2.4 CardLayout</h3><p>CardLayout布局管理器以时间而非空间来管理它里面的组件,它将加灯容器的所有组件看成一叠卡糊(每个卡片其实就是一个组件),每次只有 最上面的那个Component柯见。就好像一副扑克牌,它们叠在一起,每次只有最上面的一张扑克牌才可见.</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>CardLayout()</td>
<td>创建默认的CardLayouut布局管理器</td>
</tr>
<tr>
<td>CardLayout(int hgap,int vgap)</td>
<td>通过指定卡片与容器左右边界的间距(hgap),左右边界(vgap)的间距来创建CardLayout布局管理器</td>
</tr>
<tr>
<td>first(Container target)</td>
<td>显示target容器的第一张卡片</td>
</tr>
<tr>
<td>last(Container target)</td>
<td>显示target容器的最后一张卡片</td>
</tr>
<tr>
<td>previous(Container target)</td>
<td>显示target容器的前一张卡片</td>
</tr>
<tr>
<td>next(Container target)</td>
<td>显示target容器的后一张卡片</td>
</tr>
<tr>
<td>show(Container target,String name)</td>
<td>显示target容器中指定名字的卡片</td>
</tr>
</tbody></table>
<p><img src="/images/swing/cardlayout.png"></p>
<pre><code class="java">//创建一个panel,用来存储多张卡片
//创建卡片布局对象并且把该对象设置给之前创建的容器
CardLayout card = new CardLayout();
Panel p1 = new Panel(card);
//往panel中存放多个组件
String[] name = &#123;&quot;第一张&quot;,&quot;第二张&quot;,&quot;第三张&quot;,&quot;第四张&quot;,&quot;第五张&quot;&#125;;
for(String i:name)&#123;
    p1.add(i,new Button(i));
&#125;
//把panelf到frame中间区域进行展示
frame.add(p1);
//创建另外一个panel p2，用来存储按钮组件
Panel p2 = new Panel();
//创建5个按钮组件
Button b1 = new Button(&quot;上一张&quot;);
Button b2 = new Button(&quot;下一张&quot;);
Button b3 = new Button(&quot;第一张&quot;);
Button b4 = new Button(&quot;最后一张&quot;);
Button b5 = new Button(&quot;第三张&quot;);
//创建一个监听器，监听按钮点击动作
ActionListener listener = e -&gt; &#123;
    String actionCommand = e.getActionCommand();
    switch (actionCommand) &#123;
        case &quot;上一张&quot; -&gt; card.previous(p1);
        case &quot;下一张&quot; -&gt; card.next(p1);
        case &quot;第一张&quot; -&gt; card.first(p1);
        case &quot;最后一张&quot; -&gt; card.last(p1);
        case &quot;第三张&quot; -&gt; card.show(p1, &quot;第三张&quot;);
    &#125;
    &#125;;
//把当前这个监听器和按钮绑定在一起
b1.addActionListener(listener);
b2.addActionListener(listener);
b3.addActionListener(listener);
b4.addActionListener(listener);
b5.addActionListener(listener);
//把按钮添加到p2中
p2.add(b1);
p2.add(b2);
p2.add(b3);
p2.add(b4);
p2.add(b5);
//把p2放到frame的南边区域
frame.add(p2,BorderLayout.SOUTH);
</code></pre>
<h3 id="2-5-BoxLayout"><a href="#2-5-BoxLayout" class="headerlink" title="2.5 BoxLayout"></a>2.5 BoxLayout</h3><p><em><strong>为了简化开发, Swing引入了一个新的布局管理器: BoxLayout。BoxLayout 可以在垂直和水平两个向上摆放GUI组件，BoxLayout 提供了如下一个简单的构造器:</strong></em></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>BoxLayout(Container target,int axis)</td>
<td>指定创建基于target容器的BoxLayout布局管理器,该布局管理器里的组件按axis向排列。中axis有BoxLayout.X_ AXIS(横向)和BoxLayout.Y_ AXIS (纵向〉两个方向。</td>
</tr>
</tbody></table>
<p><img src="/images/swing/boxlayout.png"></p>
<pre><code class="java">//创建一个BoxLayout对象，并且存放组件是垂直存放
BoxLayout boxLayout = new BoxLayout(frame, BoxLayout.Y_AXIS);
//把BoxLayout设置给Frame
frame.setLayout(boxLayout);
//往Frame里增加两个按钮组件
frame.add(new Button(&quot;按钮1&quot;));
frame.add(new Button(&quot;按钮2&quot;));
</code></pre>
<p><em><strong>在java.swing包中,提供了-个新的容器BoxI,该容器的默认布局管理器就是BoxL .ayout,大多数情况下,使用Box容器去容纳多个GUI组件,然后再把Box容器作为一个组件,添到其他的容器中,从而形成整体窗口布局。</strong></em></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>static Box createHorizontalBox()</td>
<td>创建一个水平排列组件的Box容器</td>
</tr>
<tr>
<td>static Box createVerticalBox()</td>
<td>创建一个垂直排列组件的Box容器</td>
</tr>
</tbody></table>
<p><img src="/images/swing/box1.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionListener;
public class Test &#123;
    public static void main(String[] args) &#123;
        //创建窗口对象
        Frame frame = new Frame(&quot;测试BoxLayout&quot;);

        //创建一个水平排列的box容器
        Box hbox = Box.createHorizontalBox();
        //往当前容器中添加两个按钮
        hbox.add(new Button(&quot;水平按钮1&quot;));
        hbox.add(new Button(&quot;水平按钮2&quot;));
        //创建一个垂直排列组件的box容器
        Box vbox = Box.createVerticalBox();
        //往当前容器中添加两个按钮
        vbox.add(new Button(&quot;垂直按钮1&quot;));
        vbox.add(new Button(&quot;垂直按钮2&quot;));
        //把两个box添加到frame中展示
        frame.add(hbox,BorderLayout.NORTH);
        frame.add(vbox);
        
        frame.pack();
        frame.setBounds(100,100,500,300);
        frame.setVisible(true);

    &#125;&#125;
</code></pre>
<p><em><strong>Box中，提供了4个方便的静态方法来生成间隔组件</strong></em></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>static Component createHorizontalGlue()</td>
<td>创建一条水平Glue(可在两个方向上同时拉伸的间距)</td>
</tr>
<tr>
<td>static Component createVerticalGlue()</td>
<td>创建一条垂直Glue(可在两个方向上同时拉伸的间距)</td>
</tr>
<tr>
<td>static Component createHorizontalStrut(int width)</td>
<td>创建一条指定宽度(宽度固定了，不能拉伸)的水平Strut(可在垂直方向上拉伸的间距)</td>
</tr>
<tr>
<td>static Component createVerticalStrut(int height)</td>
<td>创建一条指定高度(高度固定了，不能拉伸)的水平Strut(可在水平方向上拉伸的间距)</td>
</tr>
</tbody></table>
<p><img src="/images/swing/box2.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionListener;
public class Test &#123;
    public static void main(String[] args) &#123;
        //创建窗口对象
        Frame frame = new Frame(&quot;测试BoxLayout&quot;);

        //创建水平排列的Box容器 hBox
        Box hBox = Box.createHorizontalBox();
        //往hBox容器中添加按钮，还需要在多个按钮之间添加分割
        hBox.add(new Button(&quot;水平按钮一&quot;));
        hBox.add(Box.createHorizontalGlue());//该分割在两个方向上均可拉伸
        hBox.add(new Button(&quot;水平按钮二&quot;));
        hBox.add(Box.createHorizontalStrut(30));
        hBox.add(new Button(&quot;水平按钮三&quot;));
        //创建水平排列的Box容器 vBox
        Box vBox = Box.createVerticalBox();
        //往vBox容器中添加按钮，还需要在多个按钮之间添加分割
        vBox.add(new Button(&quot;垂直按钮一&quot;));
        vBox.add(Box.createVerticalGlue());//可在两个方向上拉伸
        vBox.add(new Button(&quot;垂直按钮二&quot;));
        vBox.add(Box.createVerticalStrut(30));
        vBox.add(new Button(&quot;垂直按钮三&quot;));
        //把Box容器添加到frame中
        frame.add(hBox,BorderLayout.NORTH);
        frame.add(vBox);

        frame.pack();
        frame.setBounds(100,100,500,300);
        frame.setVisible(true);

    &#125;
&#125;
</code></pre>
<h2 id="三、-AWT中常用组件"><a href="#三、-AWT中常用组件" class="headerlink" title="三、 AWT中常用组件"></a>三、 AWT中常用组件</h2><h3 id="3-1-基本组件"><a href="#3-1-基本组件" class="headerlink" title="3.1 基本组件"></a>3.1 基本组件</h3><table>
<thead>
<tr>
<th>组件名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Button</td>
<td>按钮</td>
</tr>
<tr>
<td>Canvas</td>
<td>用于绘图的画布</td>
</tr>
<tr>
<td>Checkbox</td>
<td>复选框组件(也可以当单选框组件使用)</td>
</tr>
<tr>
<td>CheckboxGroup</td>
<td>用于将多个Checkbox组合成一组，一组Checkbox组件只有一个可以被选中，即可全部变成单选框组件</td>
</tr>
<tr>
<td>Choice</td>
<td>下拉选择框</td>
</tr>
<tr>
<td>Frame</td>
<td>窗口，在GUI程序里通过该类创建窗口</td>
</tr>
<tr>
<td>Label</td>
<td>标签类，用于放置提示性文本</td>
</tr>
<tr>
<td>List</td>
<td>列表框组件，可以添加多项条目</td>
</tr>
<tr>
<td>Panel</td>
<td>不能单独存在基本容器类，必须放到其他容器中</td>
</tr>
<tr>
<td>Scrollbar</td>
<td>滑动条组件，如果需要用户输入某个范围的值，就可以使用滑动条组件，比如调色板中设置RGB三个值所用的滑动条。当创建一个滑动条时，必须指定他的方向、初始值、滑块的大小、最小值和最大值。</td>
</tr>
<tr>
<td>ScrollPane</td>
<td>带水平及垂直滚动条的容器组件</td>
</tr>
<tr>
<td>TextArea</td>
<td>多行文本域</td>
</tr>
<tr>
<td>TextField</td>
<td>单行文本框</td>
</tr>
</tbody></table>
<p><img src="/images/swing/%E6%95%B4%E4%BD%93%E6%B5%8B%E8%AF%951.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionListener;
public class Test &#123;
    Frame frame = new Frame(&quot;测试基本组件&quot;);
    TextArea ta = new TextArea(5, 20);
    Choice colorChooseer = new Choice();
    CheckboxGroup cbg = new CheckboxGroup();
    Checkbox malc = new Checkbox(&quot;男&quot;,cbg,true);
    Checkbox female = new Checkbox(&quot;女&quot;,cbg,false);
    Checkbox isMarried = new Checkbox(&quot;是否已婚&quot;);
    TextField text = new TextField(20);
    Button ok = new Button(&quot;确认&quot;);
    List colorList = new List(6,true);

    public void inti()&#123;
        //组装界面

        //组装底部
        Box bBox = Box.createHorizontalBox();
        bBox.add(text);
        bBox.add(ok);
        frame.add(bBox,BorderLayout.SOUTH);

        //组装选择部分
        colorChooseer.add(&quot;红色&quot;);
        colorChooseer.add(&quot;蓝色&quot;);
        colorChooseer.add(&quot;绿色&quot;);
        Box cBox = Box.createHorizontalBox();
        cBox.add(colorChooseer);
        cBox.add(malc);
        cBox.add(female);
        cBox.add(isMarried);
        //组装文本域和选择部分
        Box tBox = Box.createVerticalBox();
        tBox.add(ta);
        tBox.add(cBox);
        //组装顶部左边和列表框
        colorList.add(&quot;红色&quot;);
        colorList.add(&quot;绿色&quot;);
        colorList.add(&quot;蓝色&quot;);
        Box top = Box.createHorizontalBox();
        top.add(tBox);
        top.add(colorList);
        frame.add(top);

        //设置frame为最佳大小并且可见
        frame.pack();
        frame.setVisible(true);

    &#125;
    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h3 id="3-2-对话框Dialog"><a href="#3-2-对话框Dialog" class="headerlink" title="3.2 对话框Dialog"></a>3.2 对话框Dialog</h3><h4 id="3-2-1-Dialog"><a href="#3-2-1-Dialog" class="headerlink" title="3.2.1 Dialog"></a>3.2.1 Dialog</h4><p><em><strong>Dialog是Window类的子类,是一个容器类,属于特殊组件。对话框是可以独立存在的顶级窗口，因此用法与<br>普通窗口的用法肌乎完全一样,但是使用对话框需要注意下面两点:</strong></em></p>
<ul>
<li>对话框通常依赖于其他窗口,就是通常需要有一个父窗口;</li>
<li>对话框有非模式(non-modal)和模式(modal)两种,当某个模式对话框被打开后,该模式对话框总是位于它的<br>父窗口之上,在模式对话框被关闭之前,父窗口无法获得焦点。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>Dialg(frame owner,String title,boolean modal)</td>
<td>创建一个对话框最想<br>owner：当前对话框的父窗口<br>title:当前对话框的标题<br>modal：当前对话框是否是默认对话框，true/false</td>
</tr>
</tbody></table>
<p><img src="/images/swing/%E5%AF%B9%E8%AF%9D%E6%A1%86.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionListener;
public class Test &#123;
    public static void main(String[] args) &#123;
        Frame frame = new Frame(&quot;测试Dialog&quot;);
        //创建两个对话框，一个模式的，一个非模式的
        Dialog d1 = new Dialog(frame,&quot;模式对话框&quot;,true);
        Dialog d2 = new Dialog(frame,&quot;非模式对话框&quot;,false);
        //通过setBounds方法设置Dialod的位置和大小
        d1.setBounds(20,30,200,300);
        d2.setBounds(20,30,200,300);
        //创建两个按钮
        Button b1 = new Button(&quot;打开模式对话框&quot;);
        Button b2 = new Button(&quot;打开非模式对话框&quot;);
        //给这两个按钮添加点击后的行为
        b1.addActionListener(e -&gt; d1.setVisible(true));
        b2.addActionListener(e -&gt; d2.setVisible(true));
        //把按钮添加到frame中
        frame.add(b1,BorderLayout.NORTH);
        frame.add(b2);

        frame.setVisible(true);
        frame.pack();

    &#125;
&#125;
</code></pre>
<h4 id="3-2-2-FileDialog"><a href="#3-2-2-FileDialog" class="headerlink" title="3.2.2 FileDialog"></a>3.2.2 FileDialog</h4><p>Dialog类还有一个子类: FileDialog , 它代表一个文件对话框 ,用于打开或者保存文件需要注意的是FileDialog<br>无法指定模态或者非模态,这是因为FileDialog依赖于运行平台的实现,如果运行平台的文件对话框是模态的,<br>那么FileDialog也是模态的;否则就是非模态的。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>FileDialog(Frame parent,String title,int mode)</td>
<td>创建一个文件对话框<br>parent:指定父窗口<br>title：对话框标题<br>mode：文件对话框类型，如果指定为FileDialog.LOAD，用于打开文件，如果指定为FileDialog.SAVE，用于保存文件</td>
</tr>
<tr>
<td>String getDirectory()</td>
<td>获取被打开或保存文件的绝对路径</td>
</tr>
<tr>
<td>String getFile()</td>
<td>获取被打开或保存文件的文件名</td>
</tr>
</tbody></table>
<p><img src="/images/swing/%E6%96%87%E4%BB%B6%E5%AF%B9%E8%AF%9D%E6%A1%86.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionListener;
public class Test &#123;
    public static void main(String[] args) &#123;
        Frame frame = new Frame(&quot;测试Dialog&quot;);
        //创建两个FileDialog对象
        FileDialog f1 = new FileDialog(frame,&quot;选择要打开的文件&quot;,FileDialog.LOAD);
        FileDialog f2 = new FileDialog(frame,&quot;选择要保存的文件&quot;,FileDialog.SAVE);
        //创建两个按钮
        Button b1 = new Button(&quot;打开文件&quot;);
        Button b2 = new Button(&quot;保存文件&quot;);
        //给这两个按钮设置点击后的行为，获取打开或保存文件名
        b1.addActionListener(e -&gt; &#123;
            f1.setVisible(true);
            String directory = f1.getDirectory();
            String file  = f1.getFile();
            System.out.println(&quot;打开的路径为&quot;+directory);
            System.out.println(&quot;打开的文件名为&quot;+file);
        &#125;);
        b2.addActionListener(e -&gt; &#123;
            f2.setVisible(true);
            String directory = f2.getDirectory();
            String file  = f2.getFile();
            System.out.println(&quot;保存的路径为&quot;+directory);
            System.out.println(&quot;保存的文件名为&quot;+file);
        &#125;);
        //把这两个按钮添加到Frame中
        frame.add(b1,BorderLayout.NORTH);
        frame.add(b2);

        frame.setVisible(true);
        frame.pack();

    &#125;
&#125;
</code></pre>
<h2 id="四、-事件处理"><a href="#四、-事件处理" class="headerlink" title="四、 事件处理"></a>四、 事件处理</h2><h3 id="4-1-GUI事件处理机制"><a href="#4-1-GUI事件处理机制" class="headerlink" title="4.1 GUI事件处理机制"></a>4.1 GUI事件处理机制</h3><p><strong>定义:</strong><br>        当在某个组件发生某些操作的时候,自动的触发一段代码的执行。<br>在GUl事件处理机制中涉及到4个重要的概念需要理解:<br>**事件源(Event Source) **:操作发生的场所,通常指某个组件,例如按钮、口等;<br><strong>事件( Event) :</strong> 在事件源上发生的操作可以叫做事件, GUI会把事件都封装到一个Event对象中,如果需要知道<br>该事件的详细信息,就可以通过Event对象来获取。<br>**事件监听器(Event Listener):**当在某个事件源上发生了某个事件,事件监听器就可以对这个事件进行处理。<br><strong>注册监听:</strong>    把某个事件监听器(A)通过某个事件(B)绑定到某个事件源(C)上,当在事件源C.上发生了事件B之后,那么<br>事件监听器A的代码就会自动执行。</p>
<pre><code class="mermaid">graph LR
A(外部动作)==在事件源上执行了事件==&gt;B([事件源])
B ==生成事件对象==&gt; C([事件])
C ==自动执行事件监听器中的代码,并且传递事件对象==&gt;D([事件监听器])
D ==将事件监听器通过事件注册到事件源上==&gt; B
</code></pre>
<p><strong>使用步骤：</strong></p>
<ol>
<li>创建事件源组对象；</li>
<li>自定义类，实现XxxListener接口，重写方法</li>
<li>创建事件监听器对象(自定义类对象)</li>
<li>调用事件源组对象的XxxListener方法完成注册监听</li>
</ol>
<p><strong>案例</strong><br>$$<br>点击确认按钮，在单行文本框内显示helloworld<br>$$<br> <img src="/images/swing/%E6%B5%8B%E8%AF%95%E6%8C%89%E9%92%AE.png"></p>
<pre><code class="java">import java.awt.*;
public class Test &#123;
    public static void main(String[] args) &#123;
        Frame frame = new Frame(&quot;测试事件处理&quot;);
        TextField text = new TextField(30);
        Button ok = new Button(&quot;确定&quot;);
        //组装视图
        ok.addActionListener(e -&gt; text.setText(&quot;hello world&quot;));
        frame.add(text,BorderLayout.NORTH);
        frame.add(ok);

        frame.setVisible(true);
        frame.pack();

    &#125;
&#125;
</code></pre>
<h3 id="4-2-GUI中常见事件和时间监听器"><a href="#4-2-GUI中常见事件和时间监听器" class="headerlink" title="4.2 GUI中常见事件和时间监听器"></a>4.2 GUI中常见事件和时间监听器</h3><p>事件监听器必须实现事件监听器接口，AWT提供了大量的事件监听器接口用于实现不同类型的事件监听器,于<br>监听不同类型的事件。AWT 中提供了丰富的事件类,于封装不同组件上所发生的特定操作，AWT的事件类都<br>是AWTEvent类的子类，AWTEvent是 EventObject的子类。</p>
<h4 id="4-2-1-事件"><a href="#4-2-1-事件" class="headerlink" title="4.2.1 事件"></a>4.2.1 事件</h4><ul>
<li><p>AWT把事件分了两大类</p>
</li>
<li><ol>
<li><p>低级事件:这类事件是基于某个特定动作的事件。比如进入、击、拖放等动作的鼠标事件,再比如得到焦<br>和失点等焦点事件。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>ComponentEvent</td>
<td>组件事件，当组件尺寸发生变化、位置发生移动、显示/隐藏状态发生改变时触发该事件。</td>
</tr>
<tr>
<td>ContainerEvent</td>
<td>容器事件，当容器里发生添加组件、 删除组件时触发该事件。</td>
</tr>
<tr>
<td>WindowEvent</td>
<td>窗口事件，当窗口状态发生改变(如打开、关闭、最大化、最小化)时触发该事件。</td>
</tr>
<tr>
<td>FocusEvent</td>
<td>焦点事件，当组件得到焦点或失去焦点时触发该事件。</td>
</tr>
<tr>
<td>KeyEvent</td>
<td>键盘事件，当按键被按下、 松开、单击时触发该事件。</td>
</tr>
<tr>
<td>MouseEvent</td>
<td>鼠标事件,当进行单击、按下、松开、移动鼠标等动作时触发该事件。</td>
</tr>
<tr>
<td>PaintEvent</td>
<td>组件绘制事件，该事件是一个特殊的事件类型 ，当GUI组件调用update/paint方法来埕现自身时触发该事件,该事件并非专用于事件处理模型。</td>
</tr>
</tbody></table>
</li>
<li><p>高级事件：这类事件并不会基于某个特定动作，而且根据功能含义定义的事件。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>ActionEvent</td>
<td>动作事件，当按钮、 菜单项被单击,在TextField中按Enter键时触发</td>
</tr>
<tr>
<td>AjustmentEvent</td>
<td>调节事件,在滑动条上移动滑块以调节数值时触发该事件。</td>
</tr>
<tr>
<td>ItemEvent</td>
<td>选项事件,当用户选中某项，或取消选中某项时触发该事件</td>
</tr>
<tr>
<td>TextEvent</td>
<td>文本事件，当文本框、文本域里的文本发生改变时触发该事件。</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ul>
<h3 id="4-3事件监听器"><a href="#4-3事件监听器" class="headerlink" title="4.3事件监听器"></a>4.3事件监听器</h3><p>不同的事件需要使用不同的监听器监听,不同的监听器需要实现不同的监听器接口，当指定事件发生后，事件监<br>听器就会调用所包含的事件处理器(实例方法)来处理事件。</p>
<table>
<thead>
<tr>
<th>事件类别</th>
<th>描述信息</th>
<th>监听器接口名</th>
</tr>
</thead>
<tbody><tr>
<td>ActionEvent</td>
<td>激活组件</td>
<td>ActionListener</td>
</tr>
<tr>
<td>ItemEvent</td>
<td>选择了某些项目</td>
<td>ItemListener</td>
</tr>
<tr>
<td>MouseEvent</td>
<td>鼠标移动</td>
<td>MouseMotionListener</td>
</tr>
<tr>
<td>MouseEvent</td>
<td>鼠标点击等</td>
<td>MJseListener</td>
</tr>
<tr>
<td>KeyEvent</td>
<td>键盘输入</td>
<td>KeyListener</td>
</tr>
<tr>
<td>FocusEvent</td>
<td>组件收到或失去焦点</td>
<td>FocusListener</td>
</tr>
<tr>
<td>AdjustmentEvent</td>
<td>移动了滚动条等组件</td>
<td>AdjustmentListener</td>
</tr>
<tr>
<td>ComponentEvent</td>
<td>对象移动缩放显示隐藏等</td>
<td>ComponentListener</td>
</tr>
<tr>
<td>WindowEvent</td>
<td>窗口收到窗口级事件</td>
<td>WindowListener</td>
</tr>
<tr>
<td>WindowEvent</td>
<td>容器中增加删除了组件</td>
<td>ContainerListener</td>
</tr>
<tr>
<td>TextEvent</td>
<td>文本字段或文本区发生改变</td>
<td>TextListener</td>
</tr>
</tbody></table>
<h3 id="4-4案例"><a href="#4-4案例" class="headerlink" title="4.4案例"></a>4.4案例</h3><p>通过ContainerListener监听Frame容器添加组件;<br>通过TextListener监听TextFiled内容变化;<br>通过ItemListener监听Choice邻目选中状态变化;</p>
<p><img src="/images/swing/%E7%9B%91%E5%90%AC%E5%99%A8.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ContainerEvent;
import java.awt.event.ContainerListener;
public class Test &#123;
    public static void main(String[] args) &#123;
        Frame frame = new Frame(&quot;测试事件处理&quot;);
        TextField tf = new TextField(30);
        Choice name = new Choice();
        name.add(&quot;张三&quot;);
        name.add(&quot;李四&quot;);
        name.add(&quot;王二&quot;);
        //给文本域添加TextListener，监听内容变化
        tf.addActionListener(e -&gt; System.out.println(&quot;当前文本框的内容为&quot;+tf.getText()));
        //给下拉选择框添加ItemListener，监听条目选项的变化
        name.addItemListener(e -&gt; System.out.println(&quot;选择的是&quot;+e.getItem()));
        //给frame注册ContainerListener监听器，监听容器中组件的添加
        frame.addContainerListener(new ContainerListener() &#123;
            @Override
            public void componentAdded(ContainerEvent e) &#123;
                System.out.println(&quot;当前frame中添加了&quot;+e.getChild());
            &#125;

            @Override
            public void componentRemoved(ContainerEvent e) &#123;

            &#125;
        &#125;);

        Box box = Box.createHorizontalBox();
        box.add(name);
        box.add(tf);
        frame.add(box);
        frame.setVisible(true);
        frame.pack();

    &#125;
&#125;
</code></pre>
<p>案例2</p>
<p>给frame设置WindowListener，监听用户点击X的动作，并关闭窗口</p>
<pre><code class="java">import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class Test &#123;
    public static void main(String[] args) &#123;
        Frame frame = new Frame(&quot;测试窗口&quot;);

        //设置WindowListener,监听用户点击X的动作，如果点击X，则关闭窗口
        frame.addWindowListener(new WindowAdapter() &#123;
            @Override
            public void windowClosing(WindowEvent e) &#123;
                System.exit(0);
            &#125;
        &#125;);
        frame.setVisible(true);
        frame.setBounds(200,200,500,300);

    &#125;
&#125;
</code></pre>
<h2 id="五、-菜单组件"><a href="#五、-菜单组件" class="headerlink" title="五、 菜单组件"></a>五、 菜单组件</h2><table>
<thead>
<tr>
<th>菜单组件名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>MenuBar</td>
<td>菜单条，菜单的容器。</td>
</tr>
<tr>
<td>Menu</td>
<td>菜单组件，菜单项的容器。它也是Menultem的子类 , 所以可作为菜单项使用</td>
</tr>
<tr>
<td>PopupMenu</td>
<td>上下文菜单组件(右键菜单组件)</td>
</tr>
<tr>
<td>Menultem</td>
<td>菜单项组件。</td>
</tr>
<tr>
<td>CheckboxMenultem</td>
<td>复选框菜单项组件</td>
</tr>
</tbody></table>
<p><strong>下图是常见菜单相关组件集成体系图:</strong></p>
<pre><code class="mermaid">graph BT
A(PopupMenu)==&gt;B(Menu)
C(CheckBoxMenuItem)==&gt;D(MenuItem)
B==&gt;D
B-.-&gt;E(接口:MenuContaniner)
F(MenuBar)==&gt;G(MenuComponent)
D==&gt;G
F-.-&gt;E
</code></pre>
<p><strong>菜单相关组件使用:</strong></p>
<ol>
<li>准备菜单项组件,这些组件可以是Menultem及好类对象</li>
<li>准备菜单组件Menu或者PopupMenu(右击弹出子菜单) ,把第一步中准备好的菜单项组件添加进来;</li>
<li>准备菜单条组件MenuBar ,把第二步中准备好的菜 单组件Menu添加进来;</li>
<li>把第三步中准备好的菜单条组件添加到窗口对象中显示。</li>
</ol>
<p><strong>小技巧:</strong></p>
<ol>
<li>如果要在某个菜单的菜单项之间添加分割线,那么只需要调用Menu的add ( new Menultem(“-“) )即可。</li>
<li>如果要给某个菜单项关联快捷键功能,那么只需要在创建菜单项对象时设置即可,例如给菜 单项关联ctrl+shift+Q快捷键,只需要: new Menultem(“菜单项名字”,new MenuShortcut(KeyEvent.VK Q,true);</li>
</ol>
<p><img src="/images/swing/%E8%8F%9C%E5%8D%95.png"></p>
<pre><code class="java">import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class Test &#123;
    public static void main(String[] args) &#123;
        Frame frame = new Frame(&quot;测试菜单&quot;);
        //创建菜单条
        MenuBar menuBar = new MenuBar();
        //创建菜单组件
        Menu fileMenu = new Menu(&quot;文件&quot;);
        Menu editMenu = new Menu(&quot;编辑&quot;);
        Menu formatMenu = new Menu(&quot;格式&quot;);
        //创建菜单项
        MenuItem auto = new MenuItem(&quot;自动换行&quot;);
        MenuItem copy = new MenuItem(&quot;复制&quot;);
        MenuItem paste = new MenuItem(&quot;粘贴&quot;);
        MenuItem comment = new MenuItem(&quot;注释&quot;,new MenuShortcut(KeyEvent.VK_Q,true));
        MenuItem cancelComment = new MenuItem(&quot;取消注释&quot;);
        TextArea ta = new TextArea(6, 40);
        //组装视图
        comment.addActionListener(e -&gt; ta.append(&quot;您点击了&quot;+e.getActionCommand()));
        formatMenu.add(comment);
        formatMenu.add(cancelComment);
        //组装编辑菜单
        editMenu.add(auto);
        editMenu.add(copy);
        editMenu.add(paste);
        editMenu.add(formatMenu);
        //组装MenuBar
        menuBar.add(fileMenu);
        menuBar.add(editMenu);
        //把菜单条放入到frame中
        frame.setMenuBar(menuBar);
        frame.add(ta);

        frame.setVisible(true);
        frame.setBounds(200,200,500,300);

    &#125;
&#125;
</code></pre>
<p>案例 PopMenu</p>
<p><img src="/images/swing/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95.png"></p>
<pre><code class="java">import java.awt.*;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
public class Test &#123;
    public static void main(String[] args) &#123;
        Frame frame = new Frame(&quot;测试菜单&quot;);
        //创建文本域
        TextArea ta = new TextArea(&quot;我爱中华&quot;,6,40);
        //创建panel容器
        Panel p = new Panel();
        //创建popMenu
        PopupMenu popupMenu = new PopupMenu();
        //创建菜单项
        MenuItem comment = new MenuItem(&quot;注释&quot;);
        MenuItem cancelComment = new MenuItem(&quot;取消注释&quot;);
        MenuItem copy = new MenuItem(&quot;复制&quot;);
        MenuItem paste = new MenuItem(&quot;粘贴&quot;);
        //事件监听
        ActionListener listener = e -&gt; ta.append(&quot;\n您点击了&quot;+e.getActionCommand());
        comment.addActionListener(listener);
        cancelComment.addActionListener(listener);
        copy.addActionListener(listener);
        paste.addActionListener(listener);
        //组装视图
        popupMenu.add(comment);
        popupMenu.add(cancelComment);
        popupMenu.add(copy);
        popupMenu.add(paste);
        //PopMenu放入容器
        p.add(popupMenu);
        //设置尺寸
        p.setPreferredSize(new Dimension(400,300));
        //设置右键监听
        p.addMouseListener(new MouseAdapter() &#123;
            @Override
            public void mouseReleased(MouseEvent e) &#123;
                if(e.isPopupTrigger())&#123;
                    //显示popMenu
                    popupMenu.show(p,e.getX(),e.getY());
                &#125;
            &#125;
        &#125;);
        frame.add(ta,BorderLayout.NORTH);
        frame.add(p);

        frame.setVisible(true);
        frame.setBounds(200,200,500,300);

    &#125;
&#125;
</code></pre>
<h2 id="六、-绘图"><a href="#六、-绘图" class="headerlink" title="六、 绘图"></a>六、 绘图</h2><h3 id="6-1-组件绘图原理"><a href="#6-1-组件绘图原理" class="headerlink" title="6.1 组件绘图原理"></a>6.1 组件绘图原理</h3><ul>
<li><p>在AWT中,正提供绘图功能的是Graphics对象,那么Component组件和Graphics对象存在什么关系,能让Component绘制自身图形呢?在Component类中,提供了下列三个方法来完成组件图形的绘制与刷新:</p>
</li>
<li><p>paint(Graphics g):绘制组件的外观;</p>
</li>
<li><p>update(Graphics g):内部调用paint方法，刷新组件外观;</p>
</li>
<li><p>repaint():调用update方法,刷新组件外观;</p>
</li>
</ul>
<p><img src="/images/swing/%E7%BB%98%E5%88%B6.png"></p>
<p><em><strong>一般情况下, update和paint方法是由AWT系统负责调用,如果程序要希望系统重新绘制组件,可以调用repaint方法完成。</strong></em></p>
<h3 id="6-2-Graphics对象的使用"><a href="#6-2-Graphics对象的使用" class="headerlink" title="6.2 Graphics对象的使用"></a>6.2 Graphics对象的使用</h3><p><strong>AWT中提供了Canva类充当画布,提供了Graphics类来充当画笔,通过调用Graphics对象的setColor()方法可以给画笔设置颜色。</strong></p>
<p><strong>画图的步骤</strong></p>
<ol>
<li>自定义类,继承Canvas类,重写paint(Graphics g)方法完成画图;</li>
<li>在paint方法内部,真正开始画图之前调用Graphics对象的setColor()、setFont()等方法设 置画笔的颜色、字体等属性;</li>
<li>调用Graphics画笔的drawXxx()方法开始画图。</li>
</ol>
<p>其实画图的核心就在于使用Graphics画笔在Canvas画布上画出什么颜色、什么样式的图形,所以核心在画笔上,下表中列出了Graphics类中常用的一些方法:</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>setColor(Color c)</td>
<td>设置颜色</td>
</tr>
<tr>
<td>setFont(Font font)</td>
<td>设置字体</td>
</tr>
<tr>
<td>drawLine()</td>
<td>绘制直线</td>
</tr>
<tr>
<td>drawRect()</td>
<td>绘制矩形</td>
</tr>
<tr>
<td>drawRoundRect()</td>
<td>绘制圆角矩形</td>
</tr>
<tr>
<td>drawOval()</td>
<td>绘制椭圆形</td>
</tr>
<tr>
<td>drawPolyon()</td>
<td>绘制多边形</td>
</tr>
<tr>
<td>drawArc()</td>
<td>绘制圆弧</td>
</tr>
<tr>
<td>drawPolyine()</td>
<td>绘制折线</td>
</tr>
<tr>
<td>fillRect()</td>
<td>填充矩形区域</td>
</tr>
<tr>
<td>fillRoundRect()</td>
<td>填充圆角矩形区域</td>
</tr>
<tr>
<td>fillOval()</td>
<td>填充椭圆区域</td>
</tr>
<tr>
<td>fillPolyon()</td>
<td>填充多边形区域</td>
</tr>
<tr>
<td>fillArc()</td>
<td>填充圆弧对应的扇形区域</td>
</tr>
<tr>
<td>drawImage()</td>
<td>绘制位图</td>
</tr>
</tbody></table>
<h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><p><img src="/images/swing/%E7%BB%98%E5%88%B61.png"></p>
<pre><code class="java">import java.awt.*;
public class Test &#123;
    Frame frame = new Frame(&quot;测试绘图&quot;);
    Button rect = new Button(&quot;绘制矩形&quot;);
    Button oval = new Button(&quot;绘制椭圆&quot;);
    //定义一个变量，记录当前要绘制的事椭圆还是矩形
    final String rect_shape= &quot;rect&quot;;
    final String oval_shape = &quot;oval&quot;;

    //自定义类，使用Canvas类，重写paint完成构图
    String shape = &quot;&quot;;
    private class MyCanvas extends Canvas&#123;
        @Override
        public void paint(Graphics g) &#123;
            super.paint(g);
            if(shape.equals(rect_shape))&#123;
                //绘制矩形
                g.setColor(Color.BLACK);
                g.drawRect(100,100,200,100);
            &#125;else if(shape.equals(oval_shape))&#123;
                //绘制椭圆
                g.setColor(Color.red);
                g.drawOval(100,100,200,100);
            &#125;
        &#125;
    &#125;
public void inti()&#123;
    MyCanvas canvas = new MyCanvas();
    //组装视图
    rect.addActionListener(e -&gt; &#123;shape = rect_shape;canvas.repaint();&#125;);
    oval.addActionListener(e -&gt; &#123;shape = oval_shape;canvas.repaint();&#125;);
    //创建panel承载按钮
    Panel p = new Panel();
    p.add(rect);
    p.add(oval);
    frame.add(p,BorderLayout.SOUTH);
    //canvas的大小需要设置
    canvas.setPreferredSize(new Dimension(300,300));
    frame.add(canvas);
    frame.setVisible(true);
    frame.setBounds(200,200,500,300);
&#125;

    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h4 id="案例2-弹球游戏"><a href="#案例2-弹球游戏" class="headerlink" title="案例2 弹球游戏"></a>案例2 弹球游戏</h4><ul>
<li>Java也可用于开发一些动画。 所谓动画,就是间隔一定的时间(通常小于0 .1秒)重新绘制新的图像,两次绘制的图像之间差异较小,肉眼看起来就成了所谓的动画。</li>
<li>为了实现间隔-定的时间就重新调用组件的repaint()方法,可以借助于Swing提供的Timer类, Timer类是一个定时器，它有如下一个构造器:</li>
<li>Timer(int delay, ActionListener listener):每间隔delay秒,系统自动触发ActionListener监听器里的事件处理器方法,在方法内部我们就可以调用组件的repaint方法,完成组件重绘。</li>
</ul>
<p><img src="/images/swing/%E5%BC%B9%E7%90%83%E6%B8%B8%E6%88%8F.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.*;


public class Test &#123;
    Frame frame = new Frame(&quot;弹球游戏&quot;);
    //桌面宽度
    private final int TABLE_WIDTH = 300;
    //桌面高度
    private final int TABLE_HEIGHT = 400;
    //球拍的宽高
    private final int RACKET_WIDTH = 60;
    private final int RACKET_HEIGHT = 20;
    //小球的大小
    private final int BALL_SIZE = 16;
    //定义变量，记录小球坐标
    private int ballX = 120;
    private int ballY = 20;
    //定义变量，记录小球在x和y方向山分别移动的像素
    private int speedX = 2;
    private int speedY = 10;
    //定义变量记录球拍的坐标
    private int racketX = 120;
    private final int racketY = 340;
    //定义变量，表示当前游戏是否结束
    private boolean isOver = false;
    //声明一个定时器
    private Timer timer;
    //自定义一个类继承canvas，充当画布
    private class MyCanvas extends Canvas&#123;
        @Override
        public void paint(Graphics g) &#123;
            super.paint(g);
            if(isOver) &#123;
                //游戏结束
                g.setColor(Color.BLUE);
                g.setFont(new Font(&quot;times&quot;,Font.BOLD,30));
                g.drawString(&quot;游戏结束&quot;,50,200);
            &#125;else &#123;
                //游戏中
                //绘制小球
                g.setColor(Color.RED);
                g.fillOval(ballX,ballY,BALL_SIZE,BALL_SIZE);
                //绘制球拍
                g.setColor(Color.pink);
                g.fillRect(racketX,racketY,RACKET_WIDTH,RACKET_HEIGHT);

            &#125;
        &#125;
    &#125;
    //创建绘画区域
    MyCanvas canvas = new MyCanvas();
public void inti()&#123;
    //组装视图以及游戏逻辑的控制
    //完成球拍坐标的变化
    KeyListener listener = new KeyAdapter() &#123;
        @Override
        public void keyReleased(KeyEvent e) &#123;
            if(e.getKeyCode() == KeyEvent.VK_LEFT)&#123;
                //&lt;- 应该向左移动
                if(racketX &gt; 0)&#123;
                    racketX -= 10;
                &#125;
            &#125;else if(e.getKeyCode() == KeyEvent.VK_RIGHT)&#123;
                //-&gt;应该向右移动
                if(racketX &lt; (TABLE_WIDTH-RACKET_WIDTH))&#123;
                    racketX += 10;
                &#125;
            &#125;
        &#125;
    &#125;;
    ActionListener task = new ActionListener() &#123;
        @Override
        public void actionPerformed(ActionEvent e) &#123;
            //根据边界范围修正速度
            if(ballX&lt;=0||ballX&gt;=TABLE_WIDTH-BALL_SIZE)&#123;
                speedX = -speedX;
            &#125;
            if(ballY&lt;=0||((ballY&gt;=(racketY-BALL_SIZE))&amp;&amp;(ballX&gt;racketX&amp;&amp;ballX&lt;(racketX+RACKET_WIDTH))))&#123;
                speedY = -speedY;
            &#125;
            if((ballY&gt;racketY-BALL_SIZE)&amp;&amp;(ballX&lt;racketX||ballX&gt;racketX+RACKET_WIDTH))&#123;
                //当前小球超出了球拍范围，游戏结束
                //停止计时器
                System.out.println(ballY);
                timer.stop();
                //修改游戏结束标记
                isOver = true;
                //重绘界面
                canvas.repaint();
            &#125;
            //更新小球的坐标
            ballX += speedX;
            ballY +=speedY;
            //重绘界面
            canvas.repaint();
        &#125;
    &#125;;
    //给frame和canvas注册监听器
    frame.addKeyListener(listener);
    canvas.addKeyListener(listener);
    //小球坐标的控制
    timer = new Timer(100,task);
    timer.start();
    canvas.setPreferredSize(new Dimension(TABLE_WIDTH,TABLE_HEIGHT));
    frame.add(canvas);

    frame.setVisible(true);
    frame.setBounds(200,200,300,400);
&#125;

    public static void main(String[] args) &#123;
        new Test().inti();
</code></pre>
<h3 id="6-3-处理位图"><a href="#6-3-处理位图" class="headerlink" title="6.3 处理位图"></a>6.3 处理位图</h3><p><em><strong>位图使用步骤:</strong></em></p>
<ol>
<li>创建Image的子类对象Bufferedlmage(int width,int height,int ImageType),创建时需要指定位图的宽高及类型属性;此时相当于在内存中生成了一张图片;</li>
<li>调用Bufferedlmage对象的getGraphics(方法获取画笔,此时就可以往内存中的这张图片上绘图了,绘图的方法和之前学习的一模一样;</li>
<li>调用组件paint方法中提供的Graphics对象的drawlmage()方法,一次性的内存中的图片 Bufferedlmage绘制到特定的组件上。</li>
</ol>
<ul>
<li>使用位图绘制组件的好处:</li>
<li>使用位图来绘制组件,相当于实现了图的缓冲区,此时绘图时没有直接把图形绘制到组件上,而是先绘制到内存中.的Bufferedlmage上,等全部绘制完毕,再-次性的图像显示到组件上即可,这样用户的体验会好一些。</li>
</ul>
<p><img src="/images/swing/%E6%89%8B%E7%BB%98%E7%A8%8B%E5%BA%8F.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;


public class Test &#123;
    Frame frame = new Frame(&quot;简单手绘程序&quot;);
    //定义画图区的宽高
    private final int AERA_WIDTH = 500;
    private final int AERA_HEIGHT = 400;
    //定义右键菜单，用于设置画笔颜色
    PopupMenu colorMenu = new PopupMenu();
    MenuItem redItem = new MenuItem(&quot;红色&quot;);
    MenuItem greenItem = new MenuItem(&quot;绿色&quot;);
    MenuItem blueItem = new MenuItem(&quot;蓝色&quot;);
    // 定义一个变量记录当前画笔颜色
    Color forceColor = Color.black;
    //创建一个BufferedImage对象
    BufferedImage bufferedImage = new BufferedImage(AERA_WIDTH,AERA_HEIGHT , BufferedImage.TYPE_INT_RGB);
    //通过位图获取关联的Graphics对象
    Graphics  g = bufferedImage.getGraphics();
    //自定义一个类继承canvas
    private class MyCanvas extends Canvas&#123;
        @Override
        public void paint(Graphics g) &#123;
            super.paint(g);
            g.drawImage(bufferedImage,0,0,null);

        &#125;
    &#125;
    MyCanvas canvas = new MyCanvas();
    private int preX = -1;
    private int preY = -1;
    public void inti()&#123;
        ActionListener listener = e -&gt; &#123;
            String action = e.getActionCommand();
            switch (action)&#123;
                case &quot;红色&quot; -&gt; forceColor = Color.RED;
                case &quot;绿色&quot; -&gt; forceColor = Color.GREEN;
                case &quot;蓝色&quot; -&gt; forceColor = Color.BLUE;
            &#125;
        &#125;;
        redItem.addActionListener(listener);
        greenItem.addActionListener(listener);
        blueItem.addActionListener(listener);
        colorMenu.add(redItem);
        colorMenu.add(greenItem);
        colorMenu.add(blueItem);
        //把colorMenu设置给绘图区域
        canvas.add(colorMenu);
        canvas.addMouseListener(new MouseAdapter() &#123;
            @Override
            public void mouseReleased(MouseEvent e) &#123;
                if(e.isPopupTrigger())&#123;
                    colorMenu.show(canvas,e.getX(),e.getY());
                &#125;
                preX = -1;
                preY = -1;
            &#125;
        &#125;);
        //设置位图的背景为白色
        g.setColor(Color.WHITE);
        g.fillRect(0,0,AERA_WIDTH,AERA_HEIGHT);
        //通过监听鼠标绘制
        canvas.addMouseMotionListener(new MouseAdapter() &#123;
            @Override
            public void mouseDragged(MouseEvent e) &#123;
                if (preX&gt;0&amp;&amp;preY&gt;0)&#123;
                    g.setColor(forceColor);
                    g.drawLine(preX,preY,e.getX(),e.getY());
                &#125;
                //修正preX和preY的值
                preX = e.getX();
                preY = e.getY();
                //重绘组件
                canvas.repaint();
            &#125;
        &#125;);
        canvas.setPreferredSize(new Dimension(AERA_WIDTH,AERA_HEIGHT));
        frame.add(canvas);
        frame.pack();
        frame.setVisible(true);

    &#125;
    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h3 id="6-4-ImageIO的使用"><a href="#6-4-ImageIO的使用" class="headerlink" title="6.4 ImageIO的使用"></a>6.4 ImageIO的使用</h3><p>在实际生活中,很多软件都支持打开本地磁盘已经存在的图片,然后进行编辑,编辑完毕后,再重新保存到本地磁<br>盘。如果使用AWT要完成这样的功能,那么需要使用到magelQ这个类,可以操作本地磁盘的图片文件。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>static Bufferedlmage read(File input)</td>
<td>读取本地磁盘图片文件</td>
</tr>
<tr>
<td>static Bufferedlmage read(InputStream input)</td>
<td>读取本地磁盘图片文件</td>
</tr>
<tr>
<td>static boolean write(Renderedlmage im, String formatName, File output)</td>
<td>往本地磁盘中输出图片文件</td>
</tr>
</tbody></table>
<p><img src="/images/swing/%E5%9B%BE%E7%89%87.png"></p>
<pre><code class="java">import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;


public class Test &#123;
    Frame frame = new Frame(&quot;图片查看器&quot;);
    MenuBar bar = new MenuBar();
    Menu menu = new Menu(&quot;文件&quot;);
    MenuItem open = new MenuItem(&quot;打开&quot;);
    MenuItem save = new MenuItem(&quot;另存为&quot;);
    BufferedImage image;
    MyCanvas canvas = new MyCanvas();
    private class MyCanvas extends Canvas&#123;
        @Override
        public void paint(Graphics g) &#123;
            super.paint(g);
            g.drawImage(image,0,0,null);
        &#125;
    &#125;

    public void inti()&#123;
        //组装视图
        open.addActionListener(e -&gt; &#123;
            FileDialog fileDialog = new FileDialog(frame,&quot;打开图片&quot;,FileDialog.LOAD);
            fileDialog.setVisible(true);
            String dir = fileDialog.getDirectory();
            String file = fileDialog.getFile();
            try &#123;
                image = ImageIO.read(new File(dir,file));
                canvas.repaint();
            &#125; catch (IOException ex) &#123;
                ex.printStackTrace();
            &#125;
        &#125;);
        save.addActionListener(e -&gt; &#123;
            FileDialog fileDialog = new FileDialog(frame,&quot;保存图片&quot;,FileDialog.SAVE);
            fileDialog.setVisible(true);
            String dir = fileDialog.getDirectory();
            String file = fileDialog.getFile();
            try &#123;
                ImageIO.write(image,&quot;JPEG&quot;,new File(dir,file));
            &#125; catch (IOException ex) &#123;
                ex.printStackTrace();
            &#125;
        &#125;);
        menu.add(open);
        menu.add(save);
        bar.add(menu);
        frame.setMenuBar(bar);
        frame.add(canvas);


        frame.setBounds(200,200,740,508);
        frame.setVisible(true);
        frame.addWindowListener(new WindowAdapter() &#123;
            @Override
            public void windowClosing(WindowEvent e) &#123;
                System.exit(0);
            &#125;
        &#125;);


        frame.pack();
        frame.setVisible(true);

    &#125;
    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h1 id="Swing编程"><a href="#Swing编程" class="headerlink" title="Swing编程"></a>Swing编程</h1><h2 id="2-1-Swing概述"><a href="#2-1-Swing概述" class="headerlink" title="2.1 Swing概述"></a>2.1 Swing概述</h2><ul>
<li>Swing是由100%纯Java实现的,不再低赖于本地平台的GUI，因此可以在所有平台上都保持相同的界面外观。独立于本地平台的Swing组件被称为轻量级组件;而依赖于本地平台的AWT组件被称为重量级组件。</li>
<li>由于Swing的所有组件完全采用Java实现,不再调用本地平台的GUI ,所以导致Swing形界面的显示速度要比AWT图形界面的显示速度慢一些,但相对于快速发展的硬件设施而言, 这种微小的速度差别无妨大碍。</li>
</ul>
<h3 id="使用Swing的优势"><a href="#使用Swing的优势" class="headerlink" title="使用Swing的优势:"></a>使用Swing的优势:</h3><ol>
<li>Swing组件不再依赖于本地平台的GUI ,无须采用各种平台的GUI交集,因此Swing提供了大量图形界面组件，远远超出 了AWT所提供的图形界面组件集。</li>
<li>Swing组件不再依赖于本地平台GUI , 因此不会产生与平台相关的bug。</li>
<li>Swing组件在各种平台上运行时可以保证具有相同的图形界面外观。Swing提供的这些优势,让Java图形界面程序真正实现了” Write Once, Run Anywhere”的目标。</li>
</ol>
<h3 id="Swing的特征"><a href="#Swing的特征" class="headerlink" title="Swing的特征"></a>Swing的特征</h3><ol>
<li><p>Swing组件采用MVC(ModeI-View-Controller，即模型一视图一 控制器)设计模式:</p>
<pre><code class="text">模型(Model):用于维护组件的各种状态;
视图(View):是组件的可视化表现;
控制器(Controller) :用于控制对于各种事件、组件做出响应。
当模型发生改变时,它会通知所有依赖它的视图，视图会根据模型数据来更新自己。Swing使用UI代理来包装视图和控制器，还有-一个模型对象来维护该组件的状态。例如，按钮JButton有一个维护其状态信息的模型ButtonModel对象。Swing组件的模型是自动设置的 ，因此一般都使用JButton ，而无须关心ButtonModel对象。
</code></pre>
</li>
<li><p>Swing在不同的平台，上表现一致,组有能力提供本地平台不支持的显示外观。于Swing采用MVC模式来维护各组件,所以当组件的外观被改变时,对组件的状态信息(由模型维护)没有任何影响。因此, Swing可以使用插拔式外观感觉(Pluggable Look And Feel, PLAF)来控制组件外观,使得Swing图形界面在同一个平台上运行时能拥有不同的外观,户可以选择自己喜欢的外观。相比之下,在AWT图形界面中,由于控制组件外观的对等类与具体平台相关,因此AWT组件总是具有与本地平台相同的外观。</p>
</li>
</ol>
<h2 id="2-2-Swing基本组件的用法"><a href="#2-2-Swing基本组件的用法" class="headerlink" title="2.2 Swing基本组件的用法"></a>2.2 Swing基本组件的用法</h2><h3 id="2-2-1-Swing组件层次"><a href="#2-2-1-Swing组件层次" class="headerlink" title="2.2.1 Swing组件层次"></a>2.2.1 Swing组件层次</h3><p>大部分Swing组件都是JComponent抽象类的直接或间接子类(并不是全部的Swing组件) , JComponent类定义了所有子类组件的通用方法, JComponent类是AWTjava.awt. Container类的子类，这也是 AWT和Swing的联系之一。绝大部分 Swing组件类继承了Container类,所以Swing组件都可作为容器使用(JFrame继承了Frame类。</p>
<p><strong>Swing组件和AWT组件的对应关系:</strong><br>大部分情况下,只要在AWT组件的名称前面加个,就可以得到其对应的Swing组件名称,有几个例外:</p>
<ol>
<li>JComboBox:对应于AWT里的Choice组件,但毗Choice组件功能更丰富。</li>
<li>JFileChooser:对应于AWT里的FileDialog组件。</li>
<li>JScrollBar:对应于AWT里的Scrollbar组件,注意两个组件类名中b字母的大小写差别。</li>
<li>JCheckBox :对应于AWT里的Checkbox组件，注意两个组件类名中b字母的大小写蹉别。</li>
<li>JCheckBoxMenultem:对应于AWT里的CheckboxMenultem组件,注意两个组件类名中b字母的大小写差别。.</li>
</ol>
<p><strong>Swing组件按照功能来分类:</strong></p>
<ol>
<li>层容器: JFrame、JApplet、 jDialog 和I[Window。</li>
<li>中间容器: JPanel、JScrollPane 、JSplitPane、 JToolBar 等。</li>
<li>特殊容器:在用户界面上具有特殊作用的中间容器,如JIntemalFrame、JRootPane 、JL ayeredPane和JDestopPane等。</li>
<li>基本组件:实现人机交互的组件,如jButton、JComboBox、 JList、 JMenu、 JSlider 等。</li>
<li>不可编辑信息的显示组件:向户显示不可编辑信息的组件,如JLabel、JProgressBar JToolTip等。</li>
<li>可编辑信息的显示组件:向用户显示能被编辑的格式化信息的组件,如JTable、JTextArea 和TextField等</li>
<li>特殊对话框组件:可以直接产生特殊对话框的组件，如JColorChooser和JFileChooser等。</li>
</ol>
<h3 id="2-2-2-AWT组件的Swing实现"><a href="#2-2-2-AWT组件的Swing实现" class="headerlink" title="2.2.2 AWT组件的Swing实现"></a>2.2.2 AWT组件的Swing实现</h3><ul>
<li>Swing为除Canvas之外的所有AWT组件提供了相应的实现, Swing组件比AWT组件的功能更加强大。相对于AWT组件，Swing 组件具有如下4个额外的功能: </li>
<li><ol>
<li>可以为Swing组件设置提示信息。使用setToolTipText()方法,为组件设置对用户有帮助的提示信息。</li>
<li>很多Swing组件如按钮、标签、菜单项等,除使用文字外,还可以使膠标修饰自己。为了允许在Swing组<br>件中使用图标，Swing为Icon接口提供了一个实现类: Imagelcon ,该实现类代表-个图像图标。</li>
<li>支持插拔式的外观风格。每个JComponent对象都有一个相应的ComponentUl对象,为为完成所有的绘画、事件处理、决定尺寸大等工作。ComponentUl 对象依赖当前使用的PLAF，使佣UIManager.setLookAndFeel()方法可以改变图形界面的外观风格。</li>
<li>支持设置边框。Swing 组件可以设置一个或多 个边框。Swing 中提供了各式各样的边框供用户边用,也能建立组合边框或自己设计边框。- 种空白边框可以用于增大组件,同时协助布局管理器对容器中的组件进行合理的布局。每个Swing组件都有一个对应的UI 类,例如JButton组件就有一个对应的 ButtonUl类来作为UI代理。每个Swing组件的UI代理的类名总是将该Swing组件类名的J去掉,然后在后面添加UI后缀。UI代理类通常是一 个抽象基类，不同的PLAF会有不同的UI代理实现类。Swing 类库中包含了几套UI代理,分别放在不同的包下，每套UI代理都几乎包含了所有Swing组件的ComponentUl实现,每套这样的实现都被称为-种PLAF实现。以JButton为例,其UI代理的继承层次下图:</li>
</ol>
</li>
<li>每个Swing组件都有一个对应的UI类,例如JButton组件就有一个对应的ButtonUI类来作为UI代理。每个Swing组件的U代理的类名总是将该Swing组件类名的」去掉,然后在后面添加UI后缀。UI代理类通常是一 个抽象基类，不同的PLAF会有不同的UI代理实现类。Swing 类库中包含了几套UI代理,分别放在不同的包下，套UI代理都几乎包含了所有Swing组件的ComponentU实现,套这样的实现都被称为-种PLAF 实现。以JButton为例,其UI代理的继承层次下图:</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><img src="/images/swing/swing%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class Test &#123;
    JFrame frame = new JFrame(&quot;测试Swing基本组件&quot;);
    //声明菜单相关的组件
    String[] color = &#123;&quot;红色&quot;,&quot;绿色&quot;,&quot;蓝色&quot;&#125;;
    JMenuBar bar = new JMenuBar();
    JMenu fileMenu = new JMenu(&quot;文件&quot;);
    JMenu editMenu = new JMenu(&quot;编辑&quot;);
    JMenuItem auto = new JMenuItem(&quot;自动换行&quot;);
    JMenuItem copy = new JMenuItem(&quot;复制&quot;);
    JMenuItem peast = new JMenuItem(&quot;粘贴&quot;);
    JMenu formatMenu = new JMenu(&quot;格式&quot;);
    JMenuItem comment = new JMenuItem(&quot;注释&quot;);
    JMenuItem cancelComment = new JMenuItem(&quot;取消注释&quot;);
    //声明文本域
    JTextArea ta = new JTextArea(8,20);
    //声明列表框
    JList&lt;String&gt; colorList = new JList&lt;String&gt;(color);
    //声明选择相关组件
    JComboBox&lt;String&gt; colorSelect = new JComboBox&lt;&gt;();
    ButtonGroup bg = new ButtonGroup();
    JRadioButton man = new JRadioButton(&quot;男&quot;,true);
    JRadioButton woman = new JRadioButton(&quot;女&quot;,false);
    JCheckBox isMerried = new JCheckBox(&quot;是否已婚?&quot;,true);
    //声明底部
    JTextField tf = new JTextField(40);
    JButton ok = new JButton(&quot;确定&quot;);

    //声明右键菜单
    JPopupMenu popupMenu = new JPopupMenu();
    ButtonGroup popButton = new ButtonGroup();
    JRadioButtonMenuItem metalItem = new JRadioButtonMenuItem(&quot;Metal 风格&quot;);
    JRadioButtonMenuItem nimbusItem = new JRadioButtonMenuItem(&quot;Nimbus 风格&quot;);
    JRadioButtonMenuItem windowsItem = new JRadioButtonMenuItem(&quot;Windows 风格&quot;,true);
    JRadioButtonMenuItem windowsClassicItem = new JRadioButtonMenuItem(&quot;Windows 经典风格&quot;);
    JRadioButtonMenuItem motifItem = new JRadioButtonMenuItem(&quot;Motif 风格&quot;);
    public void inti()&#123;
        //组装视图
        //组装底部
        JPanel bPanel = new JPanel();
        bPanel.add(tf);
        bPanel.add(ok);
        frame.add(bPanel, BorderLayout.SOUTH);
        //组装选择相关组件
        JPanel sPanel = new JPanel();
        sPanel.add(colorSelect);
        colorSelect.addItem(&quot;红色&quot;);
        colorSelect.addItem(&quot;绿色&quot;);
        colorSelect.addItem(&quot;蓝色&quot;);
        bg.add(man);
        bg.add(woman);
        sPanel.add(man);
        sPanel.add(woman);
        sPanel.add(isMerried);
        //组装文本域和选择相关组件
        Box topLeft = Box.createVerticalBox();
        topLeft.add(ta);
        topLeft.add(sPanel);
        //组装顶部
        Box top = Box.createHorizontalBox();
        top.add(topLeft);
        top.add(colorList);
        frame.add(top);
        //组装顶部菜单
        formatMenu.add(comment);
        formatMenu.add(cancelComment);
        editMenu.add(auto);
        editMenu.addSeparator();
        editMenu.add(copy);
        editMenu.add(peast);
        editMenu.addSeparator();
        editMenu.add(formatMenu);
        bar.add(fileMenu);
        bar.add(editMenu);
        frame.setJMenuBar(bar);
        //组装右键菜单
        ActionListener listener = new ActionListener() &#123;
            @Override
            public void actionPerformed(ActionEvent e) &#123;
                String action = e.getActionCommand();
                try &#123;
                    changeFlavor(action);
                &#125; catch (Exception ex) &#123;
                    ex.printStackTrace();
                &#125;
            &#125;
        &#125;;
        metalItem.addActionListener(listener);
        nimbusItem.addActionListener(listener);
        windowsClassicItem.addActionListener(listener);
        windowsItem.addActionListener(listener);
        motifItem.addActionListener(listener);
        popButton.add(metalItem);
        popButton.add(nimbusItem);
        popButton.add(windowsClassicItem);
        popButton.add(windowsItem);
        popButton.add(motifItem);
        popupMenu.add(metalItem);
        popupMenu.add(nimbusItem);
        popupMenu.add(windowsItem);
        popupMenu.add(windowsClassicItem);
        popupMenu.add(motifItem);

        //不需要在监听鼠标事件
        ta.setComponentPopupMenu(popupMenu);

        frame.pack();
        frame.setVisible(true);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

    &#125;
    //设置风格
    private void changeFlavor(String command) throws Exception &#123;
        switch (command)&#123;
            case &quot;Metal 风格&quot;-&gt; UIManager.setLookAndFeel(&quot;javax.swing.plaf.metal.MetalLookAndFeel&quot;);
            case &quot;Nimbus 风格&quot;-&gt;UIManager.setLookAndFeel(&quot;javax.swing.plaf.nimbus.NimbusLookAndFeel&quot;);
            case &quot;Windows 风格&quot;-&gt;UIManager.setLookAndFeel(&quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot;) ;
            case &quot;Windows 经典风格&quot;-&gt;UIManager.setLookAndFeel(&quot;com.sun.java.swing.plaf.windows.WindowsClassicLookAndFeel&quot;);
            case &quot;Motif 风格&quot;-&gt;UIManager.setLookAndFeel(&quot;com.sun.java.swing.plaf.motif.MotifLookAndFeel&quot;);
        &#125;
        //刷新组件外观
        SwingUtilities.updateComponentTreeUI(frame.getContentPane());
        SwingUtilities.updateComponentTreeUI(bar);
        SwingUtilities.updateComponentTreeUI(popupMenu);
    &#125;

    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;

&#125;
</code></pre>
<h3 id="2-2-3-边框"><a href="#2-2-3-边框" class="headerlink" title="2.2.3 边框"></a>2.2.3 边框</h3><p><img src="/images/swing/%E8%BE%B9%E6%A1%86%E6%A6%82%E8%A7%88.png"></p>
<p><strong>特殊的Border :</strong></p>
<ol>
<li>TitledBorder:它的作用并不是直接为其他组件添加边框,而是为其他边框设置标题,创建该类的对象时,要传入一个其他的Border对象;</li>
<li>CompoundBorder:用来组合其他两个边框,创建该类的对象时,需要传入其他两个Border对象,一个作为内边框,一个作为外边框</li>
</ol>
<p><strong>给组件设置边框步骤:</strong></p>
<ol>
<li>使用BorderFactory或者XxxBorder创建Border的实例对象;</li>
<li>调用Swing组件的setBorder ( Border b )方法为组件设置边框; </li>
</ol>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a><strong>案例</strong></h4><p><img src="/images/swing/%E8%BE%B9%E6%A1%86-164903460214824.png"></p>
<pre><code class="java">import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;

public class Test &#123;
    JFrame frame = new JFrame(&quot;测试边框&quot;);
    public void inti()&#123;
        //组装视图
        //修改frame布局为GridLayout
        frame.setLayout(new GridLayout(2,4));
        //往网格中填充不同的组件并设置边框和内容
        Border beverBorder = BorderFactory.createBevelBorder(BevelBorder.RAISED,Color.RED,Color.GREEN,Color.BLUE,Color.GRAY);
        frame.add(getJpanelWithBorder(beverBorder,&quot;BeverBorder&quot;));
        Border lineBorder = BorderFactory.createLineBorder(Color.ORANGE,10);
        frame.add(getJpanelWithBorder(lineBorder,&quot;LineBorder&quot;));
        Border emptyBorder = BorderFactory.createEmptyBorder(10,5,10,10);
        frame.add(getJpanelWithBorder(emptyBorder,&quot;EmptyBorder&quot;));
        Border etcheBorder = BorderFactory.createEtchedBorder(EtchedBorder.RAISED,Color.RED,Color.GREEN);
        frame.add(getJpanelWithBorder(etcheBorder,&quot;EtcheBorder&quot;));
        TitledBorder titledBorder = new TitledBorder(new LineBorder(Color.ORANGE,10),&quot;这是标题&quot;,TitledBorder.LEFT,TitledBorder.BOTTOM,new Font(&quot;StSon&quot;,Font.BOLD,18),Color.GREEN);
        frame.add(getJpanelWithBorder(titledBorder,&quot;TitledBorder&quot;));
        MatteBorder matteBorder = new MatteBorder(10,5 ,20, 10, Color.GREEN);
        frame.add(getJpanelWithBorder(matteBorder,&quot;MatteBorder&quot;));
        CompoundBorder compoundBorder = new CompoundBorder(new LineBorder(Color.RED,10),titledBorder);
        frame.add(getJpanelWithBorder(compoundBorder,&quot;CompoundBorder&quot;));
        //设置窗口最佳大小并且可见，处理关闭操作
        frame.pack();
        frame.setVisible(true);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    &#125;
    public JPanel getJpanelWithBorder(Border border,String content)&#123;
        JPanel panel = new JPanel();
        panel.add(new JLabel(content));
        //设置边框
        panel.setBorder(border);
        return panel;
    &#125;

    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;

&#125;
</code></pre>
<h3 id="2-2-4-使用JToolBar添加工具条"><a href="#2-2-4-使用JToolBar添加工具条" class="headerlink" title="2.2.4 使用JToolBar添加工具条"></a>2.2.4 使用JToolBar添加工具条</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>JToolBar( String name , int  orientation)</td>
<td>创建-个名字为name ,方向为orientation的工条对象,其orientation的是取值可以是SwingConstants.HORIZONTAL或SwingConstants.VERTICAL</td>
</tr>
<tr>
<td>JButton add(Action a)</td>
<td>通过Action对象为JToolBar工具条添加对应的工具按钮</td>
</tr>
<tr>
<td>addSeparator(Dimension size )</td>
<td>向工具条中添加指定大小的分隔符</td>
</tr>
<tr>
<td>setFloatable(boolean b )</td>
<td>设定工具条是否可以被拖动</td>
</tr>
<tr>
<td>setMargin(Insets m)</td>
<td>设置工具条与工具按钮的边距</td>
</tr>
<tr>
<td>setOrientation( int o)</td>
<td>设置工具条的方向</td>
</tr>
</tbody></table>
<p><strong>add(Action a)方法:</strong></p>
<ul>
<li>上述API中add(Action a)这个方法比较难理解,为什么呢,之前说过, Action接口是ActlonListener的一个子接口,那么它就代表-个事件监听器,而这里add方法是在给I具条添加一个工具按钮,为什么传递的是一个事件监听器呢?</li>
<li>首先要明确的是不管是菜单条中的菜单项还是工具条中的工具按钮,最终肯定是需要点击来完成一些操作 ,所以ToolBar以及JMenu都提供了更加便捷的添加子组件的方法add(Action a)，在这个方法的内部会做如下几件事:<ol>
<li>创建一个 适用于该容器的组件(例如,在工具栏中创建一个工 具按钮);</li>
<li>从Action对象中获得对应的属性来设置该组件(通过lcon来设置按钮图标) ;</li>
<li>把Action监听器注册到刚才创建的组件上;</li>
</ol>
</li>
</ul>
<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><p><img src="/images/swing/%E5%B7%A5%E5%85%B7%E6%9D%A1.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;

public class Test &#123;
    JFrame frame = new JFrame(&quot;测试工具条&quot;);
    JTextArea ta = new JTextArea(6,35);
    JToolBar toolBar = new JToolBar(&quot;播放工具条&quot;,SwingConstants.HORIZONTAL);
    //创建action对象
    Action pre = new AbstractAction(&quot;上一曲&quot;) &#123;
        @Override
        public void actionPerformed(ActionEvent e) &#123;
            ta.append(&quot;上一曲\n&quot;);
        &#125;
    &#125;;
    Action next = new AbstractAction(&quot;下一曲&quot;) &#123;
        @Override
        public void actionPerformed(ActionEvent e) &#123;
            ta.append(&quot;下一曲\n&quot;);
        &#125;
    &#125;;
    Action pause = new AbstractAction(&quot;暂停&quot;) &#123;
        @Override
        public void actionPerformed(ActionEvent e) &#123;
            ta.append(&quot;暂停\n&quot;);
        &#125;
    &#125;;
    public void inti() &#123;
        toolBar.add(pre);
        toolBar.addSeparator();
        toolBar.add(pause);
        toolBar.addSeparator();
        toolBar.add(next);
        //让工具条可以拖动
        toolBar.setFloatable(true);
        //把一个组件设置到jScrollPane中，就可以支持滚动条
        Component table;
        JScrollPane sp = new JScrollPane(ta);
        frame.add(toolBar, BorderLayout.NORTH);
        frame.add(sp);

        frame.pack();
        frame.setVisible(true);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    &#125;

    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;

&#125;
</code></pre>
<h3 id="2-2-5-JColorChooser和JFileChooser"><a href="#2-2-5-JColorChooser和JFileChooser" class="headerlink" title="2.2.5 JColorChooser和JFileChooser"></a>2.2.5 JColorChooser和JFileChooser</h3><p><strong>Swing提供了」ColorChooser和IFileChooser这两种对话框，可以很方便的完成颜色的选择和本地文件的选择。</strong></p>
<h4 id="2-2-5-1-JColorChooser"><a href="#2-2-5-1-JColorChooser" class="headerlink" title="2.2.5.1 JColorChooser"></a>2.2.5.1 JColorChooser</h4><p>JColorChooser盱创建颜色选择器对话框，该类的用法非常简单,只需要调用它的静态方法就可以快速生成一个颜色选择对话框:</p>
<pre><code class="java">public static Color showDialog(Component component,String title,Color intialColor)
/*
    参数：
        component：指定当前对话框父组件
        title：当前对话框名称
        intialColor：指定默认选择的颜色
    返回值：
        返回用户选中的颜色
*/
</code></pre>
<h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><p><img src="/images/swing/%E9%A2%9C%E8%89%B2%E9%80%89%E6%8B%A9%E5%99%A8.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;

public class Test &#123;
    JFrame frame = new JFrame(&quot;测试颜色选择器&quot;);
    JTextArea ta = new JTextArea(6,30);
    //声明按钮
    JButton button = new JButton(new AbstractAction(&quot;改变文本框颜色&quot;) &#123;
        @Override
        public void actionPerformed(ActionEvent e) &#123;
            //弹出一个颜色选择器
            Color result = JColorChooser.showDialog(frame,&quot;颜色选择器&quot;,Color.WHITE);
            //修改文本框背景
            ta.setBackground(result);
        &#125;
    &#125;);
    public void inti() &#123;
        //组装视图
        frame.add(ta);
        frame.add(button,BorderLayout.NORTH);


        frame.pack();
        frame.setVisible(true);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    &#125;

    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;

&#125;
</code></pre>
<h4 id="2-2-5-2-JFileChooser"><a href="#2-2-5-2-JFileChooser" class="headerlink" title="2.2.5.2 JFileChooser"></a>2.2.5.2 JFileChooser</h4><p>FileChooser的功能与AWT中的FileDialog基本相似,也是用于生成”打开文件”、”保存文件”对话框。与.FileDialog不同的是，JFileChooser 无须依赖于本地平台的GUI，它由100%纯Java实现，在所有平台.上具有完全相同的行为,可以在所有平台上具有相同的外观风格。</p>
<p><strong>JFileChooser使用步骤</strong></p>
<ol>
<li><p>创建JFileChooser对象：</p>
<pre><code class="java">JFileChooser chooser= new JFileChooser(&quot;D//a);//指定默认打开的本地磁盘路径
</code></pre>
</li>
<li><p>调用JFileChooser的一系列可选方法,进行初始化</p>
<pre><code class="java">setSelectedFile(File file)/setSelectedFiles(File[] selectedFiles) :设定默认选中的文件
setMultiselectionEnabled(boolean b) :设置是否允许多选，默认是单选
setFileselectionMode(int mode) :设置可以选择内容，例如文件、文件夹等，默认只能选择文件
</code></pre>
</li>
<li><p>打开文件对话框</p>
<pre><code class="java">showopenDi alog( Component parent) :打开文件加载对话框,并指定父组件
showSaveDialog(Component parent) :打开文件保存对话框,并指定父组件
</code></pre>
</li>
<li><p>获取用户选择的结果</p>
<pre><code class="java">File getSelectedFile():获取用户选择的一 一个文件
File[] getSelectedFiles() :获取用户选择的多个文件
</code></pre>
</li>
</ol>
<h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><p><img src="/images/swing/%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9.png"></p>
<pre><code class="java">import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

public class Test &#123;
    JFrame frame = new JFrame(&quot;测试JFileChooser&quot;);
    //创建菜单条
    JMenuBar bar = new JMenuBar();
    JMenu file = new JMenu(&quot;文件&quot;);
    JMenuItem open = new JMenuItem(new AbstractAction(&quot;打开&quot;) &#123;
        @Override
        public void actionPerformed(ActionEvent e) &#123;
            JFileChooser fileChooser = new JFileChooser(&quot;.&quot;);
            fileChooser.showOpenDialog(frame);
            File file = fileChooser.getSelectedFile();
            try &#123;
                image = ImageIO.read(file);
                my.repaint();
            &#125; catch (IOException ex) &#123;
                ex.printStackTrace();
            &#125;
        &#125;
    &#125;);
    JMenuItem save = new JMenuItem(new AbstractAction(&quot;另存为&quot;) &#123;
        @Override
        public void actionPerformed(ActionEvent e) &#123;
            JFileChooser fileChooser = new JFileChooser(&quot;.&quot;);
            fileChooser.showSaveDialog(frame);
            File file = fileChooser.getSelectedFile();
            try &#123;
                ImageIO.write(image,&quot;JPEG&quot;,file);
                my.repaint();
            &#125; catch (IOException ex) &#123;
                ex.printStackTrace();
            &#125;
        &#125;
    &#125;);
    BufferedImage image;
//Swing提供的组件，都是用了图像缓冲区技术
    private class My extends JPanel&#123;
    @Override
    protected void paintComponent(Graphics g) &#123;
        super.paintComponent(g);
        g.drawImage(image,0,0,null);
    &#125;
&#125;
My my = new My();
    public void inti() &#123;
        //组装视图
        file.add(open);
        file.add(save);
        bar.add(file);
        my.setPreferredSize(new Dimension(588,822));
        frame.add(my);
        frame.add(bar,BorderLayout.NORTH);

        frame.pack();
        frame.setBounds(100,100,588,822);
        frame.setVisible(true);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    &#125;

    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h3 id="2-2-6-使用JOptionPane"><a href="#2-2-6-使用JOptionPane" class="headerlink" title="2.2.6 使用JOptionPane"></a>2.2.6 使用JOptionPane</h3><h4 id="2-2-6-1-使用概述"><a href="#2-2-6-1-使用概述" class="headerlink" title="2.2.6.1 使用概述"></a>2.2.6.1 使用概述</h4><p>通过JOptionPane可以非常方便地创建一些简单的对话框 ，Swing 已经为这些对话框添加了相应的组件,无须程席员手动添加组件。lOptionPane 提供了如下4个方法来创建对话框</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>showMessageDialog/showInternalMessageDialog</td>
<td>消息对话框，告知用户某事己发生 ，户只能单击”确定’按钮，类似于JavaScript的alert函数。</td>
</tr>
<tr>
<td>showConfirmDialog/showInternalConfirmDialog</td>
<td>确认对话框,向用户确认某个问题,用户可以选择yes、no - cancel等选项。类似于JavaScript的comfirm函数。该访法返回用户单击了哪个按钮</td>
</tr>
<tr>
<td>showInputDialog/showInternallnputDialog</td>
<td>输入对话框,提示要求输入某些信息,类似于JavaScript的prompt函数。该访法返回用户输入的字符串。</td>
</tr>
<tr>
<td>showOptionDialog/showInternalOptionDialog</td>
<td>自定义选项对话框,允许使用自定义选项，可以取代showConfirmDialog所产生的对话框，只是用起来更复杂。</td>
</tr>
</tbody></table>
<pre><code class="java">showXxxDialog(Component parentComponent ，
        object message ,
        string title,
        int opmionType, 
        int messageType,
            Icon icon,
        object[] opt ions,
        object initialVvalue)
--参数解释:
parentComponent :当前对话框的父组件
message :对话框上显示的信息,信息可以是字符串、组件、图等
title :当前对话框的标题
optionType :当前对话框上显示的按钮类型: DEFAULT_ OPTION、 YES_ _NO_ OPTION、 YES_ _NO_ CANCEL_ OPTION、OK_ CANCEL_ _OPTION
messageType:当前对话框的类型: ERROR_ MESSAGE、 INFORMATION_ MESSAGE、WARNING_ MESSAGE、QUESTION_ MESSAGE、 PLAIN MESSAGE
icon:当前对话框左上角的图标
options:自定义下拉列表的选项
initialvalue :自定义选项中的默认选中项
</code></pre>
<p><strong>当用户与对话框交互结束后 ,不同类型对话框的返回值如下 :</strong></p>
<ul>
<li>showMessageDialog: 无返回值。</li>
<li>showlnputDialog:返回用户输入或选择的字符串。</li>
<li>showConfirmDialog: 返回一个整数代表用户选择的选项。</li>
<li>showOptionDialog :返回一个整数代表用户选择的选项,如果用户选择第一项,则返回0;如果选择第二项,则返回1…依.类推。</li>
</ul>
<p><strong>对showConfirmDialg所产生的对话框,有如下几个返回值:</strong></p>
<ul>
<li>YES OPTION:户单击了”是”按钮后返回。</li>
<li>NO OPTION:用户单击了”否”按钮后返回。</li>
<li>CANCEL OPTION:户单陆了”取消”按钮后返回。</li>
<li>OK OPTION :户陆了”确定”按钮后返回</li>
<li>CLOSED OPTION:用户击了对话框右上角的” X”按钮后返回。</li>
</ul>
<h4 id="2-2-6-2-四中对话框演示"><a href="#2-2-6-2-四中对话框演示" class="headerlink" title="2.2.6.2 四中对话框演示"></a>2.2.6.2 四中对话框演示</h4><h5 id="消息对话框"><a href="#消息对话框" class="headerlink" title="消息对话框"></a>消息对话框</h5><p><img src="/images/swing/%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;

public class Test &#123;
    JFrame frame = new JFrame(&quot;测试消息对话框&quot;);
    JTextArea ta = new JTextArea(6,30);
    //声明按钮
    JButton button = new JButton(new AbstractAction(&quot;弹出消息对话框&quot;) &#123;
        @Override
        public void actionPerformed(ActionEvent e) &#123;
            //弹出一个对话框，并且显示文本域中输入的内容
            String text = ta.getText();
            //参数messageType,指定消息对话框类型
            JOptionPane.showMessageDialog(frame,text,&quot;消息对话框&quot;,JOptionPane.ERROR_MESSAGE);
        &#125;
    &#125;);
    public void inti() &#123;
        //组装视图
        frame.add(ta);
        frame.add(button, BorderLayout.SOUTH);


        frame.pack();
        frame.setVisible(true);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    &#125;

    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h5 id="确认对话框"><a href="#确认对话框" class="headerlink" title="确认对话框"></a>确认对话框</h5><p><img src="/images/swing/%E7%A1%AE%E8%AE%A4%E5%AF%B9%E8%AF%9D%E6%A1%86.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;

public class Test &#123;
    JFrame frame = new JFrame(&quot;测试确认对话框&quot;);
    JTextArea ta = new JTextArea(6,30);
    //声明按钮
    JButton button = new JButton(new AbstractAction(&quot;弹出确认对话框&quot;) &#123;
        @Override
        public void actionPerformed(ActionEvent e) &#123;
            //弹出确认对话框
            String text = ta.getText();
            int result = JOptionPane.showConfirmDialog(frame,text,&quot;确认对话框&quot;,JOptionPane.YES_NO_CANCEL_OPTION);
            if(result == JOptionPane.YES_OPTION)&#123;
                ta.append(&quot;你点击了确定\n&quot;);
            &#125;if (result == JOptionPane.NO_OPTION)&#123;
                ta.append(&quot;你点击了否\n&quot;);
            &#125;if(result == JOptionPane.OK_OPTION)&#123;
                ta.append(&quot;你点击了确认\n&quot;);
            &#125;if(result == JOptionPane.CANCEL_OPTION)&#123;
                ta.append(&quot;你点击了取消\n&quot;);
            &#125;
        &#125;
    &#125;);
    public void inti() &#123;
        //组装视图
        frame.add(ta);
        frame.add(button, BorderLayout.SOUTH);


        frame.pack();
        frame.setVisible(true);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    &#125;

    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h5 id="输入对话框"><a href="#输入对话框" class="headerlink" title="输入对话框"></a>输入对话框</h5><p><img src="/images/swing/%E8%BE%93%E5%85%A5%E5%AF%B9%E8%AF%9D%E6%A1%86.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;

public class Test &#123;
    JFrame frame = new JFrame(&quot;测试输入对话框&quot;);
    JTextArea ta = new JTextArea(6,30);
    //声明按钮
    JButton button = new JButton(new AbstractAction(&quot;弹出输入对话框&quot;) &#123;
        @Override
        public void actionPerformed(ActionEvent e) &#123;
            //弹出确认对话框
            String text = ta.getText();
            String result = JOptionPane.showInputDialog(frame,&quot;输入账号&quot;,&quot;输入对话框&quot;,JOptionPane.INFORMATION_MESSAGE);
            ta.append(result);
        &#125;
    &#125;);
    public void inti() &#123;
        //组装视图
        frame.add(ta);
        frame.add(button, BorderLayout.SOUTH);


        frame.pack();
        frame.setVisible(true);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    &#125;

    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h5 id="选项对话框"><a href="#选项对话框" class="headerlink" title="选项对话框"></a>选项对话框</h5><p><img src="/images/swing/%E9%80%89%E9%A1%B9%E5%AF%B9%E8%AF%9D%E6%A1%86.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;

public class Test &#123;
    JFrame frame = new JFrame(&quot;测试选项对话框&quot;);
    JTextArea ta = new JTextArea(6,30);
    //声明按钮
    JButton button = new JButton(new AbstractAction(&quot;弹出选项对话框&quot;) &#123;
        @Override
        public void actionPerformed(ActionEvent e) &#123;
            //弹出确认对话框
            String[] choice = &#123;&quot;大号&quot;,&quot;中号&quot;,&quot;小号&quot;&#125;;
            int result = JOptionPane.showOptionDialog(frame,&quot;请选择衣服号码&quot;,&quot;选择对话框&quot;,
                    JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE,null,
                    choice,&quot;中号&quot;);
            switch (result)&#123;
                case 0 -&gt; ta.setText(&quot;用户选择了大号&quot;);
                case 1 -&gt; ta.setText(&quot;用户选择了中号&quot;);
                case 2 -&gt; ta.setText(&quot;用户选择了小号&quot;);
            &#125;
        &#125;
    &#125;);
    public void inti() &#123;
        //组装视图
        frame.add(ta);
        frame.add(button, BorderLayout.SOUTH);


        frame.pack();
        frame.setVisible(true);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    &#125;

    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h2 id="2-3-Swing中的特殊容器"><a href="#2-3-Swing中的特殊容器" class="headerlink" title="2.3 Swing中的特殊容器"></a>2.3 Swing中的特殊容器</h2><h3 id="2-3-1-使用JSplitPane"><a href="#2-3-1-使用JSplitPane" class="headerlink" title="2.3.1 使用JSplitPane"></a>2.3.1 使用JSplitPane</h3><p>JSplitPane用于创建一个分割面板,它可以将 一个组件(通常是一个容器)分割成两个部分 ,并提供一个分割条,用户可以拖动该分割条来调整两个部分的大小。</p>
<h4 id="1-创建SplitPane对象"><a href="#1-创建SplitPane对象" class="headerlink" title="1.创建SplitPane对象"></a>1.创建SplitPane对象</h4><pre><code class="java">通过如下构造方法可以创建JSplitPane对象
JSplitpane(int neworientation, Component newLeftComponent , Component     newRightComponent)
    neworientation :指定JSplitPane容器的分割方向:
        如果值为JSplitPane .VERTICAL_ SPLIT,为纵向分割;
        如果值为JSplitPane . HORIZONTAL_ SPLIT ,为横向分割;

    newLeftComponent :左侧或者上侧的组件;
    newRightComponent :右侧或者下侧的组件;
</code></pre>
<h4 id="2-设置是否开启连续布局的支持（可选）"><a href="#2-设置是否开启连续布局的支持（可选）" class="headerlink" title="2.设置是否开启连续布局的支持（可选）"></a>2.设置是否开启连续布局的支持（可选）</h4><pre><code class="java">setContinuouslayout( boolean newContinuouslayout): 
    默认是关闭的，如果设置为true ,则打开连续布局的支持,但由于连续布局支持需要不断的重绘组件，所以效率会低一些
</code></pre>
<h4 id="3-设置是否支持“一触即展”的支持-可选"><a href="#3-设置是否支持“一触即展”的支持-可选" class="headerlink" title="3.设置是否支持“一触即展”的支持(可选)"></a>3.设置是否支持“一触即展”的支持(可选)</h4><pre><code class="java">setoneTouchExpaqdable(boolean newvalue) :
默认是关闭的，如果设置为true ,则打开&quot;一触即展&quot;的支持
</code></pre>
<h4 id="4-其他设置"><a href="#4-其他设置" class="headerlink" title="4.其他设置"></a>4.其他设置</h4><pre><code class="java">setDividerlocation( double proportionallocation): 设置分隔条的位置JSplitPane的某个百分比
setDividerlocation(int ] bcation) :通过像素值设置分隔条的位置
setDividersize(int newSize) :通过像素值设置分隔条的大小
setLeftComponent(Component comp)/ setTopComponent(Component comp)/ setRightComponent (Componentcomp)/ setBottomC omponent(Component comp):设置指定位置的组件
</code></pre>
<h4 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h4><p><img src="/images/swing/SplitPane.png"></p>
<pre><code class="java">import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import java.awt.*;
import java.awt.print.Book;

public class Test &#123;
    JFrame f = new JFrame(&quot;测试JSplitPane&quot;);
    Book[] books = &#123;new Book(&quot;预言家&quot;,new ImageIcon(&quot;D:\\Users\\Administrator\\Desktop\\狼人杀\\狼人杀\\预言家.jpg&quot;),&quot;每晚可查验一名玩家具体身份&quot;),
                    new Book(&quot;训熊师&quot;,new ImageIcon(&quot;D:\\Users\\Administrator\\Desktop\\狼人杀\\狼人杀\\恶灵骑士.jpg&quot;),&quot;可查验两边玩家身份&quot;),
                    new Book(&quot;恶灵骑士&quot;,new ImageIcon(&quot;D:\\Users\\Administrator\\Desktop\\狼人杀\\狼人杀\\训熊师.jpg&quot;),&quot;不会死在夜里，可以反弹&quot;)
    &#125;;
    JList&lt;Book&gt; bookList = new JList&lt;&gt;(books);
    JLabel bookCover = new JLabel();
    JTextArea bookDesc = new JTextArea();
    public void inti()&#123;
        //组装视图
        //设置组件大小
        bookList.setPreferredSize(new Dimension(150,400));
        bookCover.setPreferredSize(new Dimension(220,270));
        bookDesc.setPreferredSize(new Dimension(220,130));

        //为bookList设置选中监听器
        bookList.addListSelectionListener(e -&gt; &#123;
            //获取选中的是哪个条目
            Book book = bookList.getSelectedValue();
            //把书籍的图片用bookCover展示
            bookCover.setIcon(book.getIcon());
            //把书籍的介绍用bookDesc展示
            bookDesc.setText(book.getDesc());
        &#125;);
        //组装左边区域
        JSplitPane left = new JSplitPane(JSplitPane.VERTICAL_SPLIT,bookCover,new JScrollPane(bookDesc));
        left.setOneTouchExpandable(true);
        JSplitPane hole = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,left,bookList);
        //支持连续布局
        hole.setContinuousLayout(true);
        f.add(hole);

        f.setVisible(true);
        f.pack();
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;

    class Book&#123;
        private String name;
        private Icon icon;
        private String desc;

        public Book(String name, Icon icon, String desc) &#123;
            this.name = name;
            this.icon = icon;
            this.desc = desc;
        &#125;

        public String getName() &#123;
            return name;
        &#125;

        public void setName(String name) &#123;
            this.name = name;
        &#125;

        public Icon getIcon() &#123;
            return icon;
        &#125;

        public void setIcon(Icon icon) &#123;
            this.icon = icon;
        &#125;

        public String getDesc() &#123;
            return desc;
        &#125;

        public void setDesc(String desc) &#123;
            this.desc = desc;
        &#125;

        @Override
        public String toString() &#123;
            return name;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h3 id="2-3-2使用JTabbedPane"><a href="#2-3-2使用JTabbedPane" class="headerlink" title="2.3.2使用JTabbedPane"></a>2.3.2使用JTabbedPane</h3><p>JTabbedPane可以很方便地在窗口上放置多个标签页,每个标签页相当于获得了一个与外部容器具有相同大小的组件摆放区域。通过这种方式，就可以在一个容器里放置更多的组件，例如右击桌面 上的”我的电脑”图标,在弹出的快捷菜单里单击”属性”菜单工项，就可以看到一个”系统属性”对话框,这 个对话框里包含了若干个标领。</p>
<ol>
<li><p>创建JTabbedPane对象</p>
<pre><code class="java">JTabbedpane(int tabPlacement, int tabl ayoutPolicy):
    tabPlacement :
        指定标签标题的放置位置,可以选择SwingConstants中的四个常量: TOP、        LEFT、 BOTTOM、 RIGHT
    tablayoutPolicy:
        指定当窗口不能容纳标签页标题时的布局策略，可以选择JT abbedPane .         WRAP_TAB_ _LAYOUT和JTabbedPane. SCROLL_ TAB_ LAYOUT
</code></pre>
</li>
<li><p>通过JTabbedPane对象标签进行增删改查</p>
<pre><code class="java">addTab(String title, Icon icon, Component component, string tip):
添加标签
    title:标签的名称
    icon:标签的图标
    component :标签对应的组件
    tip :光标放到标签上的提示
insertTab(String title, Icon icon, Component component, string tip, int index) :插入标签页
    title :标签的名称
    icon:标签的图标
    component :标签对应的组件
    tip:光标放到标签上的提示
    index :在哪个索引处插入标签页
setComponentAt(int index, Component component) :修改标签页对应的组件
    index:修改哪个索引|处的标签
    component :标签对应的组件
removeTabAt(int index):
    index :删除哪个索弓|处的标签
</code></pre>
</li>
<li><p>设置当前显示的标签页</p>
<pre><code class="java">setselectedIndex(int imdex) :设置哪个索|处的标签被选中
</code></pre>
</li>
<li><p>设置JTabbedPane的其他属性</p>
<pre><code class="java">setDi sabledIconAtint index, Icon disabledIcon): 将指定位置的禁用图标设置为icon ,该图标也可以是
null表示不使用禁用图标。
setEnabledAt(int index, boolean enabled): 设置指定位置的标签页是否启用。
setTitleAt(int index, string title):设置指定位置标签页的标题为title ,该title可以是null,这表明设置
该标签页的标题为空。
setToolTipTextAt(int index, String toolTipText): 设置指定位置标签页的提示文本
</code></pre>
</li>
<li><p>设置监听器</p>
<p><code>addChangeL istener( ChangeL istener 1)</code></p>
</li>
<li><p><strong>案例</strong></p>
<p><img src="/images/swing/tabbledPane.png"></p>
<pre><code class="java">import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import java.awt.*;
import java.awt.print.Book;

public class Test &#123;
    JFrame f = new JFrame(&quot;测试JSplitPane&quot;);
    JTabbedPane tabbedPane = new JTabbedPane(SwingConstants.LEFT,JTabbedPane.SCROLL_TAB_LAYOUT);

    public void inti()&#123;
        //添加标签
        tabbedPane.addTab(&quot;用户管理&quot;,null,new JList&lt;String&gt;(new String[]&#123;&quot;用户一&quot;,&quot;用户二&quot;,&quot;用户三&quot;&#125;));
        tabbedPane.addTab(&quot;商品管理&quot;,null,new JList&lt;String&gt;(new String[]&#123;&quot;商品一&quot;,&quot;商品二&quot;,&quot;商品三&quot;&#125;));
        tabbedPane.addTab(&quot;订单管理&quot;,null,new JList&lt;String&gt;(new String[]&#123;&quot;订单一&quot;,&quot;订单二&quot;,&quot;订单三&quot;,&quot;订单四&quot;&#125;));
        tabbedPane.setEnabledAt(0,false);
        tabbedPane.setSelectedIndex(1);
        //创建监听
        tabbedPane.addChangeListener(e -&gt; &#123;
            int selectedIndex = tabbedPane.getSelectedIndex();
            JOptionPane.showMessageDialog(f,&quot;当前选中了第&quot;+(selectedIndex+1)+&quot;个标签&quot;);
        &#125;);
        f.add(tabbedPane);

        f.setVisible(true);
        f.pack();
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        //居中
        f.setLocationRelativeTo(null);
        f.setSize(400,400);
        //窗口大小不可调节
        f.setResizable(false);
    &#125;


    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h2 id="2-4-进度条"><a href="#2-4-进度条" class="headerlink" title="2.4 进度条"></a>2.4 进度条</h2><p>进度条是图形界面中广泛使用的GUI组件，当复制一 个较大的文件时,操作系统会显示一个进度条,用于标识复制操作完成的比例:当启动Eclipse等程序时，因为需要加载较多的资源， 故而启动速度较慢，程序也会在启动过程中显示一个进度条， 用以表示该软件启动完成的比例 ….. </p>
<h3 id="2-4-1-创建进度条"><a href="#2-4-1-创建进度条" class="headerlink" title="2.4.1 创建进度条"></a>2.4.1 创建进度条</h3><p>使用ProgressBar创建进度条步骤</p>
<ol>
<li><p>创建ProgressBar对象</p>
<pre><code class="java">public JProgressBar(int orient, int min, int max):
    orient :方向
    min:最小值
    max:最大值
</code></pre>
</li>
<li><p>设置属性</p>
<pre><code class="java">setBorderPainted( boolean b) :设置进度条是否有边框
set Indeterminate( boolean newValue) :设置当前进度条是不是进度不确定的进度条,如果是,则将看到一一个滑块在进度条中左右移动
setstringPainted(boolean b) :设置进度条是否显示当前完成的百分比
</code></pre>
</li>
<li><p>获取和设置当前进度条的进度状态</p>
<pre><code class="java">setValue(int n): 设置当前进度值
double getPercentComplete(): 获取进度条的完成百分比
String getstring() :返回进度字符串的当前值
</code></pre>
</li>
<li><p><strong>案例</strong></p>
<p><img src="/images/swing/%E8%BF%9B%E5%BA%A6%E6%9D%A1.png"></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.util.stream.IntStream;

public class Test &#123;
    JFrame f = new JFrame(&quot;测试进度条&quot;);
    JCheckBox c1 = new JCheckBox(&quot;不确定进度&quot;);
    JCheckBox c2 = new JCheckBox(&quot;不绘制边框&quot;);
    JProgressBar bar = new JProgressBar(JProgressBar.HORIZONTAL,0,100);
    public void inti()&#123;
        //处理复选框的点击行为
        c1.addActionListener(e -&gt; bar.setIndeterminate(c1.isSelected()));
        c2.addActionListener(e -&gt; bar.setBorderPainted(!c2.isSelected()));
        Box box = Box.createVerticalBox();
        box.add(c1);
        box.add(c2);
        bar.setStringPainted(true);
        bar.setBorderPainted(true);
        f.setLayout(new FlowLayout());
        f.add(box);
        f.add(bar);
        f.setVisible(true);
        f.pack();
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        //居中
        f.setLocationRelativeTo(null);
        //窗口大小不可调节
        f.setResizable(false);
        for (int i=0;i&lt;=100;i++)&#123;
            bar.setValue(i);
            try &#123;
                Thread.sleep(500);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;


    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p><strong>增加多线程改进后</strong></p>
<pre><code class="java">import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.stream.IntStream;

public class Test &#123;
    JFrame f = new JFrame(&quot;测试进度条&quot;);
    JCheckBox c1 = new JCheckBox(&quot;不确定进度&quot;);
    JCheckBox c2 = new JCheckBox(&quot;不绘制边框&quot;);
    JProgressBar bar = new JProgressBar(JProgressBar.HORIZONTAL,0,100);
    public void inti()&#123;
        //处理复选框的点击行为
        c1.addActionListener(e -&gt; bar.setIndeterminate(c1.isSelected()));
        c2.addActionListener(e -&gt; bar.setBorderPainted(!c2.isSelected()));
        Box box = Box.createVerticalBox();
        box.add(c1);
        box.add(c2);
        bar.setStringPainted(true);
        bar.setBorderPainted(true);
        f.setLayout(new FlowLayout());
        f.add(box);
        f.add(bar);
        f.setVisible(true);
        f.pack();
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        //居中
        f.setLocationRelativeTo(null);
        //窗口大小不可调节
        f.setResizable(false);
        Download download = new Download(bar.getMaximum());
        new Thread(download).start();
        Timer timer = new Timer(200, e -&gt; bar.setValue(download.getCurrent()));
        timer.start();
        //监听进度条的任务变化
        bar.addChangeListener(e -&gt;&#123;
            if (bar.getValue()==download.getCount())&#123;
                timer.stop();
            &#125;
        &#125; );
    &#125;
    private class Download implements Runnable&#123;
        private int count;
        private volatile int current;

        public Download(int count) &#123;
            this.count = count;
        &#125;

        public int getCount() &#123;
            return count;
        &#125;

        public void setCount(int count) &#123;
            this.count = count;
        &#125;

        public int getCurrent() &#123;
            return current;
        &#125;

        public void setCurrent(int current) &#123;
            this.current = current;
        &#125;

        @Override
        public void run() &#123;
            //模拟下载过程
            while (current&lt;count)&#123;
                try &#123;
                    Thread.currentThread().sleep(50);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                current++;
            &#125;
        &#125;
    &#125;


    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h3 id="2-4-2-创建对话进度条"><a href="#2-4-2-创建对话进度条" class="headerlink" title="2.4.2 创建对话进度条"></a>2.4.2 创建对话进度条</h3><pre><code class="java">public HogressMoni tor(Component parentComponent , object message,String note, int min,int max):
    parentComponent :对话框的父组件
    message :对话框的描述信息
    note:进度的提示信息
    min:进度条的最小值
    max:进度条的最大值
</code></pre>
<p><strong>案例</strong></p>
<p><img src="/images/swing/%E5%AF%B9%E8%AF%9D%E8%BF%9B%E5%BA%A6%E6%9D%A1.png"></p>
<pre><code class="java">import javax.swing.*;

public class Test &#123;
    public void inti()&#123;
        //创建进度对话框
        ProgressMonitor monitor = new ProgressMonitor(null,&quot;等待任务完成&quot;,&quot;已完成&quot;,0,100);
        Download download = new Download(100);
        new Thread(download).start();
        Timer timer = new Timer(200,e -&gt; monitor.setProgress(download.getCurrent()));
        //判断用户是否点击了取消按钮
        if (monitor.isCanceled())&#123;
            timer.stop();
            monitor.close();
            System.exit(0);
        &#125;
        timer.start();


    &#125;
    private class Download implements Runnable&#123;
        private int count;
        private volatile int current;

        public Download(int count) &#123;
            this.count = count;
        &#125;

        public int getCount() &#123;
            return count;
        &#125;

        public void setCount(int count) &#123;
            this.count = count;
        &#125;

        public int getCurrent() &#123;
            return current;
        &#125;

        public void setCurrent(int current) &#123;
            this.current = current;
        &#125;

        @Override
        public void run() &#123;
            //模拟下载过程
            while (current&lt;count)&#123;
                try &#123;
                    Thread.currentThread().sleep(50);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                current++;
            &#125;
        &#125;
    &#125;


    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h2 id="2-5-JList、JComboBox实现列表框"><a href="#2-5-JList、JComboBox实现列表框" class="headerlink" title="2.5 JList、JComboBox实现列表框"></a>2.5 JList、JComboBox实现列表框</h2><h3 id="2-5-1-简单列表框"><a href="#2-5-1-简单列表框" class="headerlink" title="2.5.1 简单列表框"></a>2.5.1 简单列表框</h3><ol>
<li><p>创建List或ComboBox对象</p>
<pre><code class="java">JList(final E[] listData) :创建JList对象，把listData数组中的每项内容转换成一个列表项展示
JList(final yector&lt;? extends E&gt; listData) :创建JList对象,把listData数组中的每项内容转换成一个列表项
展示
JComboBox(E[] items):
JComboBox(Vector&lt;E&gt; items):
</code></pre>
</li>
<li><p>设置List或ComboBox的外观行为</p>
<pre><code class="java">-----------------------------JList---------------------------------
addSelectionInterval(int anchor, int lead) :在已经选中列表项的基础上，增加选中从anchor到lead索引范围内的所有列表项
setFixedCellHeight(int height )/setFixedCellwidth(int width) :设置列表项的高度和宽度
setlayoutorientation(int layoutrientation) :设置列表框的布局方向
setSelectedInex(int index) :设置默认选中项
setselectedIndices(int [] indices) :设置默认选中的多个列表项
setSelectedValue(object anObject , boolean shouldScroll) :设置默认选中项,并滚动到该项显示
setselectionBackground(Color selectionBackground) :设置选中项的背景颜色
setSelectionForeground(Color selectionForeground) :设置选中项的前景色
setselectionInterval(int anchor, int lead) :设置从anchor到1 ead范围内的所有列表项被选中
setSelectionMode(int selectionMode) :设置选中模式，默认没有限制，也可以设置为单选或者区域选中
setVisibleRowCount(int visibleRowCount) :设置列表框的可视高度足以显示多少行列表项
---------------------------JComboB0x----------------------------
setEditable(boolean aFlag) :设置是否可以直接修改列表文本框的值,默认为不可以
setMaximumRowCount(int count) : 设置列表框的可视高度足以显示多少行列表项
setSelectedIndex(int anIndex) :设置默认选中项
setSelectedItem(Object anobject) :根据列表项的值,设置默认选中项
</code></pre>
</li>
<li><p>设置监听器，监听列表项的变化，JList通过addListSelection完成，JComboBox通过addItemListener监听</p>
<p><img src="/images/swing/%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8.png"></p>
</li>
</ol>
<pre><code class="java">import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.util.List;

public class Test &#123;
    JFrame frame = new JFrame(&quot;列表测试框&quot;);
    String[] books = &#123;&quot;三国演义&quot;,&quot;红楼梦&quot;,&quot;水浒传&quot;,&quot;西游记&quot;&#125;;
    JPanel layoutPanel = new JPanel();
    ButtonGroup buttonGroup = new ButtonGroup();
    JPanel selectPanel = new JPanel();
    ButtonGroup selectGroup = new ButtonGroup();
    JTextArea favorite = new JTextArea(4,40);
    JList&lt;String&gt; bookList;
    JComboBox&lt;String&gt; bookComboBox;
    public void inti()&#123;
        bookList = new JList&lt;&gt;(books);
        addLayoutButton(&quot;纵向滚动&quot;,JList.VERTICAL);
        addLayoutButton(&quot;纵向换行&quot;,JList.VERTICAL_WRAP);
        addLayoutButton(&quot;横向换行&quot;,JList.HORIZONTAL_WRAP);
        addSelectedModel(&quot;无限制&quot;,ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        addSelectedModel(&quot;单选&quot;,ListSelectionModel.SINGLE_SELECTION);
        addSelectedModel(&quot;多选&quot;,ListSelectionModel.SINGLE_INTERVAL_SELECTION);
        //对Jlist做设置
        bookList.setVisibleRowCount(3);
        bookList.setSelectionInterval(2,4);
        Box bookListBox = Box.createVerticalBox();
        bookListBox.add(new JScrollPane(bookList));
        bookListBox.add(layoutPanel);
        bookListBox.add(selectPanel);
        bookList.addListSelectionListener(e -&gt; &#123;
            List&lt;String&gt; selectedValuesList = bookList.getSelectedValuesList();
            favorite.setText(&quot;&quot;);
            for (String i:selectedValuesList)&#123;
                favorite.append(i);
            &#125;
        &#125;);
        //组装JComboBox
        bookComboBox = new JComboBox&lt;&gt;(books);
        bookComboBox.addItemListener(e -&gt; favorite.setText((String) bookComboBox.getSelectedItem()));
        bookComboBox.setEditable(true);
        bookComboBox.setMaximumRowCount(4);
        Box topBox = Box.createHorizontalBox();
        topBox.add(bookListBox);
        JPanel bookComboBoxPanel = new JPanel();
        bookComboBoxPanel.add(bookComboBox);
        topBox.add(bookComboBoxPanel);
        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.add(new JLabel(&quot;您最喜欢的书&quot;),BorderLayout.NORTH);
        bottomPanel.add(favorite);
        frame.add(topBox);
        frame.add(bottomPanel,BorderLayout.SOUTH);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);


    &#125;
    private void addLayoutButton(String name,int layoutType)&#123;
        layoutPanel.setBorder(new TitledBorder(new EtchedBorder(),&quot;确定选项布局&quot;));
        JRadioButton button = new JRadioButton(name);
        layoutPanel.add(button);
        if (buttonGroup.getButtonCount()==0)&#123;
            button.setSelected(true);
        &#125;
        buttonGroup.add(button);
        button.addActionListener(e -&gt; bookList.setLayoutOrientation(layoutType));

    &#125;
    private void addSelectedModel(String name,int selectedModel)&#123;
        selectPanel.setBorder(new TitledBorder(new EtchedBorder(),&quot;确认选择模式&quot;));
        JRadioButton button = new JRadioButton(name);
        button.addActionListener(e -&gt; bookList.setSelectionMode(selectedModel));
        selectPanel.add(button);
    &#125;



    public static void main(String[] args) &#123;
        new Test().inti();
    &#125;
&#125;
</code></pre>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul>
<li>Swing使用JTree对象来代表一棵树，JTree树中结点可以使用Treepath来标识，该对象封装了当前结点及其所有的父结点。</li>
</ul>
<p>当一个结点具有子结点时，该结点有两种状态：</p>
<ul>
<li>展开状态：当父结点处于展开状态时，其子结点是可见的；</li>
<li>折叠状态：当父结点处于折叠状态时，其子结点都是不可见的</li>
</ul>
<p>按照结点是否包含子结点，可以把结点分为下面两类：</p>
<ul>
<li>普通结点：包含子结点的结点；</li>
<li>叶子结点：没有子结点的结点； </li>
</ul>
<p>JTree常用构造方法：</p>
<pre><code class="java">JTree（TreeModel newModel）：使用指定的数据模型创建JTree对象，它默认显示根结点
JTree（TreeNode root）：使用root作为根节点创建JTree对象，它默认显示根结点。
JTree（TreeNode root，booleanasksAlgowschildren）：使用root作为根结点创建了Tree对象，它默认显示根结点。asksA11owschildren参数控制怎样的结点才算叶子结点，如果该参数为true，则只有当程序使用
setA1lowschildren（false）显式设置某个结点不允许添加子结点时（以后也不会拥有子结点），该结点才会被JTrec
当成叶子结点：如果该参数为false，则只要某个结点当时没有子结点（不管以后是否拥有子结点），该结点都会被JTree当成叶子结点。
</code></pre>
<p><img src="/images/swing/%E6%A0%91.jpg"></p>
<pre><code class="java">import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;

public class Demo &#123;
    JFrame f = new JFrame(&quot;简单树&quot;);
    public void inti()&#123;
        DefaultMutableTreeNode root = new DefaultMutableTreeNode(&quot;中国&quot;);
        DefaultMutableTreeNode gd = new DefaultMutableTreeNode(&quot;广东&quot;);
        DefaultMutableTreeNode gx = new DefaultMutableTreeNode(&quot;广西&quot;);
        DefaultMutableTreeNode fs = new DefaultMutableTreeNode(&quot;佛山&quot;);
        DefaultMutableTreeNode st = new DefaultMutableTreeNode(&quot;汕头&quot;);
        DefaultMutableTreeNode gl = new DefaultMutableTreeNode(&quot;桂林&quot;);
        DefaultMutableTreeNode nl = new DefaultMutableTreeNode(&quot;南宁&quot;);
        root.add(gd);
        root.add(gx);
        gd.add(fs);
        gd.add(st);
        gx.add(gl);
        gx.add(nl);
        //创建JTree对象
        JTree t = new JTree(root);
        f.add(t);
        f.setSize(400,300);
        f.setLocationRelativeTo(null);
        f.setVisible(true);
        f.setResizable(false);
        f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

    &#125;
    public static void main(String[] args) &#123;
        new Demo().inti();
    &#125;
&#125;
</code></pre>
<h3 id="2-其他设置"><a href="#2-其他设置" class="headerlink" title="2.其他设置"></a>2.其他设置</h3><p>外观</p>
<pre><code class="java">tree·putclientProperty(“None”)：设置结点之间没有连接线
tree·putclientproperty(“Tree.linestyle&quot;,“Horizontal”）：设置结点之间只有水平分割线
</code></pre>
<p>其他成员方法</p>
<pre><code class="java">Enumeration breadthFirstEnumerationC）/preorderEnumerationC）：按广度优先的顺序遍历以此结点为根的子树，并返回所有结点组成的枚举对象。
Enumeration depthFirstEnumerationC）/postorderEnumerationO：按深度优先的顺序遍历以此结点为根的子树，并返回所有结点组成的枚举对象
DefaultMutableTreeNodegetMextsibling（）：返回此结点的下一个兄弟结点。
TreeNode getparent（）：返回此结点的父结点。如果此结点没有父结点，则返回nu11
TreeNode[] getPath()：返回从根结点到达此结点的所有结点组成的数组。
DefaultMutableTreeNode getPrevioussibling（）：返回此结点的上一个兄弟结点。
TreeNode getRoot（）：返回包含此结点的树的根结点。
TreeNode getsharedAncestor(DefaultMutableTreeodeallde）：返回此结点和aNode最近的共同祖先。
int getsiblingcount（）：返回此结点的兄弟结点数
boolean isLeaf（）：返回该结点是否是叶子结点
boolean isNodeAncestor（TreeNode anotherNode）：判断anotherNode是否是当前结点的祖先结点（包括父结点）
boolean isNodechild（TreeNode node）：如果Node是此结点的子结点，则返回true。
boolean isNodeDescendant(DefaultMutableTreeuode anotheruode）：如果anotheruode 是此结点的后代，包括是此结点本身、此结点的子结点或此结点的子结点的后代，都将返回true
boolean isModeRelated（DefaultMutableTreeNodeaNode）：当auode和当前结点位于同一棵树中时返回true
boolean isNodesibling（TreeNodeanotherNode）：返回anotherNode是否是当前结点的兄弟结点。
boolean isRoot（）：返回当前结点是否是根结点。
Enumeration pathFromAncestorEnumeration（TreeNode ancestor）：返回从指定祖先结点到当前结点的所有结点组成的枚举对象                       
</code></pre>
<h2 id="2-6表格"><a href="#2-6表格" class="headerlink" title="2.6表格"></a>2.6表格</h2><h3 id="2-6-1使用JTable创建简单表格步骤"><a href="#2-6-1使用JTable创建简单表格步骤" class="headerlink" title="2.6.1使用JTable创建简单表格步骤"></a>2.6.1使用JTable创建简单表格步骤</h3><ol>
<li>创建一个一维数组，存储表格中每一列的标题</li>
<li>创建一个二维数组，存储表格中每一行数据，其中二维数组内部的每个一维数组，代表表格中的一行数据</li>
<li>根据第一步和第二步创建的一维数组和二维数组，创建JTable对缘</li>
<li>把Table添加到其他容器中显示 </li>
</ol>
<p><img src="/images/swing/%E8%A1%A8%E6%A0%BC.jpg"></p>
<pre><code class="java">import javax.swing.*;

public class Demo &#123;
    JFrame f = new JFrame(&quot;简单表格&quot;);
    Object[] titles = &#123;&quot;姓名&quot;,&quot;年龄&quot;,&quot;性别&quot;&#125;;
    Object[][] data = &#123;
            &#123;&quot;李清照&quot;,29,&quot;女&quot;&#125;,
            &#123;&quot;苏格拉底&quot;,56,&quot;男&quot;&#125;,
            &#123;&quot;李白&quot;,35,&quot;男&quot;&#125;,
            &#123;&quot;弄玉&quot;,18,&quot;女&quot;&#125;,
            &#123;&quot;虎头&quot;,2,&quot;男&quot;&#125;
    &#125;;
    public void inti()&#123;
        JTable table = new JTable(data, titles);
        f.add(table);

        f.setSize(400,300);
        f.setLocationRelativeTo(null);
        f.setVisible(true);
        f.setResizable(false);
        f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

    &#125;
    public static void main(String[] args) &#123;
        new Demo().inti();
    &#125;
&#125;
</code></pre>
<h3 id="2-6-2调整表格"><a href="#2-6-2调整表格" class="headerlink" title="2.6.2调整表格"></a>2.6.2调整表格</h3><p>列宽</p>
<ul>
<li>Jable使用Tablecolumn来表示表格中的每一列，Iable中表格列的所有属性，如最佳宽度、是否可调整宽度、最小和最大宽度等都保存在该Tablecolumn中。<ol>
<li>setMaxwidth（intmaxwidth）:设置该列的最大宽度。如果指定的maxwidth小于该列的最小宽度，则maxWidth被设置成最小宽度。</li>
<li>setMinwidth（intminwidth）:设置该列的最小宽度。</li>
<li>setPreferredwidth（intpreferredwidth）:设置该列的最佳宽度。</li>
</ol>
</li>
</ul>
<p>选择模式</p>
<p>与lList类似的是，Iable使用了一个ListSelectionModel表示该表格的选择状态，程序可以通过ListSelectionModel.setselectionMode（intmode）控制Iable的选择模式。Jable的选择模式有如下三种：</p>
<ol>
<li>ListSelectionMode.MULTIPLEINTERVAL_SELECTION:没有任何限制。</li>
<li>ListselectionMode.SINGLE_INTERVAL_SELECTION:选择单个连续区域。</li>
<li>ListSele_SELECTION:只能选择单行。</li>
</ol>
<h3 id="2-6-3TableModel"><a href="#2-6-3TableModel" class="headerlink" title="2.6.3TableModel"></a>2.6.3TableModel</h3><p>自定义TableModel步骤：</p>
<ol>
<li><p>自定义类，继承AbsractTableModel抽象类，重写下面几个方法：</p>
<pre><code class="java">intgetcolumncount（）：返回表格列的数量
intgetRowcount（）：返回表格行的数量
object getvalueAt(int rowIndex,intcolumnIndex）：返回rowIndex行，colum列的单元格的值
String getcolumnName（int columnIndex）：返回columnIndex列的列名称
boolean iscellEditable（int rowIndex，int columnIndex）：设置rowIndex行，columnIndex列单格是否可痛辑
</code></pre>
</li>
<li><p>创建自定义类对象，根据该对象，创建JIable对象</p>
</li>
</ol>
<p><img src="/images/swing/%E8%A1%A8%E9%AB%98%E7%BA%A71.jpg"></p>
<pre><code class="java">import javax.swing.*;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableColumn;
import java.awt.*;
import java.util.*;

public class Demo &#123;
    JFrame f = new JFrame(&quot;简单表格&quot;);
    Object[][] data = &#123;
            &#123;&quot;李清照&quot;,29,&quot;女&quot;&#125;,
            &#123;&quot;苏格拉底&quot;,56,&quot;男&quot;&#125;,
            &#123;&quot;李白&quot;,35,&quot;男&quot;&#125;,
            &#123;&quot;弄玉&quot;,18,&quot;女&quot;&#125;,
            &#123;&quot;虎头&quot;,2,&quot;男&quot;&#125;
    &#125;;
    Vector&lt;Object&gt; title = new Vector&lt;&gt;();
    Vector&lt;Vector&lt;Object&gt;&gt; d = new Vector&lt;&gt;();
    private class MyTableModel extends AbstractTableModel&#123;

        @Override
        public int getRowCount() &#123;
            return d.size();
        &#125;

        @Override
        public int getColumnCount() &#123;
            return title.size();
        &#125;

        @Override
        public Object getValueAt(int rowIndex, int columnIndex) &#123;
            return d.get(rowIndex).get(columnIndex);
        &#125;

        @Override
        public String getColumnName(int column) &#123;
            return (String) title.get(column);
        &#125;
        @Override
        public boolean isCellEditable(int rowIndex, int columIndex)&#123;
            return false;
        &#125;
    &#125;
    public void inti()&#123;
        Collections.addAll(title,&quot;姓名&quot;,&quot;年龄&quot;,&quot;性别&quot;);
        for (Object[] da : data) &#123;
            Vector&lt;Object&gt; v = new Vector&lt;&gt;(Arrays.asList(da));
            d.add(v);
        &#125;
        MyTableModel my = new MyTableModel();
        JTable table = new JTable(my);
        f.add(new JScrollPane(table));
        //设置选择模式
        table.getSelectionModel().setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        //设置列宽
        TableColumn column1 = table.getColumn(title.get(0));
        column1.setMinWidth(40);
        TableColumn column2 = table.getColumn(title.get(1));
        column2.setMaxWidth(50);
        TableColumn column3 = table.getColumn(title.get(2));
        JButton button = new JButton(&quot;确认&quot;);
        button.addActionListener(e-&gt;&#123;
            int colum = table.getSelectedColumn();
            int row = table.getSelectedRow();
            System.out.println(colum+&quot;行&quot;+row+&quot;列&quot;);
            System.out.println(my.getValueAt(row,colum));
        &#125;);
        f.add(button, BorderLayout.SOUTH);

        f.setSize(400,300);
        f.setLocationRelativeTo(null);
        f.setVisible(true);
        f.setResizable(false);
        f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

    &#125;
    public static void main(String[] args) &#123;
        new Demo().inti();
    &#125;
&#125;
</code></pre>
<p>​        不仅用户可以扩展AbstractTableModel抽象类，Swing本身也为AbstractTableModel提供了一个DefaultTableModel实现类，程序可以通过使用DefaultTableModel实现类来创建jTable对象。通过pefaultTableMedel对象创建Jable对象后，就可以调用它提供的方法来添加数据行、插入数据行、删除数据行和移动数据行。PefaultTableMogel提供了如下几个方法来控制数据行操作：</p>
<pre><code class="java">addcolumn(object columnName)/addcolumnCobject columnName,object[]columnData）：添加一列
addRow（object[] rouData）：添加一行
insertRow（introw，Object[]rowData）：指定位置处插入一行
removeRow（introw）：删除一行
movgRow（intstart，intend，intto）：移动指定范围内的数据行
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>-JavaGUI -笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>血染钟楼教派与紫罗兰技能</title>
    <url>/%E6%A1%8C%E6%B8%B8/%E8%A1%80%E6%9F%93%E9%92%9F%E6%A5%BC/%E8%A1%80%E6%9F%93%E9%92%9F%E6%A5%BC%E6%95%99%E6%B4%BE%E4%B8%8E%E7%B4%AB%E7%BD%97%E5%85%B0%E6%8A%80%E8%83%BD/</url>
    <content><![CDATA[<div style="background-color:#afb4db color:" black"">
<div style="background-color:black">
红色字体角色表名该角色技能第一晚不能使用<br>
绿色字体角色名表示该角色技能整局游戏只能生效一次
</div>

<hr>
<style>
    h4 {
        display: flex;
        flex-direction: row;
    }
            
    h4:before,
    h4:after {
        content: "";
        flex: 1 1;
        border-bottom: 2px solid #000;
        margin: auto;
    }        
</style>

<h4>村民</h4>
<font color="green">钟&ensp;表&ensp;匠</font>：<span>游戏开始时，你得知恶魔与距他最近的爪牙之间的距离。<br>
入&ensp;梦&ensp;人：每个夜晚，选择一名其他玩家，你得知一个善良身份和一个邪恶身份，其中一个是他的身份。
耍&ensp;蛇&ensp;人：每个夜晚，选择一名存活玩家，当你选中一名恶魔时，交换你和他的身份以及阵营，然后，他中毒。<br>
数&ensp;学&ensp;家：每个夜晚，你得知有多少玩家的技能因为其他玩家的技能未正常生效。(从拂晓开始算起)<br>
<font color="red">花&ensp;艺&ensp;师</font>：每个夜晚，你得知恶魔在白天是否进行了投票。<br>
<font color="red">传&ensp;令&ensp;员</font>：每个夜晚，你得知爪牙在白天是否发起了提名。<br>
<font color="red">祭&emsp;&emsp;司</font>：每个夜晚，你得知死去的玩家有多少名属于邪恶阵营。<br>
学&emsp;&emsp;者：每个白天，拜访说书人并获得两条信息，其中一条是正确的，一条是错误的。<br>
<font color="green">裁&emsp;&emsp;缝</font>：整局游戏限一次，夜晚，选择两名其他玩家，得知他们是否属于同一阵营。<br>
<font color="green">哲&ensp;学&ensp;家</font>：整局游戏限一次，夜晚，选择一个善良身份，获得他的技能，如果有玩家为该身份，他醉酒。<br>
<font color="green">艺&ensp;术&ensp;家</font>：整局游戏限一次，白天，私下询问说书人一个"是/否"的问题。<br>
<font color="green">贤&emsp;&emsp;者</font>：当恶魔杀害你时，你得知两名玩家，其中一名是恶魔。<br>
<font color="green">杂技演员</font>：你的第一天白天，公开猜测之多5名玩家的身份，当晚，你将会得知猜对了多少个。<br>
</span></div>

<hr>
<h4>外来者</h4>
<p>
<font color="green">变种人</font>：当你对“我是外来者”疯狂时，你可能会被处决。<br>
<font color="green">意中人</font>：当你死亡时，一名玩家醉酒。<br>
<font color="green">理发师</font>：如果你死亡，恶魔在当晚可以选择两名玩家交换身份。（不可以交换自己外的其他恶魔）<br>
<font color="green">笨&emsp;蛋</font>：当你得知你死亡时，公开选择一名活着的玩家，如果他属于邪恶阵营，你的阵营落败。<br>
</p>

<hr>
<h4>爪牙</h4>
<p>
<font color="red">女&emsp;&emsp;巫</font>：每个夜晚选择一名玩家，如果他在明天发起了提名，他死亡。场上剩下三名玩家存活时，你失去该技能<br>
<font color="red">炼&ensp;药&ensp;师</font>：每个夜晚，选择一名玩家和一个身份，他变为该身份伽不存在。如果你创造了一个恶魔，当晚所有恶魔将随机行动。<br>
<font color="green">黑白双子</font>：你与一名对立阵营的玩家互知。如果其中的善良玩家被处决，邪恶阵营获胜。当两个双子均存活时善良阵营不能获胜。<br>
洗师：每个夜晚，选择一名玩家和一个善良身份，明天他需要对“他是这个身份”疯狂，否则他可能会被处决
</p>

<hr>
<h4>恶魔</h4>
<p>
<font color="red">染&emsp;魂</font>：每个夜晚，选择一名玩家，将他杀害。当染魂第一次杀死外来者时，他变为一个邪恶的染魂，你死亡。[+1外来者]<br>
<font color="red">巫&emsp;妖</font>：每个夜晚，选择一名玩家，将他杀害。被你杀害的爪牙保留技能，并且一名与他相邻的村民中毒。[-1外来者]<br>
<font color="red">混&emsp;沌</font>：每个夜晚，选择一名玩家，将他杀害。村民的技能必定获取错误信息。每个白天，如果没有玩家被处决,邪恶阵营获胜。<br>
<font color="red">蚀魂魔</font>：每个夜晚*，选择一名玩家，将他杀害。与你相邻的村民中毒。
</p>



]]></content>
      <categories>
        <category>桌游</category>
        <category>血染钟楼</category>
      </categories>
      <tags>
        <tag>血染钟楼 桌游</tag>
      </tags>
  </entry>
</search>
